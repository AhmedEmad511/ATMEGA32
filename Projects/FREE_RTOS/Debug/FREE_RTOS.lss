
FREE_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000427c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000122  00800060  0000427c  00004310  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000047e  00800182  00800182  00004432  2**0
                  ALLOC
  3 .stab         0000546c  00000000  00000000  00004434  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002e68  00000000  00000000  000098a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000180  00000000  00000000  0000c708  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001d1  00000000  00000000  0000c888  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002010  00000000  00000000  0000ca59  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001161  00000000  00000000  0000ea69  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001003  00000000  00000000  0000fbca  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001a0  00000000  00000000  00010bd0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002be  00000000  00000000  00010d70  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000090e  00000000  00000000  0001102e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001193c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 1b 15 	jmp	0x2a36	; 0x2a36 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e7       	ldi	r30, 0x7C	; 124
      68:	f2 e4       	ldi	r31, 0x42	; 66
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 38       	cpi	r26, 0x82	; 130
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a2 e8       	ldi	r26, 0x82	; 130
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 30       	cpi	r26, 0x00	; 0
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <main>
      8a:	0c 94 3c 21 	jmp	0x4278	; 0x4278 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 07 04 	call	0x80e	; 0x80e <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 07 04 	call	0x80e	; 0x80e <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 e6 20 	jmp	0x41cc	; 0x41cc <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a7 e7       	ldi	r26, 0x77	; 119
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 02 21 	jmp	0x4204	; 0x4204 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 f2 20 	jmp	0x41e4	; 0x41e4 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 aa 04 	call	0x954	; 0x954 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 0e 21 	jmp	0x421c	; 0x421c <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 f2 20 	jmp	0x41e4	; 0x41e4 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 aa 04 	call	0x954	; 0x954 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 0e 21 	jmp	0x421c	; 0x421c <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 e6 20 	jmp	0x41cc	; 0x41cc <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	87 e7       	ldi	r24, 0x77	; 119
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 aa 04 	call	0x954	; 0x954 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 02 21 	jmp	0x4204	; 0x4204 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 f2 20 	jmp	0x41e4	; 0x41e4 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 f7 05 	call	0xbee	; 0xbee <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 0e 21 	jmp	0x421c	; 0x421c <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 f2 20 	jmp	0x41e4	; 0x41e4 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 f7 05 	call	0xbee	; 0xbee <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 0e 21 	jmp	0x421c	; 0x421c <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 f2 20 	jmp	0x41e4	; 0x41e4 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 f7 05 	call	0xbee	; 0xbee <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 0e 21 	jmp	0x421c	; 0x421c <__epilogue_restores__+0x18>

00000752 <__floatsisf>:
     752:	a8 e0       	ldi	r26, 0x08	; 8
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 ef 20 	jmp	0x41de	; 0x41de <__prologue_saves__+0x12>
     75e:	9b 01       	movw	r18, r22
     760:	ac 01       	movw	r20, r24
     762:	83 e0       	ldi	r24, 0x03	; 3
     764:	89 83       	std	Y+1, r24	; 0x01
     766:	da 01       	movw	r26, r20
     768:	c9 01       	movw	r24, r18
     76a:	88 27       	eor	r24, r24
     76c:	b7 fd       	sbrc	r27, 7
     76e:	83 95       	inc	r24
     770:	99 27       	eor	r25, r25
     772:	aa 27       	eor	r26, r26
     774:	bb 27       	eor	r27, r27
     776:	b8 2e       	mov	r11, r24
     778:	21 15       	cp	r18, r1
     77a:	31 05       	cpc	r19, r1
     77c:	41 05       	cpc	r20, r1
     77e:	51 05       	cpc	r21, r1
     780:	19 f4       	brne	.+6      	; 0x788 <__floatsisf+0x36>
     782:	82 e0       	ldi	r24, 0x02	; 2
     784:	89 83       	std	Y+1, r24	; 0x01
     786:	3a c0       	rjmp	.+116    	; 0x7fc <__floatsisf+0xaa>
     788:	88 23       	and	r24, r24
     78a:	a9 f0       	breq	.+42     	; 0x7b6 <__floatsisf+0x64>
     78c:	20 30       	cpi	r18, 0x00	; 0
     78e:	80 e0       	ldi	r24, 0x00	; 0
     790:	38 07       	cpc	r19, r24
     792:	80 e0       	ldi	r24, 0x00	; 0
     794:	48 07       	cpc	r20, r24
     796:	80 e8       	ldi	r24, 0x80	; 128
     798:	58 07       	cpc	r21, r24
     79a:	29 f4       	brne	.+10     	; 0x7a6 <__floatsisf+0x54>
     79c:	60 e0       	ldi	r22, 0x00	; 0
     79e:	70 e0       	ldi	r23, 0x00	; 0
     7a0:	80 e0       	ldi	r24, 0x00	; 0
     7a2:	9f ec       	ldi	r25, 0xCF	; 207
     7a4:	30 c0       	rjmp	.+96     	; 0x806 <__floatsisf+0xb4>
     7a6:	ee 24       	eor	r14, r14
     7a8:	ff 24       	eor	r15, r15
     7aa:	87 01       	movw	r16, r14
     7ac:	e2 1a       	sub	r14, r18
     7ae:	f3 0a       	sbc	r15, r19
     7b0:	04 0b       	sbc	r16, r20
     7b2:	15 0b       	sbc	r17, r21
     7b4:	02 c0       	rjmp	.+4      	; 0x7ba <__floatsisf+0x68>
     7b6:	79 01       	movw	r14, r18
     7b8:	8a 01       	movw	r16, r20
     7ba:	8e e1       	ldi	r24, 0x1E	; 30
     7bc:	c8 2e       	mov	r12, r24
     7be:	d1 2c       	mov	r13, r1
     7c0:	dc 82       	std	Y+4, r13	; 0x04
     7c2:	cb 82       	std	Y+3, r12	; 0x03
     7c4:	ed 82       	std	Y+5, r14	; 0x05
     7c6:	fe 82       	std	Y+6, r15	; 0x06
     7c8:	0f 83       	std	Y+7, r16	; 0x07
     7ca:	18 87       	std	Y+8, r17	; 0x08
     7cc:	c8 01       	movw	r24, r16
     7ce:	b7 01       	movw	r22, r14
     7d0:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <__clzsi2>
     7d4:	01 97       	sbiw	r24, 0x01	; 1
     7d6:	18 16       	cp	r1, r24
     7d8:	19 06       	cpc	r1, r25
     7da:	84 f4       	brge	.+32     	; 0x7fc <__floatsisf+0xaa>
     7dc:	08 2e       	mov	r0, r24
     7de:	04 c0       	rjmp	.+8      	; 0x7e8 <__floatsisf+0x96>
     7e0:	ee 0c       	add	r14, r14
     7e2:	ff 1c       	adc	r15, r15
     7e4:	00 1f       	adc	r16, r16
     7e6:	11 1f       	adc	r17, r17
     7e8:	0a 94       	dec	r0
     7ea:	d2 f7       	brpl	.-12     	; 0x7e0 <__floatsisf+0x8e>
     7ec:	ed 82       	std	Y+5, r14	; 0x05
     7ee:	fe 82       	std	Y+6, r15	; 0x06
     7f0:	0f 83       	std	Y+7, r16	; 0x07
     7f2:	18 87       	std	Y+8, r17	; 0x08
     7f4:	c8 1a       	sub	r12, r24
     7f6:	d9 0a       	sbc	r13, r25
     7f8:	dc 82       	std	Y+4, r13	; 0x04
     7fa:	cb 82       	std	Y+3, r12	; 0x03
     7fc:	ba 82       	std	Y+2, r11	; 0x02
     7fe:	ce 01       	movw	r24, r28
     800:	01 96       	adiw	r24, 0x01	; 1
     802:	0e 94 aa 04 	call	0x954	; 0x954 <__pack_f>
     806:	28 96       	adiw	r28, 0x08	; 8
     808:	e9 e0       	ldi	r30, 0x09	; 9
     80a:	0c 94 0b 21 	jmp	0x4216	; 0x4216 <__epilogue_restores__+0x12>

0000080e <__fixsfsi>:
     80e:	ac e0       	ldi	r26, 0x0C	; 12
     810:	b0 e0       	ldi	r27, 0x00	; 0
     812:	ed e0       	ldi	r30, 0x0D	; 13
     814:	f4 e0       	ldi	r31, 0x04	; 4
     816:	0c 94 f6 20 	jmp	0x41ec	; 0x41ec <__prologue_saves__+0x20>
     81a:	69 83       	std	Y+1, r22	; 0x01
     81c:	7a 83       	std	Y+2, r23	; 0x02
     81e:	8b 83       	std	Y+3, r24	; 0x03
     820:	9c 83       	std	Y+4, r25	; 0x04
     822:	ce 01       	movw	r24, r28
     824:	01 96       	adiw	r24, 0x01	; 1
     826:	be 01       	movw	r22, r28
     828:	6b 5f       	subi	r22, 0xFB	; 251
     82a:	7f 4f       	sbci	r23, 0xFF	; 255
     82c:	0e 94 7f 05 	call	0xafe	; 0xafe <__unpack_f>
     830:	8d 81       	ldd	r24, Y+5	; 0x05
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	61 f1       	breq	.+88     	; 0x88e <__stack+0x2f>
     836:	82 30       	cpi	r24, 0x02	; 2
     838:	50 f1       	brcs	.+84     	; 0x88e <__stack+0x2f>
     83a:	84 30       	cpi	r24, 0x04	; 4
     83c:	21 f4       	brne	.+8      	; 0x846 <__fixsfsi+0x38>
     83e:	8e 81       	ldd	r24, Y+6	; 0x06
     840:	88 23       	and	r24, r24
     842:	51 f1       	breq	.+84     	; 0x898 <__stack+0x39>
     844:	2e c0       	rjmp	.+92     	; 0x8a2 <__stack+0x43>
     846:	2f 81       	ldd	r18, Y+7	; 0x07
     848:	38 85       	ldd	r19, Y+8	; 0x08
     84a:	37 fd       	sbrc	r19, 7
     84c:	20 c0       	rjmp	.+64     	; 0x88e <__stack+0x2f>
     84e:	6e 81       	ldd	r22, Y+6	; 0x06
     850:	2f 31       	cpi	r18, 0x1F	; 31
     852:	31 05       	cpc	r19, r1
     854:	1c f0       	brlt	.+6      	; 0x85c <__fixsfsi+0x4e>
     856:	66 23       	and	r22, r22
     858:	f9 f0       	breq	.+62     	; 0x898 <__stack+0x39>
     85a:	23 c0       	rjmp	.+70     	; 0x8a2 <__stack+0x43>
     85c:	8e e1       	ldi	r24, 0x1E	; 30
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	82 1b       	sub	r24, r18
     862:	93 0b       	sbc	r25, r19
     864:	29 85       	ldd	r18, Y+9	; 0x09
     866:	3a 85       	ldd	r19, Y+10	; 0x0a
     868:	4b 85       	ldd	r20, Y+11	; 0x0b
     86a:	5c 85       	ldd	r21, Y+12	; 0x0c
     86c:	04 c0       	rjmp	.+8      	; 0x876 <__stack+0x17>
     86e:	56 95       	lsr	r21
     870:	47 95       	ror	r20
     872:	37 95       	ror	r19
     874:	27 95       	ror	r18
     876:	8a 95       	dec	r24
     878:	d2 f7       	brpl	.-12     	; 0x86e <__stack+0xf>
     87a:	66 23       	and	r22, r22
     87c:	b1 f0       	breq	.+44     	; 0x8aa <__stack+0x4b>
     87e:	50 95       	com	r21
     880:	40 95       	com	r20
     882:	30 95       	com	r19
     884:	21 95       	neg	r18
     886:	3f 4f       	sbci	r19, 0xFF	; 255
     888:	4f 4f       	sbci	r20, 0xFF	; 255
     88a:	5f 4f       	sbci	r21, 0xFF	; 255
     88c:	0e c0       	rjmp	.+28     	; 0x8aa <__stack+0x4b>
     88e:	20 e0       	ldi	r18, 0x00	; 0
     890:	30 e0       	ldi	r19, 0x00	; 0
     892:	40 e0       	ldi	r20, 0x00	; 0
     894:	50 e0       	ldi	r21, 0x00	; 0
     896:	09 c0       	rjmp	.+18     	; 0x8aa <__stack+0x4b>
     898:	2f ef       	ldi	r18, 0xFF	; 255
     89a:	3f ef       	ldi	r19, 0xFF	; 255
     89c:	4f ef       	ldi	r20, 0xFF	; 255
     89e:	5f e7       	ldi	r21, 0x7F	; 127
     8a0:	04 c0       	rjmp	.+8      	; 0x8aa <__stack+0x4b>
     8a2:	20 e0       	ldi	r18, 0x00	; 0
     8a4:	30 e0       	ldi	r19, 0x00	; 0
     8a6:	40 e0       	ldi	r20, 0x00	; 0
     8a8:	50 e8       	ldi	r21, 0x80	; 128
     8aa:	b9 01       	movw	r22, r18
     8ac:	ca 01       	movw	r24, r20
     8ae:	2c 96       	adiw	r28, 0x0c	; 12
     8b0:	e2 e0       	ldi	r30, 0x02	; 2
     8b2:	0c 94 12 21 	jmp	0x4224	; 0x4224 <__epilogue_restores__+0x20>

000008b6 <__clzsi2>:
     8b6:	ef 92       	push	r14
     8b8:	ff 92       	push	r15
     8ba:	0f 93       	push	r16
     8bc:	1f 93       	push	r17
     8be:	7b 01       	movw	r14, r22
     8c0:	8c 01       	movw	r16, r24
     8c2:	80 e0       	ldi	r24, 0x00	; 0
     8c4:	e8 16       	cp	r14, r24
     8c6:	80 e0       	ldi	r24, 0x00	; 0
     8c8:	f8 06       	cpc	r15, r24
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	08 07       	cpc	r16, r24
     8ce:	80 e0       	ldi	r24, 0x00	; 0
     8d0:	18 07       	cpc	r17, r24
     8d2:	88 f4       	brcc	.+34     	; 0x8f6 <__clzsi2+0x40>
     8d4:	8f ef       	ldi	r24, 0xFF	; 255
     8d6:	e8 16       	cp	r14, r24
     8d8:	f1 04       	cpc	r15, r1
     8da:	01 05       	cpc	r16, r1
     8dc:	11 05       	cpc	r17, r1
     8de:	31 f0       	breq	.+12     	; 0x8ec <__clzsi2+0x36>
     8e0:	28 f0       	brcs	.+10     	; 0x8ec <__clzsi2+0x36>
     8e2:	88 e0       	ldi	r24, 0x08	; 8
     8e4:	90 e0       	ldi	r25, 0x00	; 0
     8e6:	a0 e0       	ldi	r26, 0x00	; 0
     8e8:	b0 e0       	ldi	r27, 0x00	; 0
     8ea:	17 c0       	rjmp	.+46     	; 0x91a <__clzsi2+0x64>
     8ec:	80 e0       	ldi	r24, 0x00	; 0
     8ee:	90 e0       	ldi	r25, 0x00	; 0
     8f0:	a0 e0       	ldi	r26, 0x00	; 0
     8f2:	b0 e0       	ldi	r27, 0x00	; 0
     8f4:	12 c0       	rjmp	.+36     	; 0x91a <__clzsi2+0x64>
     8f6:	80 e0       	ldi	r24, 0x00	; 0
     8f8:	e8 16       	cp	r14, r24
     8fa:	80 e0       	ldi	r24, 0x00	; 0
     8fc:	f8 06       	cpc	r15, r24
     8fe:	80 e0       	ldi	r24, 0x00	; 0
     900:	08 07       	cpc	r16, r24
     902:	81 e0       	ldi	r24, 0x01	; 1
     904:	18 07       	cpc	r17, r24
     906:	28 f0       	brcs	.+10     	; 0x912 <__clzsi2+0x5c>
     908:	88 e1       	ldi	r24, 0x18	; 24
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	a0 e0       	ldi	r26, 0x00	; 0
     90e:	b0 e0       	ldi	r27, 0x00	; 0
     910:	04 c0       	rjmp	.+8      	; 0x91a <__clzsi2+0x64>
     912:	80 e1       	ldi	r24, 0x10	; 16
     914:	90 e0       	ldi	r25, 0x00	; 0
     916:	a0 e0       	ldi	r26, 0x00	; 0
     918:	b0 e0       	ldi	r27, 0x00	; 0
     91a:	20 e2       	ldi	r18, 0x20	; 32
     91c:	30 e0       	ldi	r19, 0x00	; 0
     91e:	40 e0       	ldi	r20, 0x00	; 0
     920:	50 e0       	ldi	r21, 0x00	; 0
     922:	28 1b       	sub	r18, r24
     924:	39 0b       	sbc	r19, r25
     926:	4a 0b       	sbc	r20, r26
     928:	5b 0b       	sbc	r21, r27
     92a:	04 c0       	rjmp	.+8      	; 0x934 <__clzsi2+0x7e>
     92c:	16 95       	lsr	r17
     92e:	07 95       	ror	r16
     930:	f7 94       	ror	r15
     932:	e7 94       	ror	r14
     934:	8a 95       	dec	r24
     936:	d2 f7       	brpl	.-12     	; 0x92c <__clzsi2+0x76>
     938:	f7 01       	movw	r30, r14
     93a:	e1 58       	subi	r30, 0x81	; 129
     93c:	ff 4f       	sbci	r31, 0xFF	; 255
     93e:	80 81       	ld	r24, Z
     940:	28 1b       	sub	r18, r24
     942:	31 09       	sbc	r19, r1
     944:	41 09       	sbc	r20, r1
     946:	51 09       	sbc	r21, r1
     948:	c9 01       	movw	r24, r18
     94a:	1f 91       	pop	r17
     94c:	0f 91       	pop	r16
     94e:	ff 90       	pop	r15
     950:	ef 90       	pop	r14
     952:	08 95       	ret

00000954 <__pack_f>:
     954:	df 92       	push	r13
     956:	ef 92       	push	r14
     958:	ff 92       	push	r15
     95a:	0f 93       	push	r16
     95c:	1f 93       	push	r17
     95e:	fc 01       	movw	r30, r24
     960:	e4 80       	ldd	r14, Z+4	; 0x04
     962:	f5 80       	ldd	r15, Z+5	; 0x05
     964:	06 81       	ldd	r16, Z+6	; 0x06
     966:	17 81       	ldd	r17, Z+7	; 0x07
     968:	d1 80       	ldd	r13, Z+1	; 0x01
     96a:	80 81       	ld	r24, Z
     96c:	82 30       	cpi	r24, 0x02	; 2
     96e:	48 f4       	brcc	.+18     	; 0x982 <__pack_f+0x2e>
     970:	80 e0       	ldi	r24, 0x00	; 0
     972:	90 e0       	ldi	r25, 0x00	; 0
     974:	a0 e1       	ldi	r26, 0x10	; 16
     976:	b0 e0       	ldi	r27, 0x00	; 0
     978:	e8 2a       	or	r14, r24
     97a:	f9 2a       	or	r15, r25
     97c:	0a 2b       	or	r16, r26
     97e:	1b 2b       	or	r17, r27
     980:	a5 c0       	rjmp	.+330    	; 0xacc <__pack_f+0x178>
     982:	84 30       	cpi	r24, 0x04	; 4
     984:	09 f4       	brne	.+2      	; 0x988 <__pack_f+0x34>
     986:	9f c0       	rjmp	.+318    	; 0xac6 <__pack_f+0x172>
     988:	82 30       	cpi	r24, 0x02	; 2
     98a:	21 f4       	brne	.+8      	; 0x994 <__pack_f+0x40>
     98c:	ee 24       	eor	r14, r14
     98e:	ff 24       	eor	r15, r15
     990:	87 01       	movw	r16, r14
     992:	05 c0       	rjmp	.+10     	; 0x99e <__pack_f+0x4a>
     994:	e1 14       	cp	r14, r1
     996:	f1 04       	cpc	r15, r1
     998:	01 05       	cpc	r16, r1
     99a:	11 05       	cpc	r17, r1
     99c:	19 f4       	brne	.+6      	; 0x9a4 <__pack_f+0x50>
     99e:	e0 e0       	ldi	r30, 0x00	; 0
     9a0:	f0 e0       	ldi	r31, 0x00	; 0
     9a2:	96 c0       	rjmp	.+300    	; 0xad0 <__pack_f+0x17c>
     9a4:	62 81       	ldd	r22, Z+2	; 0x02
     9a6:	73 81       	ldd	r23, Z+3	; 0x03
     9a8:	9f ef       	ldi	r25, 0xFF	; 255
     9aa:	62 38       	cpi	r22, 0x82	; 130
     9ac:	79 07       	cpc	r23, r25
     9ae:	0c f0       	brlt	.+2      	; 0x9b2 <__pack_f+0x5e>
     9b0:	5b c0       	rjmp	.+182    	; 0xa68 <__pack_f+0x114>
     9b2:	22 e8       	ldi	r18, 0x82	; 130
     9b4:	3f ef       	ldi	r19, 0xFF	; 255
     9b6:	26 1b       	sub	r18, r22
     9b8:	37 0b       	sbc	r19, r23
     9ba:	2a 31       	cpi	r18, 0x1A	; 26
     9bc:	31 05       	cpc	r19, r1
     9be:	2c f0       	brlt	.+10     	; 0x9ca <__pack_f+0x76>
     9c0:	20 e0       	ldi	r18, 0x00	; 0
     9c2:	30 e0       	ldi	r19, 0x00	; 0
     9c4:	40 e0       	ldi	r20, 0x00	; 0
     9c6:	50 e0       	ldi	r21, 0x00	; 0
     9c8:	2a c0       	rjmp	.+84     	; 0xa1e <__pack_f+0xca>
     9ca:	b8 01       	movw	r22, r16
     9cc:	a7 01       	movw	r20, r14
     9ce:	02 2e       	mov	r0, r18
     9d0:	04 c0       	rjmp	.+8      	; 0x9da <__pack_f+0x86>
     9d2:	76 95       	lsr	r23
     9d4:	67 95       	ror	r22
     9d6:	57 95       	ror	r21
     9d8:	47 95       	ror	r20
     9da:	0a 94       	dec	r0
     9dc:	d2 f7       	brpl	.-12     	; 0x9d2 <__pack_f+0x7e>
     9de:	81 e0       	ldi	r24, 0x01	; 1
     9e0:	90 e0       	ldi	r25, 0x00	; 0
     9e2:	a0 e0       	ldi	r26, 0x00	; 0
     9e4:	b0 e0       	ldi	r27, 0x00	; 0
     9e6:	04 c0       	rjmp	.+8      	; 0x9f0 <__pack_f+0x9c>
     9e8:	88 0f       	add	r24, r24
     9ea:	99 1f       	adc	r25, r25
     9ec:	aa 1f       	adc	r26, r26
     9ee:	bb 1f       	adc	r27, r27
     9f0:	2a 95       	dec	r18
     9f2:	d2 f7       	brpl	.-12     	; 0x9e8 <__pack_f+0x94>
     9f4:	01 97       	sbiw	r24, 0x01	; 1
     9f6:	a1 09       	sbc	r26, r1
     9f8:	b1 09       	sbc	r27, r1
     9fa:	8e 21       	and	r24, r14
     9fc:	9f 21       	and	r25, r15
     9fe:	a0 23       	and	r26, r16
     a00:	b1 23       	and	r27, r17
     a02:	00 97       	sbiw	r24, 0x00	; 0
     a04:	a1 05       	cpc	r26, r1
     a06:	b1 05       	cpc	r27, r1
     a08:	21 f0       	breq	.+8      	; 0xa12 <__pack_f+0xbe>
     a0a:	81 e0       	ldi	r24, 0x01	; 1
     a0c:	90 e0       	ldi	r25, 0x00	; 0
     a0e:	a0 e0       	ldi	r26, 0x00	; 0
     a10:	b0 e0       	ldi	r27, 0x00	; 0
     a12:	9a 01       	movw	r18, r20
     a14:	ab 01       	movw	r20, r22
     a16:	28 2b       	or	r18, r24
     a18:	39 2b       	or	r19, r25
     a1a:	4a 2b       	or	r20, r26
     a1c:	5b 2b       	or	r21, r27
     a1e:	da 01       	movw	r26, r20
     a20:	c9 01       	movw	r24, r18
     a22:	8f 77       	andi	r24, 0x7F	; 127
     a24:	90 70       	andi	r25, 0x00	; 0
     a26:	a0 70       	andi	r26, 0x00	; 0
     a28:	b0 70       	andi	r27, 0x00	; 0
     a2a:	80 34       	cpi	r24, 0x40	; 64
     a2c:	91 05       	cpc	r25, r1
     a2e:	a1 05       	cpc	r26, r1
     a30:	b1 05       	cpc	r27, r1
     a32:	39 f4       	brne	.+14     	; 0xa42 <__pack_f+0xee>
     a34:	27 ff       	sbrs	r18, 7
     a36:	09 c0       	rjmp	.+18     	; 0xa4a <__pack_f+0xf6>
     a38:	20 5c       	subi	r18, 0xC0	; 192
     a3a:	3f 4f       	sbci	r19, 0xFF	; 255
     a3c:	4f 4f       	sbci	r20, 0xFF	; 255
     a3e:	5f 4f       	sbci	r21, 0xFF	; 255
     a40:	04 c0       	rjmp	.+8      	; 0xa4a <__pack_f+0xf6>
     a42:	21 5c       	subi	r18, 0xC1	; 193
     a44:	3f 4f       	sbci	r19, 0xFF	; 255
     a46:	4f 4f       	sbci	r20, 0xFF	; 255
     a48:	5f 4f       	sbci	r21, 0xFF	; 255
     a4a:	e0 e0       	ldi	r30, 0x00	; 0
     a4c:	f0 e0       	ldi	r31, 0x00	; 0
     a4e:	20 30       	cpi	r18, 0x00	; 0
     a50:	a0 e0       	ldi	r26, 0x00	; 0
     a52:	3a 07       	cpc	r19, r26
     a54:	a0 e0       	ldi	r26, 0x00	; 0
     a56:	4a 07       	cpc	r20, r26
     a58:	a0 e4       	ldi	r26, 0x40	; 64
     a5a:	5a 07       	cpc	r21, r26
     a5c:	10 f0       	brcs	.+4      	; 0xa62 <__pack_f+0x10e>
     a5e:	e1 e0       	ldi	r30, 0x01	; 1
     a60:	f0 e0       	ldi	r31, 0x00	; 0
     a62:	79 01       	movw	r14, r18
     a64:	8a 01       	movw	r16, r20
     a66:	27 c0       	rjmp	.+78     	; 0xab6 <__pack_f+0x162>
     a68:	60 38       	cpi	r22, 0x80	; 128
     a6a:	71 05       	cpc	r23, r1
     a6c:	64 f5       	brge	.+88     	; 0xac6 <__pack_f+0x172>
     a6e:	fb 01       	movw	r30, r22
     a70:	e1 58       	subi	r30, 0x81	; 129
     a72:	ff 4f       	sbci	r31, 0xFF	; 255
     a74:	d8 01       	movw	r26, r16
     a76:	c7 01       	movw	r24, r14
     a78:	8f 77       	andi	r24, 0x7F	; 127
     a7a:	90 70       	andi	r25, 0x00	; 0
     a7c:	a0 70       	andi	r26, 0x00	; 0
     a7e:	b0 70       	andi	r27, 0x00	; 0
     a80:	80 34       	cpi	r24, 0x40	; 64
     a82:	91 05       	cpc	r25, r1
     a84:	a1 05       	cpc	r26, r1
     a86:	b1 05       	cpc	r27, r1
     a88:	39 f4       	brne	.+14     	; 0xa98 <__pack_f+0x144>
     a8a:	e7 fe       	sbrs	r14, 7
     a8c:	0d c0       	rjmp	.+26     	; 0xaa8 <__pack_f+0x154>
     a8e:	80 e4       	ldi	r24, 0x40	; 64
     a90:	90 e0       	ldi	r25, 0x00	; 0
     a92:	a0 e0       	ldi	r26, 0x00	; 0
     a94:	b0 e0       	ldi	r27, 0x00	; 0
     a96:	04 c0       	rjmp	.+8      	; 0xaa0 <__pack_f+0x14c>
     a98:	8f e3       	ldi	r24, 0x3F	; 63
     a9a:	90 e0       	ldi	r25, 0x00	; 0
     a9c:	a0 e0       	ldi	r26, 0x00	; 0
     a9e:	b0 e0       	ldi	r27, 0x00	; 0
     aa0:	e8 0e       	add	r14, r24
     aa2:	f9 1e       	adc	r15, r25
     aa4:	0a 1f       	adc	r16, r26
     aa6:	1b 1f       	adc	r17, r27
     aa8:	17 ff       	sbrs	r17, 7
     aaa:	05 c0       	rjmp	.+10     	; 0xab6 <__pack_f+0x162>
     aac:	16 95       	lsr	r17
     aae:	07 95       	ror	r16
     ab0:	f7 94       	ror	r15
     ab2:	e7 94       	ror	r14
     ab4:	31 96       	adiw	r30, 0x01	; 1
     ab6:	87 e0       	ldi	r24, 0x07	; 7
     ab8:	16 95       	lsr	r17
     aba:	07 95       	ror	r16
     abc:	f7 94       	ror	r15
     abe:	e7 94       	ror	r14
     ac0:	8a 95       	dec	r24
     ac2:	d1 f7       	brne	.-12     	; 0xab8 <__pack_f+0x164>
     ac4:	05 c0       	rjmp	.+10     	; 0xad0 <__pack_f+0x17c>
     ac6:	ee 24       	eor	r14, r14
     ac8:	ff 24       	eor	r15, r15
     aca:	87 01       	movw	r16, r14
     acc:	ef ef       	ldi	r30, 0xFF	; 255
     ace:	f0 e0       	ldi	r31, 0x00	; 0
     ad0:	6e 2f       	mov	r22, r30
     ad2:	67 95       	ror	r22
     ad4:	66 27       	eor	r22, r22
     ad6:	67 95       	ror	r22
     ad8:	90 2f       	mov	r25, r16
     ada:	9f 77       	andi	r25, 0x7F	; 127
     adc:	d7 94       	ror	r13
     ade:	dd 24       	eor	r13, r13
     ae0:	d7 94       	ror	r13
     ae2:	8e 2f       	mov	r24, r30
     ae4:	86 95       	lsr	r24
     ae6:	49 2f       	mov	r20, r25
     ae8:	46 2b       	or	r20, r22
     aea:	58 2f       	mov	r21, r24
     aec:	5d 29       	or	r21, r13
     aee:	b7 01       	movw	r22, r14
     af0:	ca 01       	movw	r24, r20
     af2:	1f 91       	pop	r17
     af4:	0f 91       	pop	r16
     af6:	ff 90       	pop	r15
     af8:	ef 90       	pop	r14
     afa:	df 90       	pop	r13
     afc:	08 95       	ret

00000afe <__unpack_f>:
     afe:	fc 01       	movw	r30, r24
     b00:	db 01       	movw	r26, r22
     b02:	40 81       	ld	r20, Z
     b04:	51 81       	ldd	r21, Z+1	; 0x01
     b06:	22 81       	ldd	r18, Z+2	; 0x02
     b08:	62 2f       	mov	r22, r18
     b0a:	6f 77       	andi	r22, 0x7F	; 127
     b0c:	70 e0       	ldi	r23, 0x00	; 0
     b0e:	22 1f       	adc	r18, r18
     b10:	22 27       	eor	r18, r18
     b12:	22 1f       	adc	r18, r18
     b14:	93 81       	ldd	r25, Z+3	; 0x03
     b16:	89 2f       	mov	r24, r25
     b18:	88 0f       	add	r24, r24
     b1a:	82 2b       	or	r24, r18
     b1c:	28 2f       	mov	r18, r24
     b1e:	30 e0       	ldi	r19, 0x00	; 0
     b20:	99 1f       	adc	r25, r25
     b22:	99 27       	eor	r25, r25
     b24:	99 1f       	adc	r25, r25
     b26:	11 96       	adiw	r26, 0x01	; 1
     b28:	9c 93       	st	X, r25
     b2a:	11 97       	sbiw	r26, 0x01	; 1
     b2c:	21 15       	cp	r18, r1
     b2e:	31 05       	cpc	r19, r1
     b30:	a9 f5       	brne	.+106    	; 0xb9c <__unpack_f+0x9e>
     b32:	41 15       	cp	r20, r1
     b34:	51 05       	cpc	r21, r1
     b36:	61 05       	cpc	r22, r1
     b38:	71 05       	cpc	r23, r1
     b3a:	11 f4       	brne	.+4      	; 0xb40 <__unpack_f+0x42>
     b3c:	82 e0       	ldi	r24, 0x02	; 2
     b3e:	37 c0       	rjmp	.+110    	; 0xbae <__unpack_f+0xb0>
     b40:	82 e8       	ldi	r24, 0x82	; 130
     b42:	9f ef       	ldi	r25, 0xFF	; 255
     b44:	13 96       	adiw	r26, 0x03	; 3
     b46:	9c 93       	st	X, r25
     b48:	8e 93       	st	-X, r24
     b4a:	12 97       	sbiw	r26, 0x02	; 2
     b4c:	9a 01       	movw	r18, r20
     b4e:	ab 01       	movw	r20, r22
     b50:	67 e0       	ldi	r22, 0x07	; 7
     b52:	22 0f       	add	r18, r18
     b54:	33 1f       	adc	r19, r19
     b56:	44 1f       	adc	r20, r20
     b58:	55 1f       	adc	r21, r21
     b5a:	6a 95       	dec	r22
     b5c:	d1 f7       	brne	.-12     	; 0xb52 <__unpack_f+0x54>
     b5e:	83 e0       	ldi	r24, 0x03	; 3
     b60:	8c 93       	st	X, r24
     b62:	0d c0       	rjmp	.+26     	; 0xb7e <__unpack_f+0x80>
     b64:	22 0f       	add	r18, r18
     b66:	33 1f       	adc	r19, r19
     b68:	44 1f       	adc	r20, r20
     b6a:	55 1f       	adc	r21, r21
     b6c:	12 96       	adiw	r26, 0x02	; 2
     b6e:	8d 91       	ld	r24, X+
     b70:	9c 91       	ld	r25, X
     b72:	13 97       	sbiw	r26, 0x03	; 3
     b74:	01 97       	sbiw	r24, 0x01	; 1
     b76:	13 96       	adiw	r26, 0x03	; 3
     b78:	9c 93       	st	X, r25
     b7a:	8e 93       	st	-X, r24
     b7c:	12 97       	sbiw	r26, 0x02	; 2
     b7e:	20 30       	cpi	r18, 0x00	; 0
     b80:	80 e0       	ldi	r24, 0x00	; 0
     b82:	38 07       	cpc	r19, r24
     b84:	80 e0       	ldi	r24, 0x00	; 0
     b86:	48 07       	cpc	r20, r24
     b88:	80 e4       	ldi	r24, 0x40	; 64
     b8a:	58 07       	cpc	r21, r24
     b8c:	58 f3       	brcs	.-42     	; 0xb64 <__unpack_f+0x66>
     b8e:	14 96       	adiw	r26, 0x04	; 4
     b90:	2d 93       	st	X+, r18
     b92:	3d 93       	st	X+, r19
     b94:	4d 93       	st	X+, r20
     b96:	5c 93       	st	X, r21
     b98:	17 97       	sbiw	r26, 0x07	; 7
     b9a:	08 95       	ret
     b9c:	2f 3f       	cpi	r18, 0xFF	; 255
     b9e:	31 05       	cpc	r19, r1
     ba0:	79 f4       	brne	.+30     	; 0xbc0 <__unpack_f+0xc2>
     ba2:	41 15       	cp	r20, r1
     ba4:	51 05       	cpc	r21, r1
     ba6:	61 05       	cpc	r22, r1
     ba8:	71 05       	cpc	r23, r1
     baa:	19 f4       	brne	.+6      	; 0xbb2 <__unpack_f+0xb4>
     bac:	84 e0       	ldi	r24, 0x04	; 4
     bae:	8c 93       	st	X, r24
     bb0:	08 95       	ret
     bb2:	64 ff       	sbrs	r22, 4
     bb4:	03 c0       	rjmp	.+6      	; 0xbbc <__unpack_f+0xbe>
     bb6:	81 e0       	ldi	r24, 0x01	; 1
     bb8:	8c 93       	st	X, r24
     bba:	12 c0       	rjmp	.+36     	; 0xbe0 <__unpack_f+0xe2>
     bbc:	1c 92       	st	X, r1
     bbe:	10 c0       	rjmp	.+32     	; 0xbe0 <__unpack_f+0xe2>
     bc0:	2f 57       	subi	r18, 0x7F	; 127
     bc2:	30 40       	sbci	r19, 0x00	; 0
     bc4:	13 96       	adiw	r26, 0x03	; 3
     bc6:	3c 93       	st	X, r19
     bc8:	2e 93       	st	-X, r18
     bca:	12 97       	sbiw	r26, 0x02	; 2
     bcc:	83 e0       	ldi	r24, 0x03	; 3
     bce:	8c 93       	st	X, r24
     bd0:	87 e0       	ldi	r24, 0x07	; 7
     bd2:	44 0f       	add	r20, r20
     bd4:	55 1f       	adc	r21, r21
     bd6:	66 1f       	adc	r22, r22
     bd8:	77 1f       	adc	r23, r23
     bda:	8a 95       	dec	r24
     bdc:	d1 f7       	brne	.-12     	; 0xbd2 <__unpack_f+0xd4>
     bde:	70 64       	ori	r23, 0x40	; 64
     be0:	14 96       	adiw	r26, 0x04	; 4
     be2:	4d 93       	st	X+, r20
     be4:	5d 93       	st	X+, r21
     be6:	6d 93       	st	X+, r22
     be8:	7c 93       	st	X, r23
     bea:	17 97       	sbiw	r26, 0x07	; 7
     bec:	08 95       	ret

00000bee <__fpcmp_parts_f>:
     bee:	1f 93       	push	r17
     bf0:	dc 01       	movw	r26, r24
     bf2:	fb 01       	movw	r30, r22
     bf4:	9c 91       	ld	r25, X
     bf6:	92 30       	cpi	r25, 0x02	; 2
     bf8:	08 f4       	brcc	.+2      	; 0xbfc <__fpcmp_parts_f+0xe>
     bfa:	47 c0       	rjmp	.+142    	; 0xc8a <__fpcmp_parts_f+0x9c>
     bfc:	80 81       	ld	r24, Z
     bfe:	82 30       	cpi	r24, 0x02	; 2
     c00:	08 f4       	brcc	.+2      	; 0xc04 <__fpcmp_parts_f+0x16>
     c02:	43 c0       	rjmp	.+134    	; 0xc8a <__fpcmp_parts_f+0x9c>
     c04:	94 30       	cpi	r25, 0x04	; 4
     c06:	51 f4       	brne	.+20     	; 0xc1c <__fpcmp_parts_f+0x2e>
     c08:	11 96       	adiw	r26, 0x01	; 1
     c0a:	1c 91       	ld	r17, X
     c0c:	84 30       	cpi	r24, 0x04	; 4
     c0e:	99 f5       	brne	.+102    	; 0xc76 <__fpcmp_parts_f+0x88>
     c10:	81 81       	ldd	r24, Z+1	; 0x01
     c12:	68 2f       	mov	r22, r24
     c14:	70 e0       	ldi	r23, 0x00	; 0
     c16:	61 1b       	sub	r22, r17
     c18:	71 09       	sbc	r23, r1
     c1a:	3f c0       	rjmp	.+126    	; 0xc9a <__fpcmp_parts_f+0xac>
     c1c:	84 30       	cpi	r24, 0x04	; 4
     c1e:	21 f0       	breq	.+8      	; 0xc28 <__fpcmp_parts_f+0x3a>
     c20:	92 30       	cpi	r25, 0x02	; 2
     c22:	31 f4       	brne	.+12     	; 0xc30 <__fpcmp_parts_f+0x42>
     c24:	82 30       	cpi	r24, 0x02	; 2
     c26:	b9 f1       	breq	.+110    	; 0xc96 <__fpcmp_parts_f+0xa8>
     c28:	81 81       	ldd	r24, Z+1	; 0x01
     c2a:	88 23       	and	r24, r24
     c2c:	89 f1       	breq	.+98     	; 0xc90 <__fpcmp_parts_f+0xa2>
     c2e:	2d c0       	rjmp	.+90     	; 0xc8a <__fpcmp_parts_f+0x9c>
     c30:	11 96       	adiw	r26, 0x01	; 1
     c32:	1c 91       	ld	r17, X
     c34:	11 97       	sbiw	r26, 0x01	; 1
     c36:	82 30       	cpi	r24, 0x02	; 2
     c38:	f1 f0       	breq	.+60     	; 0xc76 <__fpcmp_parts_f+0x88>
     c3a:	81 81       	ldd	r24, Z+1	; 0x01
     c3c:	18 17       	cp	r17, r24
     c3e:	d9 f4       	brne	.+54     	; 0xc76 <__fpcmp_parts_f+0x88>
     c40:	12 96       	adiw	r26, 0x02	; 2
     c42:	2d 91       	ld	r18, X+
     c44:	3c 91       	ld	r19, X
     c46:	13 97       	sbiw	r26, 0x03	; 3
     c48:	82 81       	ldd	r24, Z+2	; 0x02
     c4a:	93 81       	ldd	r25, Z+3	; 0x03
     c4c:	82 17       	cp	r24, r18
     c4e:	93 07       	cpc	r25, r19
     c50:	94 f0       	brlt	.+36     	; 0xc76 <__fpcmp_parts_f+0x88>
     c52:	28 17       	cp	r18, r24
     c54:	39 07       	cpc	r19, r25
     c56:	bc f0       	brlt	.+46     	; 0xc86 <__fpcmp_parts_f+0x98>
     c58:	14 96       	adiw	r26, 0x04	; 4
     c5a:	8d 91       	ld	r24, X+
     c5c:	9d 91       	ld	r25, X+
     c5e:	0d 90       	ld	r0, X+
     c60:	bc 91       	ld	r27, X
     c62:	a0 2d       	mov	r26, r0
     c64:	24 81       	ldd	r18, Z+4	; 0x04
     c66:	35 81       	ldd	r19, Z+5	; 0x05
     c68:	46 81       	ldd	r20, Z+6	; 0x06
     c6a:	57 81       	ldd	r21, Z+7	; 0x07
     c6c:	28 17       	cp	r18, r24
     c6e:	39 07       	cpc	r19, r25
     c70:	4a 07       	cpc	r20, r26
     c72:	5b 07       	cpc	r21, r27
     c74:	18 f4       	brcc	.+6      	; 0xc7c <__fpcmp_parts_f+0x8e>
     c76:	11 23       	and	r17, r17
     c78:	41 f0       	breq	.+16     	; 0xc8a <__fpcmp_parts_f+0x9c>
     c7a:	0a c0       	rjmp	.+20     	; 0xc90 <__fpcmp_parts_f+0xa2>
     c7c:	82 17       	cp	r24, r18
     c7e:	93 07       	cpc	r25, r19
     c80:	a4 07       	cpc	r26, r20
     c82:	b5 07       	cpc	r27, r21
     c84:	40 f4       	brcc	.+16     	; 0xc96 <__fpcmp_parts_f+0xa8>
     c86:	11 23       	and	r17, r17
     c88:	19 f0       	breq	.+6      	; 0xc90 <__fpcmp_parts_f+0xa2>
     c8a:	61 e0       	ldi	r22, 0x01	; 1
     c8c:	70 e0       	ldi	r23, 0x00	; 0
     c8e:	05 c0       	rjmp	.+10     	; 0xc9a <__fpcmp_parts_f+0xac>
     c90:	6f ef       	ldi	r22, 0xFF	; 255
     c92:	7f ef       	ldi	r23, 0xFF	; 255
     c94:	02 c0       	rjmp	.+4      	; 0xc9a <__fpcmp_parts_f+0xac>
     c96:	60 e0       	ldi	r22, 0x00	; 0
     c98:	70 e0       	ldi	r23, 0x00	; 0
     c9a:	cb 01       	movw	r24, r22
     c9c:	1f 91       	pop	r17
     c9e:	08 95       	ret

00000ca0 <DIO_u8SetPinDirection>:
/*********************************************************************************/

#include "DIO_interface.h"

u8 DIO_u8SetPinDirection(u8 Copy_u8Port, u8 Copy_u8Pin ,u8 Copy_u8Direction)
{
     ca0:	df 93       	push	r29
     ca2:	cf 93       	push	r28
     ca4:	cd b7       	in	r28, 0x3d	; 61
     ca6:	de b7       	in	r29, 0x3e	; 62
     ca8:	28 97       	sbiw	r28, 0x08	; 8
     caa:	0f b6       	in	r0, 0x3f	; 63
     cac:	f8 94       	cli
     cae:	de bf       	out	0x3e, r29	; 62
     cb0:	0f be       	out	0x3f, r0	; 63
     cb2:	cd bf       	out	0x3d, r28	; 61
     cb4:	8a 83       	std	Y+2, r24	; 0x02
     cb6:	6b 83       	std	Y+3, r22	; 0x03
     cb8:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState = 0;
     cba:	19 82       	std	Y+1, r1	; 0x01
	if (Copy_u8Pin > 7)
     cbc:	8b 81       	ldd	r24, Y+3	; 0x03
     cbe:	88 30       	cpi	r24, 0x08	; 8
     cc0:	10 f0       	brcs	.+4      	; 0xcc6 <DIO_u8SetPinDirection+0x26>
		Local_u8ErrorState = 1;
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8Direction == INPUT)
     cc6:	8c 81       	ldd	r24, Y+4	; 0x04
     cc8:	88 23       	and	r24, r24
     cca:	09 f0       	breq	.+2      	; 0xcce <DIO_u8SetPinDirection+0x2e>
     ccc:	78 c0       	rjmp	.+240    	; 0xdbe <DIO_u8SetPinDirection+0x11e>
	{
		switch (Copy_u8Port)
     cce:	8a 81       	ldd	r24, Y+2	; 0x02
     cd0:	28 2f       	mov	r18, r24
     cd2:	30 e0       	ldi	r19, 0x00	; 0
     cd4:	38 87       	std	Y+8, r19	; 0x08
     cd6:	2f 83       	std	Y+7, r18	; 0x07
     cd8:	8f 81       	ldd	r24, Y+7	; 0x07
     cda:	98 85       	ldd	r25, Y+8	; 0x08
     cdc:	82 30       	cpi	r24, 0x02	; 2
     cde:	91 05       	cpc	r25, r1
     ce0:	61 f1       	breq	.+88     	; 0xd3a <DIO_u8SetPinDirection+0x9a>
     ce2:	2f 81       	ldd	r18, Y+7	; 0x07
     ce4:	38 85       	ldd	r19, Y+8	; 0x08
     ce6:	23 30       	cpi	r18, 0x03	; 3
     ce8:	31 05       	cpc	r19, r1
     cea:	34 f4       	brge	.+12     	; 0xcf8 <DIO_u8SetPinDirection+0x58>
     cec:	8f 81       	ldd	r24, Y+7	; 0x07
     cee:	98 85       	ldd	r25, Y+8	; 0x08
     cf0:	81 30       	cpi	r24, 0x01	; 1
     cf2:	91 05       	cpc	r25, r1
     cf4:	69 f0       	breq	.+26     	; 0xd10 <DIO_u8SetPinDirection+0x70>
     cf6:	60 c0       	rjmp	.+192    	; 0xdb8 <DIO_u8SetPinDirection+0x118>
     cf8:	2f 81       	ldd	r18, Y+7	; 0x07
     cfa:	38 85       	ldd	r19, Y+8	; 0x08
     cfc:	23 30       	cpi	r18, 0x03	; 3
     cfe:	31 05       	cpc	r19, r1
     d00:	89 f1       	breq	.+98     	; 0xd64 <DIO_u8SetPinDirection+0xc4>
     d02:	8f 81       	ldd	r24, Y+7	; 0x07
     d04:	98 85       	ldd	r25, Y+8	; 0x08
     d06:	84 30       	cpi	r24, 0x04	; 4
     d08:	91 05       	cpc	r25, r1
     d0a:	09 f4       	brne	.+2      	; 0xd0e <DIO_u8SetPinDirection+0x6e>
     d0c:	40 c0       	rjmp	.+128    	; 0xd8e <DIO_u8SetPinDirection+0xee>
     d0e:	54 c0       	rjmp	.+168    	; 0xdb8 <DIO_u8SetPinDirection+0x118>
		{
		case PORT_A :
			CLR_BIT(DDRA,Copy_u8Pin);
     d10:	aa e3       	ldi	r26, 0x3A	; 58
     d12:	b0 e0       	ldi	r27, 0x00	; 0
     d14:	ea e3       	ldi	r30, 0x3A	; 58
     d16:	f0 e0       	ldi	r31, 0x00	; 0
     d18:	80 81       	ld	r24, Z
     d1a:	48 2f       	mov	r20, r24
     d1c:	8b 81       	ldd	r24, Y+3	; 0x03
     d1e:	28 2f       	mov	r18, r24
     d20:	30 e0       	ldi	r19, 0x00	; 0
     d22:	81 e0       	ldi	r24, 0x01	; 1
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	02 2e       	mov	r0, r18
     d28:	02 c0       	rjmp	.+4      	; 0xd2e <DIO_u8SetPinDirection+0x8e>
     d2a:	88 0f       	add	r24, r24
     d2c:	99 1f       	adc	r25, r25
     d2e:	0a 94       	dec	r0
     d30:	e2 f7       	brpl	.-8      	; 0xd2a <DIO_u8SetPinDirection+0x8a>
     d32:	80 95       	com	r24
     d34:	84 23       	and	r24, r20
     d36:	8c 93       	st	X, r24
     d38:	bb c0       	rjmp	.+374    	; 0xeb0 <DIO_u8SetPinDirection+0x210>
			break;
		case PORT_B :
			CLR_BIT(DDRB,Copy_u8Pin);
     d3a:	a7 e3       	ldi	r26, 0x37	; 55
     d3c:	b0 e0       	ldi	r27, 0x00	; 0
     d3e:	e7 e3       	ldi	r30, 0x37	; 55
     d40:	f0 e0       	ldi	r31, 0x00	; 0
     d42:	80 81       	ld	r24, Z
     d44:	48 2f       	mov	r20, r24
     d46:	8b 81       	ldd	r24, Y+3	; 0x03
     d48:	28 2f       	mov	r18, r24
     d4a:	30 e0       	ldi	r19, 0x00	; 0
     d4c:	81 e0       	ldi	r24, 0x01	; 1
     d4e:	90 e0       	ldi	r25, 0x00	; 0
     d50:	02 2e       	mov	r0, r18
     d52:	02 c0       	rjmp	.+4      	; 0xd58 <DIO_u8SetPinDirection+0xb8>
     d54:	88 0f       	add	r24, r24
     d56:	99 1f       	adc	r25, r25
     d58:	0a 94       	dec	r0
     d5a:	e2 f7       	brpl	.-8      	; 0xd54 <DIO_u8SetPinDirection+0xb4>
     d5c:	80 95       	com	r24
     d5e:	84 23       	and	r24, r20
     d60:	8c 93       	st	X, r24
     d62:	a6 c0       	rjmp	.+332    	; 0xeb0 <DIO_u8SetPinDirection+0x210>
			break;
		case PORT_C :
			CLR_BIT(DDRC,Copy_u8Pin);
     d64:	a4 e3       	ldi	r26, 0x34	; 52
     d66:	b0 e0       	ldi	r27, 0x00	; 0
     d68:	e4 e3       	ldi	r30, 0x34	; 52
     d6a:	f0 e0       	ldi	r31, 0x00	; 0
     d6c:	80 81       	ld	r24, Z
     d6e:	48 2f       	mov	r20, r24
     d70:	8b 81       	ldd	r24, Y+3	; 0x03
     d72:	28 2f       	mov	r18, r24
     d74:	30 e0       	ldi	r19, 0x00	; 0
     d76:	81 e0       	ldi	r24, 0x01	; 1
     d78:	90 e0       	ldi	r25, 0x00	; 0
     d7a:	02 2e       	mov	r0, r18
     d7c:	02 c0       	rjmp	.+4      	; 0xd82 <DIO_u8SetPinDirection+0xe2>
     d7e:	88 0f       	add	r24, r24
     d80:	99 1f       	adc	r25, r25
     d82:	0a 94       	dec	r0
     d84:	e2 f7       	brpl	.-8      	; 0xd7e <DIO_u8SetPinDirection+0xde>
     d86:	80 95       	com	r24
     d88:	84 23       	and	r24, r20
     d8a:	8c 93       	st	X, r24
     d8c:	91 c0       	rjmp	.+290    	; 0xeb0 <DIO_u8SetPinDirection+0x210>
			break;
		case PORT_D :
			CLR_BIT(DDRD,Copy_u8Pin);
     d8e:	a1 e3       	ldi	r26, 0x31	; 49
     d90:	b0 e0       	ldi	r27, 0x00	; 0
     d92:	e1 e3       	ldi	r30, 0x31	; 49
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	80 81       	ld	r24, Z
     d98:	48 2f       	mov	r20, r24
     d9a:	8b 81       	ldd	r24, Y+3	; 0x03
     d9c:	28 2f       	mov	r18, r24
     d9e:	30 e0       	ldi	r19, 0x00	; 0
     da0:	81 e0       	ldi	r24, 0x01	; 1
     da2:	90 e0       	ldi	r25, 0x00	; 0
     da4:	02 2e       	mov	r0, r18
     da6:	02 c0       	rjmp	.+4      	; 0xdac <DIO_u8SetPinDirection+0x10c>
     da8:	88 0f       	add	r24, r24
     daa:	99 1f       	adc	r25, r25
     dac:	0a 94       	dec	r0
     dae:	e2 f7       	brpl	.-8      	; 0xda8 <DIO_u8SetPinDirection+0x108>
     db0:	80 95       	com	r24
     db2:	84 23       	and	r24, r20
     db4:	8c 93       	st	X, r24
     db6:	7c c0       	rjmp	.+248    	; 0xeb0 <DIO_u8SetPinDirection+0x210>
			break;
		default:
			Local_u8ErrorState =1;
     db8:	81 e0       	ldi	r24, 0x01	; 1
     dba:	89 83       	std	Y+1, r24	; 0x01
     dbc:	79 c0       	rjmp	.+242    	; 0xeb0 <DIO_u8SetPinDirection+0x210>
			break;
		}
	}
	else if(Copy_u8Direction == OUTPUT)
     dbe:	8c 81       	ldd	r24, Y+4	; 0x04
     dc0:	81 30       	cpi	r24, 0x01	; 1
     dc2:	09 f0       	breq	.+2      	; 0xdc6 <DIO_u8SetPinDirection+0x126>
     dc4:	73 c0       	rjmp	.+230    	; 0xeac <DIO_u8SetPinDirection+0x20c>
	{
		switch (Copy_u8Port)
     dc6:	8a 81       	ldd	r24, Y+2	; 0x02
     dc8:	28 2f       	mov	r18, r24
     dca:	30 e0       	ldi	r19, 0x00	; 0
     dcc:	3e 83       	std	Y+6, r19	; 0x06
     dce:	2d 83       	std	Y+5, r18	; 0x05
     dd0:	8d 81       	ldd	r24, Y+5	; 0x05
     dd2:	9e 81       	ldd	r25, Y+6	; 0x06
     dd4:	82 30       	cpi	r24, 0x02	; 2
     dd6:	91 05       	cpc	r25, r1
     dd8:	51 f1       	breq	.+84     	; 0xe2e <DIO_u8SetPinDirection+0x18e>
     dda:	2d 81       	ldd	r18, Y+5	; 0x05
     ddc:	3e 81       	ldd	r19, Y+6	; 0x06
     dde:	23 30       	cpi	r18, 0x03	; 3
     de0:	31 05       	cpc	r19, r1
     de2:	34 f4       	brge	.+12     	; 0xdf0 <DIO_u8SetPinDirection+0x150>
     de4:	8d 81       	ldd	r24, Y+5	; 0x05
     de6:	9e 81       	ldd	r25, Y+6	; 0x06
     de8:	81 30       	cpi	r24, 0x01	; 1
     dea:	91 05       	cpc	r25, r1
     dec:	61 f0       	breq	.+24     	; 0xe06 <DIO_u8SetPinDirection+0x166>
     dee:	5b c0       	rjmp	.+182    	; 0xea6 <DIO_u8SetPinDirection+0x206>
     df0:	2d 81       	ldd	r18, Y+5	; 0x05
     df2:	3e 81       	ldd	r19, Y+6	; 0x06
     df4:	23 30       	cpi	r18, 0x03	; 3
     df6:	31 05       	cpc	r19, r1
     df8:	71 f1       	breq	.+92     	; 0xe56 <DIO_u8SetPinDirection+0x1b6>
     dfa:	8d 81       	ldd	r24, Y+5	; 0x05
     dfc:	9e 81       	ldd	r25, Y+6	; 0x06
     dfe:	84 30       	cpi	r24, 0x04	; 4
     e00:	91 05       	cpc	r25, r1
     e02:	e9 f1       	breq	.+122    	; 0xe7e <DIO_u8SetPinDirection+0x1de>
     e04:	50 c0       	rjmp	.+160    	; 0xea6 <DIO_u8SetPinDirection+0x206>
		{
		case PORT_A :
			SET_BIT(DDRA,Copy_u8Pin);
     e06:	aa e3       	ldi	r26, 0x3A	; 58
     e08:	b0 e0       	ldi	r27, 0x00	; 0
     e0a:	ea e3       	ldi	r30, 0x3A	; 58
     e0c:	f0 e0       	ldi	r31, 0x00	; 0
     e0e:	80 81       	ld	r24, Z
     e10:	48 2f       	mov	r20, r24
     e12:	8b 81       	ldd	r24, Y+3	; 0x03
     e14:	28 2f       	mov	r18, r24
     e16:	30 e0       	ldi	r19, 0x00	; 0
     e18:	81 e0       	ldi	r24, 0x01	; 1
     e1a:	90 e0       	ldi	r25, 0x00	; 0
     e1c:	02 2e       	mov	r0, r18
     e1e:	02 c0       	rjmp	.+4      	; 0xe24 <DIO_u8SetPinDirection+0x184>
     e20:	88 0f       	add	r24, r24
     e22:	99 1f       	adc	r25, r25
     e24:	0a 94       	dec	r0
     e26:	e2 f7       	brpl	.-8      	; 0xe20 <DIO_u8SetPinDirection+0x180>
     e28:	84 2b       	or	r24, r20
     e2a:	8c 93       	st	X, r24
     e2c:	41 c0       	rjmp	.+130    	; 0xeb0 <DIO_u8SetPinDirection+0x210>
			break;
		case PORT_B :
			SET_BIT(DDRB,Copy_u8Pin);
     e2e:	a7 e3       	ldi	r26, 0x37	; 55
     e30:	b0 e0       	ldi	r27, 0x00	; 0
     e32:	e7 e3       	ldi	r30, 0x37	; 55
     e34:	f0 e0       	ldi	r31, 0x00	; 0
     e36:	80 81       	ld	r24, Z
     e38:	48 2f       	mov	r20, r24
     e3a:	8b 81       	ldd	r24, Y+3	; 0x03
     e3c:	28 2f       	mov	r18, r24
     e3e:	30 e0       	ldi	r19, 0x00	; 0
     e40:	81 e0       	ldi	r24, 0x01	; 1
     e42:	90 e0       	ldi	r25, 0x00	; 0
     e44:	02 2e       	mov	r0, r18
     e46:	02 c0       	rjmp	.+4      	; 0xe4c <DIO_u8SetPinDirection+0x1ac>
     e48:	88 0f       	add	r24, r24
     e4a:	99 1f       	adc	r25, r25
     e4c:	0a 94       	dec	r0
     e4e:	e2 f7       	brpl	.-8      	; 0xe48 <DIO_u8SetPinDirection+0x1a8>
     e50:	84 2b       	or	r24, r20
     e52:	8c 93       	st	X, r24
     e54:	2d c0       	rjmp	.+90     	; 0xeb0 <DIO_u8SetPinDirection+0x210>
			break;
		case PORT_C :
			SET_BIT(DDRC,Copy_u8Pin);
     e56:	a4 e3       	ldi	r26, 0x34	; 52
     e58:	b0 e0       	ldi	r27, 0x00	; 0
     e5a:	e4 e3       	ldi	r30, 0x34	; 52
     e5c:	f0 e0       	ldi	r31, 0x00	; 0
     e5e:	80 81       	ld	r24, Z
     e60:	48 2f       	mov	r20, r24
     e62:	8b 81       	ldd	r24, Y+3	; 0x03
     e64:	28 2f       	mov	r18, r24
     e66:	30 e0       	ldi	r19, 0x00	; 0
     e68:	81 e0       	ldi	r24, 0x01	; 1
     e6a:	90 e0       	ldi	r25, 0x00	; 0
     e6c:	02 2e       	mov	r0, r18
     e6e:	02 c0       	rjmp	.+4      	; 0xe74 <DIO_u8SetPinDirection+0x1d4>
     e70:	88 0f       	add	r24, r24
     e72:	99 1f       	adc	r25, r25
     e74:	0a 94       	dec	r0
     e76:	e2 f7       	brpl	.-8      	; 0xe70 <DIO_u8SetPinDirection+0x1d0>
     e78:	84 2b       	or	r24, r20
     e7a:	8c 93       	st	X, r24
     e7c:	19 c0       	rjmp	.+50     	; 0xeb0 <DIO_u8SetPinDirection+0x210>
			break;
		case PORT_D :
			SET_BIT(DDRD,Copy_u8Pin);
     e7e:	a1 e3       	ldi	r26, 0x31	; 49
     e80:	b0 e0       	ldi	r27, 0x00	; 0
     e82:	e1 e3       	ldi	r30, 0x31	; 49
     e84:	f0 e0       	ldi	r31, 0x00	; 0
     e86:	80 81       	ld	r24, Z
     e88:	48 2f       	mov	r20, r24
     e8a:	8b 81       	ldd	r24, Y+3	; 0x03
     e8c:	28 2f       	mov	r18, r24
     e8e:	30 e0       	ldi	r19, 0x00	; 0
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	02 2e       	mov	r0, r18
     e96:	02 c0       	rjmp	.+4      	; 0xe9c <DIO_u8SetPinDirection+0x1fc>
     e98:	88 0f       	add	r24, r24
     e9a:	99 1f       	adc	r25, r25
     e9c:	0a 94       	dec	r0
     e9e:	e2 f7       	brpl	.-8      	; 0xe98 <DIO_u8SetPinDirection+0x1f8>
     ea0:	84 2b       	or	r24, r20
     ea2:	8c 93       	st	X, r24
     ea4:	05 c0       	rjmp	.+10     	; 0xeb0 <DIO_u8SetPinDirection+0x210>
			break;
		default:
			Local_u8ErrorState =1;
     ea6:	81 e0       	ldi	r24, 0x01	; 1
     ea8:	89 83       	std	Y+1, r24	; 0x01
     eaa:	02 c0       	rjmp	.+4      	; 0xeb0 <DIO_u8SetPinDirection+0x210>
			break;
		}
	}
	else
	{
		Local_u8ErrorState =1;
     eac:	81 e0       	ldi	r24, 0x01	; 1
     eae:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState;
     eb0:	89 81       	ldd	r24, Y+1	; 0x01
}
     eb2:	28 96       	adiw	r28, 0x08	; 8
     eb4:	0f b6       	in	r0, 0x3f	; 63
     eb6:	f8 94       	cli
     eb8:	de bf       	out	0x3e, r29	; 62
     eba:	0f be       	out	0x3f, r0	; 63
     ebc:	cd bf       	out	0x3d, r28	; 61
     ebe:	cf 91       	pop	r28
     ec0:	df 91       	pop	r29
     ec2:	08 95       	ret

00000ec4 <DIO_u8SetPortDirection>:
u8 DIO_u8SetPortDirection(u8 Copy_u8Port, u8 Copy_u8Direction)
{
     ec4:	df 93       	push	r29
     ec6:	cf 93       	push	r28
     ec8:	00 d0       	rcall	.+0      	; 0xeca <DIO_u8SetPortDirection+0x6>
     eca:	00 d0       	rcall	.+0      	; 0xecc <DIO_u8SetPortDirection+0x8>
     ecc:	0f 92       	push	r0
     ece:	cd b7       	in	r28, 0x3d	; 61
     ed0:	de b7       	in	r29, 0x3e	; 62
     ed2:	8a 83       	std	Y+2, r24	; 0x02
     ed4:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState =0;
     ed6:	19 82       	std	Y+1, r1	; 0x01
	switch (Copy_u8Port)
     ed8:	8a 81       	ldd	r24, Y+2	; 0x02
     eda:	28 2f       	mov	r18, r24
     edc:	30 e0       	ldi	r19, 0x00	; 0
     ede:	3d 83       	std	Y+5, r19	; 0x05
     ee0:	2c 83       	std	Y+4, r18	; 0x04
     ee2:	8c 81       	ldd	r24, Y+4	; 0x04
     ee4:	9d 81       	ldd	r25, Y+5	; 0x05
     ee6:	82 30       	cpi	r24, 0x02	; 2
     ee8:	91 05       	cpc	r25, r1
     eea:	d9 f0       	breq	.+54     	; 0xf22 <DIO_u8SetPortDirection+0x5e>
     eec:	2c 81       	ldd	r18, Y+4	; 0x04
     eee:	3d 81       	ldd	r19, Y+5	; 0x05
     ef0:	23 30       	cpi	r18, 0x03	; 3
     ef2:	31 05       	cpc	r19, r1
     ef4:	34 f4       	brge	.+12     	; 0xf02 <DIO_u8SetPortDirection+0x3e>
     ef6:	8c 81       	ldd	r24, Y+4	; 0x04
     ef8:	9d 81       	ldd	r25, Y+5	; 0x05
     efa:	81 30       	cpi	r24, 0x01	; 1
     efc:	91 05       	cpc	r25, r1
     efe:	61 f0       	breq	.+24     	; 0xf18 <DIO_u8SetPortDirection+0x54>
     f00:	1f c0       	rjmp	.+62     	; 0xf40 <DIO_u8SetPortDirection+0x7c>
     f02:	2c 81       	ldd	r18, Y+4	; 0x04
     f04:	3d 81       	ldd	r19, Y+5	; 0x05
     f06:	23 30       	cpi	r18, 0x03	; 3
     f08:	31 05       	cpc	r19, r1
     f0a:	81 f0       	breq	.+32     	; 0xf2c <DIO_u8SetPortDirection+0x68>
     f0c:	8c 81       	ldd	r24, Y+4	; 0x04
     f0e:	9d 81       	ldd	r25, Y+5	; 0x05
     f10:	84 30       	cpi	r24, 0x04	; 4
     f12:	91 05       	cpc	r25, r1
     f14:	81 f0       	breq	.+32     	; 0xf36 <DIO_u8SetPortDirection+0x72>
     f16:	14 c0       	rjmp	.+40     	; 0xf40 <DIO_u8SetPortDirection+0x7c>
	{
	case PORT_A :
		DDRA = Copy_u8Direction;
     f18:	ea e3       	ldi	r30, 0x3A	; 58
     f1a:	f0 e0       	ldi	r31, 0x00	; 0
     f1c:	8b 81       	ldd	r24, Y+3	; 0x03
     f1e:	80 83       	st	Z, r24
     f20:	11 c0       	rjmp	.+34     	; 0xf44 <DIO_u8SetPortDirection+0x80>
		break;
	case PORT_B :
		DDRB = Copy_u8Direction;
     f22:	e7 e3       	ldi	r30, 0x37	; 55
     f24:	f0 e0       	ldi	r31, 0x00	; 0
     f26:	8b 81       	ldd	r24, Y+3	; 0x03
     f28:	80 83       	st	Z, r24
     f2a:	0c c0       	rjmp	.+24     	; 0xf44 <DIO_u8SetPortDirection+0x80>
		break;
	case PORT_C :
		DDRC = Copy_u8Direction;
     f2c:	e4 e3       	ldi	r30, 0x34	; 52
     f2e:	f0 e0       	ldi	r31, 0x00	; 0
     f30:	8b 81       	ldd	r24, Y+3	; 0x03
     f32:	80 83       	st	Z, r24
     f34:	07 c0       	rjmp	.+14     	; 0xf44 <DIO_u8SetPortDirection+0x80>
		break;
	case PORT_D :
		DDRD = Copy_u8Direction;
     f36:	e1 e3       	ldi	r30, 0x31	; 49
     f38:	f0 e0       	ldi	r31, 0x00	; 0
     f3a:	8b 81       	ldd	r24, Y+3	; 0x03
     f3c:	80 83       	st	Z, r24
     f3e:	02 c0       	rjmp	.+4      	; 0xf44 <DIO_u8SetPortDirection+0x80>
		break;
	default :
		Local_u8ErrorState =1;
     f40:	81 e0       	ldi	r24, 0x01	; 1
     f42:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	return Local_u8ErrorState;
     f44:	89 81       	ldd	r24, Y+1	; 0x01
}
     f46:	0f 90       	pop	r0
     f48:	0f 90       	pop	r0
     f4a:	0f 90       	pop	r0
     f4c:	0f 90       	pop	r0
     f4e:	0f 90       	pop	r0
     f50:	cf 91       	pop	r28
     f52:	df 91       	pop	r29
     f54:	08 95       	ret

00000f56 <DIO_u8SetPinValue>:
u8 DIO_u8SetPinValue(u8 Copy_u8Port, u8 Copy_u8Pin ,u8 Copy_u8Value)
{
     f56:	df 93       	push	r29
     f58:	cf 93       	push	r28
     f5a:	cd b7       	in	r28, 0x3d	; 61
     f5c:	de b7       	in	r29, 0x3e	; 62
     f5e:	28 97       	sbiw	r28, 0x08	; 8
     f60:	0f b6       	in	r0, 0x3f	; 63
     f62:	f8 94       	cli
     f64:	de bf       	out	0x3e, r29	; 62
     f66:	0f be       	out	0x3f, r0	; 63
     f68:	cd bf       	out	0x3d, r28	; 61
     f6a:	8a 83       	std	Y+2, r24	; 0x02
     f6c:	6b 83       	std	Y+3, r22	; 0x03
     f6e:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState =0;
     f70:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8Pin>7)
     f72:	8b 81       	ldd	r24, Y+3	; 0x03
     f74:	88 30       	cpi	r24, 0x08	; 8
     f76:	10 f0       	brcs	.+4      	; 0xf7c <DIO_u8SetPinValue+0x26>
		Local_u8ErrorState =1;
     f78:	81 e0       	ldi	r24, 0x01	; 1
     f7a:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8Value == LOW)
     f7c:	8c 81       	ldd	r24, Y+4	; 0x04
     f7e:	88 23       	and	r24, r24
     f80:	09 f0       	breq	.+2      	; 0xf84 <DIO_u8SetPinValue+0x2e>
     f82:	78 c0       	rjmp	.+240    	; 0x1074 <DIO_u8SetPinValue+0x11e>
	{
		switch (Copy_u8Port)
     f84:	8a 81       	ldd	r24, Y+2	; 0x02
     f86:	28 2f       	mov	r18, r24
     f88:	30 e0       	ldi	r19, 0x00	; 0
     f8a:	38 87       	std	Y+8, r19	; 0x08
     f8c:	2f 83       	std	Y+7, r18	; 0x07
     f8e:	8f 81       	ldd	r24, Y+7	; 0x07
     f90:	98 85       	ldd	r25, Y+8	; 0x08
     f92:	82 30       	cpi	r24, 0x02	; 2
     f94:	91 05       	cpc	r25, r1
     f96:	61 f1       	breq	.+88     	; 0xff0 <DIO_u8SetPinValue+0x9a>
     f98:	2f 81       	ldd	r18, Y+7	; 0x07
     f9a:	38 85       	ldd	r19, Y+8	; 0x08
     f9c:	23 30       	cpi	r18, 0x03	; 3
     f9e:	31 05       	cpc	r19, r1
     fa0:	34 f4       	brge	.+12     	; 0xfae <DIO_u8SetPinValue+0x58>
     fa2:	8f 81       	ldd	r24, Y+7	; 0x07
     fa4:	98 85       	ldd	r25, Y+8	; 0x08
     fa6:	81 30       	cpi	r24, 0x01	; 1
     fa8:	91 05       	cpc	r25, r1
     faa:	69 f0       	breq	.+26     	; 0xfc6 <DIO_u8SetPinValue+0x70>
     fac:	60 c0       	rjmp	.+192    	; 0x106e <DIO_u8SetPinValue+0x118>
     fae:	2f 81       	ldd	r18, Y+7	; 0x07
     fb0:	38 85       	ldd	r19, Y+8	; 0x08
     fb2:	23 30       	cpi	r18, 0x03	; 3
     fb4:	31 05       	cpc	r19, r1
     fb6:	89 f1       	breq	.+98     	; 0x101a <DIO_u8SetPinValue+0xc4>
     fb8:	8f 81       	ldd	r24, Y+7	; 0x07
     fba:	98 85       	ldd	r25, Y+8	; 0x08
     fbc:	84 30       	cpi	r24, 0x04	; 4
     fbe:	91 05       	cpc	r25, r1
     fc0:	09 f4       	brne	.+2      	; 0xfc4 <DIO_u8SetPinValue+0x6e>
     fc2:	40 c0       	rjmp	.+128    	; 0x1044 <DIO_u8SetPinValue+0xee>
     fc4:	54 c0       	rjmp	.+168    	; 0x106e <DIO_u8SetPinValue+0x118>
		{
		case PORT_A :
			CLR_BIT(PORTA,Copy_u8Pin);
     fc6:	ab e3       	ldi	r26, 0x3B	; 59
     fc8:	b0 e0       	ldi	r27, 0x00	; 0
     fca:	eb e3       	ldi	r30, 0x3B	; 59
     fcc:	f0 e0       	ldi	r31, 0x00	; 0
     fce:	80 81       	ld	r24, Z
     fd0:	48 2f       	mov	r20, r24
     fd2:	8b 81       	ldd	r24, Y+3	; 0x03
     fd4:	28 2f       	mov	r18, r24
     fd6:	30 e0       	ldi	r19, 0x00	; 0
     fd8:	81 e0       	ldi	r24, 0x01	; 1
     fda:	90 e0       	ldi	r25, 0x00	; 0
     fdc:	02 2e       	mov	r0, r18
     fde:	02 c0       	rjmp	.+4      	; 0xfe4 <DIO_u8SetPinValue+0x8e>
     fe0:	88 0f       	add	r24, r24
     fe2:	99 1f       	adc	r25, r25
     fe4:	0a 94       	dec	r0
     fe6:	e2 f7       	brpl	.-8      	; 0xfe0 <DIO_u8SetPinValue+0x8a>
     fe8:	80 95       	com	r24
     fea:	84 23       	and	r24, r20
     fec:	8c 93       	st	X, r24
     fee:	bb c0       	rjmp	.+374    	; 0x1166 <DIO_u8SetPinValue+0x210>
			break;
		case PORT_B :
			CLR_BIT(PORTB,Copy_u8Pin);
     ff0:	a8 e3       	ldi	r26, 0x38	; 56
     ff2:	b0 e0       	ldi	r27, 0x00	; 0
     ff4:	e8 e3       	ldi	r30, 0x38	; 56
     ff6:	f0 e0       	ldi	r31, 0x00	; 0
     ff8:	80 81       	ld	r24, Z
     ffa:	48 2f       	mov	r20, r24
     ffc:	8b 81       	ldd	r24, Y+3	; 0x03
     ffe:	28 2f       	mov	r18, r24
    1000:	30 e0       	ldi	r19, 0x00	; 0
    1002:	81 e0       	ldi	r24, 0x01	; 1
    1004:	90 e0       	ldi	r25, 0x00	; 0
    1006:	02 2e       	mov	r0, r18
    1008:	02 c0       	rjmp	.+4      	; 0x100e <DIO_u8SetPinValue+0xb8>
    100a:	88 0f       	add	r24, r24
    100c:	99 1f       	adc	r25, r25
    100e:	0a 94       	dec	r0
    1010:	e2 f7       	brpl	.-8      	; 0x100a <DIO_u8SetPinValue+0xb4>
    1012:	80 95       	com	r24
    1014:	84 23       	and	r24, r20
    1016:	8c 93       	st	X, r24
    1018:	a6 c0       	rjmp	.+332    	; 0x1166 <DIO_u8SetPinValue+0x210>
			break;
		case PORT_C :
			CLR_BIT(PORTC,Copy_u8Pin);
    101a:	a5 e3       	ldi	r26, 0x35	; 53
    101c:	b0 e0       	ldi	r27, 0x00	; 0
    101e:	e5 e3       	ldi	r30, 0x35	; 53
    1020:	f0 e0       	ldi	r31, 0x00	; 0
    1022:	80 81       	ld	r24, Z
    1024:	48 2f       	mov	r20, r24
    1026:	8b 81       	ldd	r24, Y+3	; 0x03
    1028:	28 2f       	mov	r18, r24
    102a:	30 e0       	ldi	r19, 0x00	; 0
    102c:	81 e0       	ldi	r24, 0x01	; 1
    102e:	90 e0       	ldi	r25, 0x00	; 0
    1030:	02 2e       	mov	r0, r18
    1032:	02 c0       	rjmp	.+4      	; 0x1038 <DIO_u8SetPinValue+0xe2>
    1034:	88 0f       	add	r24, r24
    1036:	99 1f       	adc	r25, r25
    1038:	0a 94       	dec	r0
    103a:	e2 f7       	brpl	.-8      	; 0x1034 <DIO_u8SetPinValue+0xde>
    103c:	80 95       	com	r24
    103e:	84 23       	and	r24, r20
    1040:	8c 93       	st	X, r24
    1042:	91 c0       	rjmp	.+290    	; 0x1166 <DIO_u8SetPinValue+0x210>
			break;
		case PORT_D :
			CLR_BIT(PORTD,Copy_u8Pin);
    1044:	a2 e3       	ldi	r26, 0x32	; 50
    1046:	b0 e0       	ldi	r27, 0x00	; 0
    1048:	e2 e3       	ldi	r30, 0x32	; 50
    104a:	f0 e0       	ldi	r31, 0x00	; 0
    104c:	80 81       	ld	r24, Z
    104e:	48 2f       	mov	r20, r24
    1050:	8b 81       	ldd	r24, Y+3	; 0x03
    1052:	28 2f       	mov	r18, r24
    1054:	30 e0       	ldi	r19, 0x00	; 0
    1056:	81 e0       	ldi	r24, 0x01	; 1
    1058:	90 e0       	ldi	r25, 0x00	; 0
    105a:	02 2e       	mov	r0, r18
    105c:	02 c0       	rjmp	.+4      	; 0x1062 <DIO_u8SetPinValue+0x10c>
    105e:	88 0f       	add	r24, r24
    1060:	99 1f       	adc	r25, r25
    1062:	0a 94       	dec	r0
    1064:	e2 f7       	brpl	.-8      	; 0x105e <DIO_u8SetPinValue+0x108>
    1066:	80 95       	com	r24
    1068:	84 23       	and	r24, r20
    106a:	8c 93       	st	X, r24
    106c:	7c c0       	rjmp	.+248    	; 0x1166 <DIO_u8SetPinValue+0x210>
			break;
		default:
			Local_u8ErrorState =1;
    106e:	81 e0       	ldi	r24, 0x01	; 1
    1070:	89 83       	std	Y+1, r24	; 0x01
    1072:	79 c0       	rjmp	.+242    	; 0x1166 <DIO_u8SetPinValue+0x210>
			break;
		}
	}
	else if(Copy_u8Value == HIGH)
    1074:	8c 81       	ldd	r24, Y+4	; 0x04
    1076:	81 30       	cpi	r24, 0x01	; 1
    1078:	09 f0       	breq	.+2      	; 0x107c <DIO_u8SetPinValue+0x126>
    107a:	73 c0       	rjmp	.+230    	; 0x1162 <DIO_u8SetPinValue+0x20c>
	{
		switch (Copy_u8Port)
    107c:	8a 81       	ldd	r24, Y+2	; 0x02
    107e:	28 2f       	mov	r18, r24
    1080:	30 e0       	ldi	r19, 0x00	; 0
    1082:	3e 83       	std	Y+6, r19	; 0x06
    1084:	2d 83       	std	Y+5, r18	; 0x05
    1086:	8d 81       	ldd	r24, Y+5	; 0x05
    1088:	9e 81       	ldd	r25, Y+6	; 0x06
    108a:	82 30       	cpi	r24, 0x02	; 2
    108c:	91 05       	cpc	r25, r1
    108e:	51 f1       	breq	.+84     	; 0x10e4 <DIO_u8SetPinValue+0x18e>
    1090:	2d 81       	ldd	r18, Y+5	; 0x05
    1092:	3e 81       	ldd	r19, Y+6	; 0x06
    1094:	23 30       	cpi	r18, 0x03	; 3
    1096:	31 05       	cpc	r19, r1
    1098:	34 f4       	brge	.+12     	; 0x10a6 <DIO_u8SetPinValue+0x150>
    109a:	8d 81       	ldd	r24, Y+5	; 0x05
    109c:	9e 81       	ldd	r25, Y+6	; 0x06
    109e:	81 30       	cpi	r24, 0x01	; 1
    10a0:	91 05       	cpc	r25, r1
    10a2:	61 f0       	breq	.+24     	; 0x10bc <DIO_u8SetPinValue+0x166>
    10a4:	5b c0       	rjmp	.+182    	; 0x115c <DIO_u8SetPinValue+0x206>
    10a6:	2d 81       	ldd	r18, Y+5	; 0x05
    10a8:	3e 81       	ldd	r19, Y+6	; 0x06
    10aa:	23 30       	cpi	r18, 0x03	; 3
    10ac:	31 05       	cpc	r19, r1
    10ae:	71 f1       	breq	.+92     	; 0x110c <DIO_u8SetPinValue+0x1b6>
    10b0:	8d 81       	ldd	r24, Y+5	; 0x05
    10b2:	9e 81       	ldd	r25, Y+6	; 0x06
    10b4:	84 30       	cpi	r24, 0x04	; 4
    10b6:	91 05       	cpc	r25, r1
    10b8:	e9 f1       	breq	.+122    	; 0x1134 <DIO_u8SetPinValue+0x1de>
    10ba:	50 c0       	rjmp	.+160    	; 0x115c <DIO_u8SetPinValue+0x206>
		{
		case PORT_A :
			SET_BIT(PORTA,Copy_u8Pin);
    10bc:	ab e3       	ldi	r26, 0x3B	; 59
    10be:	b0 e0       	ldi	r27, 0x00	; 0
    10c0:	eb e3       	ldi	r30, 0x3B	; 59
    10c2:	f0 e0       	ldi	r31, 0x00	; 0
    10c4:	80 81       	ld	r24, Z
    10c6:	48 2f       	mov	r20, r24
    10c8:	8b 81       	ldd	r24, Y+3	; 0x03
    10ca:	28 2f       	mov	r18, r24
    10cc:	30 e0       	ldi	r19, 0x00	; 0
    10ce:	81 e0       	ldi	r24, 0x01	; 1
    10d0:	90 e0       	ldi	r25, 0x00	; 0
    10d2:	02 2e       	mov	r0, r18
    10d4:	02 c0       	rjmp	.+4      	; 0x10da <DIO_u8SetPinValue+0x184>
    10d6:	88 0f       	add	r24, r24
    10d8:	99 1f       	adc	r25, r25
    10da:	0a 94       	dec	r0
    10dc:	e2 f7       	brpl	.-8      	; 0x10d6 <DIO_u8SetPinValue+0x180>
    10de:	84 2b       	or	r24, r20
    10e0:	8c 93       	st	X, r24
    10e2:	41 c0       	rjmp	.+130    	; 0x1166 <DIO_u8SetPinValue+0x210>
			break;
		case PORT_B :
			SET_BIT(PORTB,Copy_u8Pin);
    10e4:	a8 e3       	ldi	r26, 0x38	; 56
    10e6:	b0 e0       	ldi	r27, 0x00	; 0
    10e8:	e8 e3       	ldi	r30, 0x38	; 56
    10ea:	f0 e0       	ldi	r31, 0x00	; 0
    10ec:	80 81       	ld	r24, Z
    10ee:	48 2f       	mov	r20, r24
    10f0:	8b 81       	ldd	r24, Y+3	; 0x03
    10f2:	28 2f       	mov	r18, r24
    10f4:	30 e0       	ldi	r19, 0x00	; 0
    10f6:	81 e0       	ldi	r24, 0x01	; 1
    10f8:	90 e0       	ldi	r25, 0x00	; 0
    10fa:	02 2e       	mov	r0, r18
    10fc:	02 c0       	rjmp	.+4      	; 0x1102 <DIO_u8SetPinValue+0x1ac>
    10fe:	88 0f       	add	r24, r24
    1100:	99 1f       	adc	r25, r25
    1102:	0a 94       	dec	r0
    1104:	e2 f7       	brpl	.-8      	; 0x10fe <DIO_u8SetPinValue+0x1a8>
    1106:	84 2b       	or	r24, r20
    1108:	8c 93       	st	X, r24
    110a:	2d c0       	rjmp	.+90     	; 0x1166 <DIO_u8SetPinValue+0x210>
			break;
		case PORT_C :
			SET_BIT(PORTC,Copy_u8Pin);
    110c:	a5 e3       	ldi	r26, 0x35	; 53
    110e:	b0 e0       	ldi	r27, 0x00	; 0
    1110:	e5 e3       	ldi	r30, 0x35	; 53
    1112:	f0 e0       	ldi	r31, 0x00	; 0
    1114:	80 81       	ld	r24, Z
    1116:	48 2f       	mov	r20, r24
    1118:	8b 81       	ldd	r24, Y+3	; 0x03
    111a:	28 2f       	mov	r18, r24
    111c:	30 e0       	ldi	r19, 0x00	; 0
    111e:	81 e0       	ldi	r24, 0x01	; 1
    1120:	90 e0       	ldi	r25, 0x00	; 0
    1122:	02 2e       	mov	r0, r18
    1124:	02 c0       	rjmp	.+4      	; 0x112a <DIO_u8SetPinValue+0x1d4>
    1126:	88 0f       	add	r24, r24
    1128:	99 1f       	adc	r25, r25
    112a:	0a 94       	dec	r0
    112c:	e2 f7       	brpl	.-8      	; 0x1126 <DIO_u8SetPinValue+0x1d0>
    112e:	84 2b       	or	r24, r20
    1130:	8c 93       	st	X, r24
    1132:	19 c0       	rjmp	.+50     	; 0x1166 <DIO_u8SetPinValue+0x210>
			break;
		case PORT_D :
			SET_BIT(PORTD,Copy_u8Pin);
    1134:	a2 e3       	ldi	r26, 0x32	; 50
    1136:	b0 e0       	ldi	r27, 0x00	; 0
    1138:	e2 e3       	ldi	r30, 0x32	; 50
    113a:	f0 e0       	ldi	r31, 0x00	; 0
    113c:	80 81       	ld	r24, Z
    113e:	48 2f       	mov	r20, r24
    1140:	8b 81       	ldd	r24, Y+3	; 0x03
    1142:	28 2f       	mov	r18, r24
    1144:	30 e0       	ldi	r19, 0x00	; 0
    1146:	81 e0       	ldi	r24, 0x01	; 1
    1148:	90 e0       	ldi	r25, 0x00	; 0
    114a:	02 2e       	mov	r0, r18
    114c:	02 c0       	rjmp	.+4      	; 0x1152 <DIO_u8SetPinValue+0x1fc>
    114e:	88 0f       	add	r24, r24
    1150:	99 1f       	adc	r25, r25
    1152:	0a 94       	dec	r0
    1154:	e2 f7       	brpl	.-8      	; 0x114e <DIO_u8SetPinValue+0x1f8>
    1156:	84 2b       	or	r24, r20
    1158:	8c 93       	st	X, r24
    115a:	05 c0       	rjmp	.+10     	; 0x1166 <DIO_u8SetPinValue+0x210>
			break;
		default:
			Local_u8ErrorState =1;
    115c:	81 e0       	ldi	r24, 0x01	; 1
    115e:	89 83       	std	Y+1, r24	; 0x01
    1160:	02 c0       	rjmp	.+4      	; 0x1166 <DIO_u8SetPinValue+0x210>
			break;
		}
	}
	else
	{
		Local_u8ErrorState = 1;
    1162:	81 e0       	ldi	r24, 0x01	; 1
    1164:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState;
    1166:	89 81       	ldd	r24, Y+1	; 0x01
}
    1168:	28 96       	adiw	r28, 0x08	; 8
    116a:	0f b6       	in	r0, 0x3f	; 63
    116c:	f8 94       	cli
    116e:	de bf       	out	0x3e, r29	; 62
    1170:	0f be       	out	0x3f, r0	; 63
    1172:	cd bf       	out	0x3d, r28	; 61
    1174:	cf 91       	pop	r28
    1176:	df 91       	pop	r29
    1178:	08 95       	ret

0000117a <DIO_u8SetPortValue>:
u8 DIO_u8SetPortValue(u8 Copy_u8Port, u8 Copy_u8Value)
{
    117a:	df 93       	push	r29
    117c:	cf 93       	push	r28
    117e:	00 d0       	rcall	.+0      	; 0x1180 <DIO_u8SetPortValue+0x6>
    1180:	00 d0       	rcall	.+0      	; 0x1182 <DIO_u8SetPortValue+0x8>
    1182:	0f 92       	push	r0
    1184:	cd b7       	in	r28, 0x3d	; 61
    1186:	de b7       	in	r29, 0x3e	; 62
    1188:	8a 83       	std	Y+2, r24	; 0x02
    118a:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState =0;
    118c:	19 82       	std	Y+1, r1	; 0x01
	switch (Copy_u8Port)
    118e:	8a 81       	ldd	r24, Y+2	; 0x02
    1190:	28 2f       	mov	r18, r24
    1192:	30 e0       	ldi	r19, 0x00	; 0
    1194:	3d 83       	std	Y+5, r19	; 0x05
    1196:	2c 83       	std	Y+4, r18	; 0x04
    1198:	8c 81       	ldd	r24, Y+4	; 0x04
    119a:	9d 81       	ldd	r25, Y+5	; 0x05
    119c:	82 30       	cpi	r24, 0x02	; 2
    119e:	91 05       	cpc	r25, r1
    11a0:	d9 f0       	breq	.+54     	; 0x11d8 <DIO_u8SetPortValue+0x5e>
    11a2:	2c 81       	ldd	r18, Y+4	; 0x04
    11a4:	3d 81       	ldd	r19, Y+5	; 0x05
    11a6:	23 30       	cpi	r18, 0x03	; 3
    11a8:	31 05       	cpc	r19, r1
    11aa:	34 f4       	brge	.+12     	; 0x11b8 <DIO_u8SetPortValue+0x3e>
    11ac:	8c 81       	ldd	r24, Y+4	; 0x04
    11ae:	9d 81       	ldd	r25, Y+5	; 0x05
    11b0:	81 30       	cpi	r24, 0x01	; 1
    11b2:	91 05       	cpc	r25, r1
    11b4:	61 f0       	breq	.+24     	; 0x11ce <DIO_u8SetPortValue+0x54>
    11b6:	1f c0       	rjmp	.+62     	; 0x11f6 <DIO_u8SetPortValue+0x7c>
    11b8:	2c 81       	ldd	r18, Y+4	; 0x04
    11ba:	3d 81       	ldd	r19, Y+5	; 0x05
    11bc:	23 30       	cpi	r18, 0x03	; 3
    11be:	31 05       	cpc	r19, r1
    11c0:	81 f0       	breq	.+32     	; 0x11e2 <DIO_u8SetPortValue+0x68>
    11c2:	8c 81       	ldd	r24, Y+4	; 0x04
    11c4:	9d 81       	ldd	r25, Y+5	; 0x05
    11c6:	84 30       	cpi	r24, 0x04	; 4
    11c8:	91 05       	cpc	r25, r1
    11ca:	81 f0       	breq	.+32     	; 0x11ec <DIO_u8SetPortValue+0x72>
    11cc:	14 c0       	rjmp	.+40     	; 0x11f6 <DIO_u8SetPortValue+0x7c>
	{
	case PORT_A :
		PORTA = Copy_u8Value;
    11ce:	eb e3       	ldi	r30, 0x3B	; 59
    11d0:	f0 e0       	ldi	r31, 0x00	; 0
    11d2:	8b 81       	ldd	r24, Y+3	; 0x03
    11d4:	80 83       	st	Z, r24
    11d6:	11 c0       	rjmp	.+34     	; 0x11fa <DIO_u8SetPortValue+0x80>
		break;

	case PORT_B :
		PORTB = Copy_u8Value ;
    11d8:	e8 e3       	ldi	r30, 0x38	; 56
    11da:	f0 e0       	ldi	r31, 0x00	; 0
    11dc:	8b 81       	ldd	r24, Y+3	; 0x03
    11de:	80 83       	st	Z, r24
    11e0:	0c c0       	rjmp	.+24     	; 0x11fa <DIO_u8SetPortValue+0x80>
		break;

	case PORT_C :
		PORTC = Copy_u8Value ;
    11e2:	e5 e3       	ldi	r30, 0x35	; 53
    11e4:	f0 e0       	ldi	r31, 0x00	; 0
    11e6:	8b 81       	ldd	r24, Y+3	; 0x03
    11e8:	80 83       	st	Z, r24
    11ea:	07 c0       	rjmp	.+14     	; 0x11fa <DIO_u8SetPortValue+0x80>
		break;

	case PORT_D :
		PORTD = Copy_u8Value ;
    11ec:	e2 e3       	ldi	r30, 0x32	; 50
    11ee:	f0 e0       	ldi	r31, 0x00	; 0
    11f0:	8b 81       	ldd	r24, Y+3	; 0x03
    11f2:	80 83       	st	Z, r24
    11f4:	02 c0       	rjmp	.+4      	; 0x11fa <DIO_u8SetPortValue+0x80>
		break;

	default :

		Local_u8ErrorState =1;
    11f6:	81 e0       	ldi	r24, 0x01	; 1
    11f8:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	return Local_u8ErrorState;
    11fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    11fc:	0f 90       	pop	r0
    11fe:	0f 90       	pop	r0
    1200:	0f 90       	pop	r0
    1202:	0f 90       	pop	r0
    1204:	0f 90       	pop	r0
    1206:	cf 91       	pop	r28
    1208:	df 91       	pop	r29
    120a:	08 95       	ret

0000120c <DIO_u8GetPinValue>:
u8 DIO_u8GetPinValue(u8 Copy_u8Port, u8 Copy_u8Pin, u8* Copy_u8Value)
{
    120c:	df 93       	push	r29
    120e:	cf 93       	push	r28
    1210:	cd b7       	in	r28, 0x3d	; 61
    1212:	de b7       	in	r29, 0x3e	; 62
    1214:	27 97       	sbiw	r28, 0x07	; 7
    1216:	0f b6       	in	r0, 0x3f	; 63
    1218:	f8 94       	cli
    121a:	de bf       	out	0x3e, r29	; 62
    121c:	0f be       	out	0x3f, r0	; 63
    121e:	cd bf       	out	0x3d, r28	; 61
    1220:	8a 83       	std	Y+2, r24	; 0x02
    1222:	6b 83       	std	Y+3, r22	; 0x03
    1224:	5d 83       	std	Y+5, r21	; 0x05
    1226:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState =0;
    1228:	19 82       	std	Y+1, r1	; 0x01
	if((Copy_u8Value == NULL) || (Copy_u8Pin > 7))
    122a:	8c 81       	ldd	r24, Y+4	; 0x04
    122c:	9d 81       	ldd	r25, Y+5	; 0x05
    122e:	00 97       	sbiw	r24, 0x00	; 0
    1230:	19 f0       	breq	.+6      	; 0x1238 <DIO_u8GetPinValue+0x2c>
    1232:	8b 81       	ldd	r24, Y+3	; 0x03
    1234:	88 30       	cpi	r24, 0x08	; 8
    1236:	10 f0       	brcs	.+4      	; 0x123c <DIO_u8GetPinValue+0x30>
		Local_u8ErrorState =1;
    1238:	81 e0       	ldi	r24, 0x01	; 1
    123a:	89 83       	std	Y+1, r24	; 0x01
	switch (Copy_u8Port)
    123c:	8a 81       	ldd	r24, Y+2	; 0x02
    123e:	28 2f       	mov	r18, r24
    1240:	30 e0       	ldi	r19, 0x00	; 0
    1242:	3f 83       	std	Y+7, r19	; 0x07
    1244:	2e 83       	std	Y+6, r18	; 0x06
    1246:	4e 81       	ldd	r20, Y+6	; 0x06
    1248:	5f 81       	ldd	r21, Y+7	; 0x07
    124a:	42 30       	cpi	r20, 0x02	; 2
    124c:	51 05       	cpc	r21, r1
    124e:	59 f1       	breq	.+86     	; 0x12a6 <DIO_u8GetPinValue+0x9a>
    1250:	8e 81       	ldd	r24, Y+6	; 0x06
    1252:	9f 81       	ldd	r25, Y+7	; 0x07
    1254:	83 30       	cpi	r24, 0x03	; 3
    1256:	91 05       	cpc	r25, r1
    1258:	34 f4       	brge	.+12     	; 0x1266 <DIO_u8GetPinValue+0x5a>
    125a:	2e 81       	ldd	r18, Y+6	; 0x06
    125c:	3f 81       	ldd	r19, Y+7	; 0x07
    125e:	21 30       	cpi	r18, 0x01	; 1
    1260:	31 05       	cpc	r19, r1
    1262:	69 f0       	breq	.+26     	; 0x127e <DIO_u8GetPinValue+0x72>
    1264:	5c c0       	rjmp	.+184    	; 0x131e <DIO_u8GetPinValue+0x112>
    1266:	4e 81       	ldd	r20, Y+6	; 0x06
    1268:	5f 81       	ldd	r21, Y+7	; 0x07
    126a:	43 30       	cpi	r20, 0x03	; 3
    126c:	51 05       	cpc	r21, r1
    126e:	79 f1       	breq	.+94     	; 0x12ce <DIO_u8GetPinValue+0xc2>
    1270:	8e 81       	ldd	r24, Y+6	; 0x06
    1272:	9f 81       	ldd	r25, Y+7	; 0x07
    1274:	84 30       	cpi	r24, 0x04	; 4
    1276:	91 05       	cpc	r25, r1
    1278:	09 f4       	brne	.+2      	; 0x127c <DIO_u8GetPinValue+0x70>
    127a:	3d c0       	rjmp	.+122    	; 0x12f6 <DIO_u8GetPinValue+0xea>
    127c:	50 c0       	rjmp	.+160    	; 0x131e <DIO_u8GetPinValue+0x112>
	{
	case PORT_A :
		*Copy_u8Value = GET_BIT(PINA,Copy_u8Pin);
    127e:	e9 e3       	ldi	r30, 0x39	; 57
    1280:	f0 e0       	ldi	r31, 0x00	; 0
    1282:	80 81       	ld	r24, Z
    1284:	28 2f       	mov	r18, r24
    1286:	30 e0       	ldi	r19, 0x00	; 0
    1288:	8b 81       	ldd	r24, Y+3	; 0x03
    128a:	88 2f       	mov	r24, r24
    128c:	90 e0       	ldi	r25, 0x00	; 0
    128e:	a9 01       	movw	r20, r18
    1290:	02 c0       	rjmp	.+4      	; 0x1296 <DIO_u8GetPinValue+0x8a>
    1292:	55 95       	asr	r21
    1294:	47 95       	ror	r20
    1296:	8a 95       	dec	r24
    1298:	e2 f7       	brpl	.-8      	; 0x1292 <DIO_u8GetPinValue+0x86>
    129a:	ca 01       	movw	r24, r20
    129c:	81 70       	andi	r24, 0x01	; 1
    129e:	ec 81       	ldd	r30, Y+4	; 0x04
    12a0:	fd 81       	ldd	r31, Y+5	; 0x05
    12a2:	80 83       	st	Z, r24
    12a4:	3e c0       	rjmp	.+124    	; 0x1322 <DIO_u8GetPinValue+0x116>
		break;
	case PORT_B :
		*Copy_u8Value = GET_BIT(PINB,Copy_u8Pin);
    12a6:	e6 e3       	ldi	r30, 0x36	; 54
    12a8:	f0 e0       	ldi	r31, 0x00	; 0
    12aa:	80 81       	ld	r24, Z
    12ac:	28 2f       	mov	r18, r24
    12ae:	30 e0       	ldi	r19, 0x00	; 0
    12b0:	8b 81       	ldd	r24, Y+3	; 0x03
    12b2:	88 2f       	mov	r24, r24
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	a9 01       	movw	r20, r18
    12b8:	02 c0       	rjmp	.+4      	; 0x12be <DIO_u8GetPinValue+0xb2>
    12ba:	55 95       	asr	r21
    12bc:	47 95       	ror	r20
    12be:	8a 95       	dec	r24
    12c0:	e2 f7       	brpl	.-8      	; 0x12ba <DIO_u8GetPinValue+0xae>
    12c2:	ca 01       	movw	r24, r20
    12c4:	81 70       	andi	r24, 0x01	; 1
    12c6:	ec 81       	ldd	r30, Y+4	; 0x04
    12c8:	fd 81       	ldd	r31, Y+5	; 0x05
    12ca:	80 83       	st	Z, r24
    12cc:	2a c0       	rjmp	.+84     	; 0x1322 <DIO_u8GetPinValue+0x116>
		break;
	case PORT_C :
		*Copy_u8Value = GET_BIT(PINC,Copy_u8Pin);
    12ce:	e3 e3       	ldi	r30, 0x33	; 51
    12d0:	f0 e0       	ldi	r31, 0x00	; 0
    12d2:	80 81       	ld	r24, Z
    12d4:	28 2f       	mov	r18, r24
    12d6:	30 e0       	ldi	r19, 0x00	; 0
    12d8:	8b 81       	ldd	r24, Y+3	; 0x03
    12da:	88 2f       	mov	r24, r24
    12dc:	90 e0       	ldi	r25, 0x00	; 0
    12de:	a9 01       	movw	r20, r18
    12e0:	02 c0       	rjmp	.+4      	; 0x12e6 <DIO_u8GetPinValue+0xda>
    12e2:	55 95       	asr	r21
    12e4:	47 95       	ror	r20
    12e6:	8a 95       	dec	r24
    12e8:	e2 f7       	brpl	.-8      	; 0x12e2 <DIO_u8GetPinValue+0xd6>
    12ea:	ca 01       	movw	r24, r20
    12ec:	81 70       	andi	r24, 0x01	; 1
    12ee:	ec 81       	ldd	r30, Y+4	; 0x04
    12f0:	fd 81       	ldd	r31, Y+5	; 0x05
    12f2:	80 83       	st	Z, r24
    12f4:	16 c0       	rjmp	.+44     	; 0x1322 <DIO_u8GetPinValue+0x116>
		break;
	case PORT_D :
		*Copy_u8Value = GET_BIT(PIND,Copy_u8Pin);
    12f6:	e0 e3       	ldi	r30, 0x30	; 48
    12f8:	f0 e0       	ldi	r31, 0x00	; 0
    12fa:	80 81       	ld	r24, Z
    12fc:	28 2f       	mov	r18, r24
    12fe:	30 e0       	ldi	r19, 0x00	; 0
    1300:	8b 81       	ldd	r24, Y+3	; 0x03
    1302:	88 2f       	mov	r24, r24
    1304:	90 e0       	ldi	r25, 0x00	; 0
    1306:	a9 01       	movw	r20, r18
    1308:	02 c0       	rjmp	.+4      	; 0x130e <DIO_u8GetPinValue+0x102>
    130a:	55 95       	asr	r21
    130c:	47 95       	ror	r20
    130e:	8a 95       	dec	r24
    1310:	e2 f7       	brpl	.-8      	; 0x130a <DIO_u8GetPinValue+0xfe>
    1312:	ca 01       	movw	r24, r20
    1314:	81 70       	andi	r24, 0x01	; 1
    1316:	ec 81       	ldd	r30, Y+4	; 0x04
    1318:	fd 81       	ldd	r31, Y+5	; 0x05
    131a:	80 83       	st	Z, r24
    131c:	02 c0       	rjmp	.+4      	; 0x1322 <DIO_u8GetPinValue+0x116>
		break;
	default:
		Local_u8ErrorState =1;
    131e:	81 e0       	ldi	r24, 0x01	; 1
    1320:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	return Local_u8ErrorState;
    1322:	89 81       	ldd	r24, Y+1	; 0x01
}
    1324:	27 96       	adiw	r28, 0x07	; 7
    1326:	0f b6       	in	r0, 0x3f	; 63
    1328:	f8 94       	cli
    132a:	de bf       	out	0x3e, r29	; 62
    132c:	0f be       	out	0x3f, r0	; 63
    132e:	cd bf       	out	0x3d, r28	; 61
    1330:	cf 91       	pop	r28
    1332:	df 91       	pop	r29
    1334:	08 95       	ret

00001336 <DIO_u8GetPortValue>:
u8 DIO_u8GetPortValue(u8 Copy_u8Port, u8* Copy_u8Value)
{
    1336:	df 93       	push	r29
    1338:	cf 93       	push	r28
    133a:	00 d0       	rcall	.+0      	; 0x133c <DIO_u8GetPortValue+0x6>
    133c:	00 d0       	rcall	.+0      	; 0x133e <DIO_u8GetPortValue+0x8>
    133e:	00 d0       	rcall	.+0      	; 0x1340 <DIO_u8GetPortValue+0xa>
    1340:	cd b7       	in	r28, 0x3d	; 61
    1342:	de b7       	in	r29, 0x3e	; 62
    1344:	8a 83       	std	Y+2, r24	; 0x02
    1346:	7c 83       	std	Y+4, r23	; 0x04
    1348:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState =0;
    134a:	19 82       	std	Y+1, r1	; 0x01
	switch(Copy_u8Port)
    134c:	8a 81       	ldd	r24, Y+2	; 0x02
    134e:	28 2f       	mov	r18, r24
    1350:	30 e0       	ldi	r19, 0x00	; 0
    1352:	3e 83       	std	Y+6, r19	; 0x06
    1354:	2d 83       	std	Y+5, r18	; 0x05
    1356:	8d 81       	ldd	r24, Y+5	; 0x05
    1358:	9e 81       	ldd	r25, Y+6	; 0x06
    135a:	82 30       	cpi	r24, 0x02	; 2
    135c:	91 05       	cpc	r25, r1
    135e:	e9 f0       	breq	.+58     	; 0x139a <DIO_u8GetPortValue+0x64>
    1360:	2d 81       	ldd	r18, Y+5	; 0x05
    1362:	3e 81       	ldd	r19, Y+6	; 0x06
    1364:	23 30       	cpi	r18, 0x03	; 3
    1366:	31 05       	cpc	r19, r1
    1368:	34 f4       	brge	.+12     	; 0x1376 <DIO_u8GetPortValue+0x40>
    136a:	8d 81       	ldd	r24, Y+5	; 0x05
    136c:	9e 81       	ldd	r25, Y+6	; 0x06
    136e:	81 30       	cpi	r24, 0x01	; 1
    1370:	91 05       	cpc	r25, r1
    1372:	61 f0       	breq	.+24     	; 0x138c <DIO_u8GetPortValue+0x56>
    1374:	27 c0       	rjmp	.+78     	; 0x13c4 <DIO_u8GetPortValue+0x8e>
    1376:	2d 81       	ldd	r18, Y+5	; 0x05
    1378:	3e 81       	ldd	r19, Y+6	; 0x06
    137a:	23 30       	cpi	r18, 0x03	; 3
    137c:	31 05       	cpc	r19, r1
    137e:	a1 f0       	breq	.+40     	; 0x13a8 <DIO_u8GetPortValue+0x72>
    1380:	8d 81       	ldd	r24, Y+5	; 0x05
    1382:	9e 81       	ldd	r25, Y+6	; 0x06
    1384:	84 30       	cpi	r24, 0x04	; 4
    1386:	91 05       	cpc	r25, r1
    1388:	b1 f0       	breq	.+44     	; 0x13b6 <DIO_u8GetPortValue+0x80>
    138a:	1c c0       	rjmp	.+56     	; 0x13c4 <DIO_u8GetPortValue+0x8e>
	{
	case PORT_A :
		*Copy_u8Value = PINA ;
    138c:	e9 e3       	ldi	r30, 0x39	; 57
    138e:	f0 e0       	ldi	r31, 0x00	; 0
    1390:	80 81       	ld	r24, Z
    1392:	eb 81       	ldd	r30, Y+3	; 0x03
    1394:	fc 81       	ldd	r31, Y+4	; 0x04
    1396:	80 83       	st	Z, r24
    1398:	17 c0       	rjmp	.+46     	; 0x13c8 <DIO_u8GetPortValue+0x92>
		break;
	case PORT_B :
		*Copy_u8Value = PINB ;
    139a:	e6 e3       	ldi	r30, 0x36	; 54
    139c:	f0 e0       	ldi	r31, 0x00	; 0
    139e:	80 81       	ld	r24, Z
    13a0:	eb 81       	ldd	r30, Y+3	; 0x03
    13a2:	fc 81       	ldd	r31, Y+4	; 0x04
    13a4:	80 83       	st	Z, r24
    13a6:	10 c0       	rjmp	.+32     	; 0x13c8 <DIO_u8GetPortValue+0x92>
		break;
	case PORT_C :
		*Copy_u8Value = PINC ;
    13a8:	e3 e3       	ldi	r30, 0x33	; 51
    13aa:	f0 e0       	ldi	r31, 0x00	; 0
    13ac:	80 81       	ld	r24, Z
    13ae:	eb 81       	ldd	r30, Y+3	; 0x03
    13b0:	fc 81       	ldd	r31, Y+4	; 0x04
    13b2:	80 83       	st	Z, r24
    13b4:	09 c0       	rjmp	.+18     	; 0x13c8 <DIO_u8GetPortValue+0x92>
		break;
	case PORT_D :
		*Copy_u8Value = PIND ;
    13b6:	e0 e3       	ldi	r30, 0x30	; 48
    13b8:	f0 e0       	ldi	r31, 0x00	; 0
    13ba:	80 81       	ld	r24, Z
    13bc:	eb 81       	ldd	r30, Y+3	; 0x03
    13be:	fc 81       	ldd	r31, Y+4	; 0x04
    13c0:	80 83       	st	Z, r24
    13c2:	02 c0       	rjmp	.+4      	; 0x13c8 <DIO_u8GetPortValue+0x92>
		break;
	default :
		Local_u8ErrorState =1;
    13c4:	81 e0       	ldi	r24, 0x01	; 1
    13c6:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	return Local_u8ErrorState ;
    13c8:	89 81       	ldd	r24, Y+1	; 0x01
}
    13ca:	26 96       	adiw	r28, 0x06	; 6
    13cc:	0f b6       	in	r0, 0x3f	; 63
    13ce:	f8 94       	cli
    13d0:	de bf       	out	0x3e, r29	; 62
    13d2:	0f be       	out	0x3f, r0	; 63
    13d4:	cd bf       	out	0x3d, r28	; 61
    13d6:	cf 91       	pop	r28
    13d8:	df 91       	pop	r29
    13da:	08 95       	ret

000013dc <Map>:

f32 Map(s32 InputValue,s32 InputMin,s32 InputMax,s32 OutMin,s32 OutMax)
{
    13dc:	af 92       	push	r10
    13de:	bf 92       	push	r11
    13e0:	cf 92       	push	r12
    13e2:	df 92       	push	r13
    13e4:	ef 92       	push	r14
    13e6:	ff 92       	push	r15
    13e8:	0f 93       	push	r16
    13ea:	1f 93       	push	r17
    13ec:	df 93       	push	r29
    13ee:	cf 93       	push	r28
    13f0:	cd b7       	in	r28, 0x3d	; 61
    13f2:	de b7       	in	r29, 0x3e	; 62
    13f4:	68 97       	sbiw	r28, 0x18	; 24
    13f6:	0f b6       	in	r0, 0x3f	; 63
    13f8:	f8 94       	cli
    13fa:	de bf       	out	0x3e, r29	; 62
    13fc:	0f be       	out	0x3f, r0	; 63
    13fe:	cd bf       	out	0x3d, r28	; 61
    1400:	69 87       	std	Y+9, r22	; 0x09
    1402:	7a 87       	std	Y+10, r23	; 0x0a
    1404:	8b 87       	std	Y+11, r24	; 0x0b
    1406:	9c 87       	std	Y+12, r25	; 0x0c
    1408:	2d 87       	std	Y+13, r18	; 0x0d
    140a:	3e 87       	std	Y+14, r19	; 0x0e
    140c:	4f 87       	std	Y+15, r20	; 0x0f
    140e:	58 8b       	std	Y+16, r21	; 0x10
    1410:	e9 8a       	std	Y+17, r14	; 0x11
    1412:	fa 8a       	std	Y+18, r15	; 0x12
    1414:	0b 8b       	std	Y+19, r16	; 0x13
    1416:	1c 8b       	std	Y+20, r17	; 0x14
    1418:	ad 8a       	std	Y+21, r10	; 0x15
    141a:	be 8a       	std	Y+22, r11	; 0x16
    141c:	cf 8a       	std	Y+23, r12	; 0x17
    141e:	d8 8e       	std	Y+24, r13	; 0x18
	f32 Result =(((OutMax-OutMin)*(InputValue-InputMin))/(InputMax-InputMin));
    1420:	2d a1       	ldd	r18, Y+37	; 0x25
    1422:	3e a1       	ldd	r19, Y+38	; 0x26
    1424:	4f a1       	ldd	r20, Y+39	; 0x27
    1426:	58 a5       	ldd	r21, Y+40	; 0x28
    1428:	8d 89       	ldd	r24, Y+21	; 0x15
    142a:	9e 89       	ldd	r25, Y+22	; 0x16
    142c:	af 89       	ldd	r26, Y+23	; 0x17
    142e:	b8 8d       	ldd	r27, Y+24	; 0x18
    1430:	79 01       	movw	r14, r18
    1432:	8a 01       	movw	r16, r20
    1434:	e8 1a       	sub	r14, r24
    1436:	f9 0a       	sbc	r15, r25
    1438:	0a 0b       	sbc	r16, r26
    143a:	1b 0b       	sbc	r17, r27
    143c:	29 85       	ldd	r18, Y+9	; 0x09
    143e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1440:	4b 85       	ldd	r20, Y+11	; 0x0b
    1442:	5c 85       	ldd	r21, Y+12	; 0x0c
    1444:	8d 85       	ldd	r24, Y+13	; 0x0d
    1446:	9e 85       	ldd	r25, Y+14	; 0x0e
    1448:	af 85       	ldd	r26, Y+15	; 0x0f
    144a:	b8 89       	ldd	r27, Y+16	; 0x10
    144c:	28 1b       	sub	r18, r24
    144e:	39 0b       	sbc	r19, r25
    1450:	4a 0b       	sbc	r20, r26
    1452:	5b 0b       	sbc	r21, r27
    1454:	c8 01       	movw	r24, r16
    1456:	b7 01       	movw	r22, r14
    1458:	0e 94 8a 20 	call	0x4114	; 0x4114 <__mulsi3>
    145c:	7b 01       	movw	r14, r22
    145e:	8c 01       	movw	r16, r24
    1460:	29 89       	ldd	r18, Y+17	; 0x11
    1462:	3a 89       	ldd	r19, Y+18	; 0x12
    1464:	4b 89       	ldd	r20, Y+19	; 0x13
    1466:	5c 89       	ldd	r21, Y+20	; 0x14
    1468:	8d 85       	ldd	r24, Y+13	; 0x0d
    146a:	9e 85       	ldd	r25, Y+14	; 0x0e
    146c:	af 85       	ldd	r26, Y+15	; 0x0f
    146e:	b8 89       	ldd	r27, Y+16	; 0x10
    1470:	28 1b       	sub	r18, r24
    1472:	39 0b       	sbc	r19, r25
    1474:	4a 0b       	sbc	r20, r26
    1476:	5b 0b       	sbc	r21, r27
    1478:	c8 01       	movw	r24, r16
    147a:	b7 01       	movw	r22, r14
    147c:	0e 94 cb 20 	call	0x4196	; 0x4196 <__divmodsi4>
    1480:	da 01       	movw	r26, r20
    1482:	c9 01       	movw	r24, r18
    1484:	bc 01       	movw	r22, r24
    1486:	cd 01       	movw	r24, r26
    1488:	0e 94 a9 03 	call	0x752	; 0x752 <__floatsisf>
    148c:	dc 01       	movw	r26, r24
    148e:	cb 01       	movw	r24, r22
    1490:	8d 83       	std	Y+5, r24	; 0x05
    1492:	9e 83       	std	Y+6, r25	; 0x06
    1494:	af 83       	std	Y+7, r26	; 0x07
    1496:	b8 87       	std	Y+8, r27	; 0x08
	f32 OutValue =Result+OutMin;
    1498:	6d 89       	ldd	r22, Y+21	; 0x15
    149a:	7e 89       	ldd	r23, Y+22	; 0x16
    149c:	8f 89       	ldd	r24, Y+23	; 0x17
    149e:	98 8d       	ldd	r25, Y+24	; 0x18
    14a0:	0e 94 a9 03 	call	0x752	; 0x752 <__floatsisf>
    14a4:	dc 01       	movw	r26, r24
    14a6:	cb 01       	movw	r24, r22
    14a8:	bc 01       	movw	r22, r24
    14aa:	cd 01       	movw	r24, r26
    14ac:	2d 81       	ldd	r18, Y+5	; 0x05
    14ae:	3e 81       	ldd	r19, Y+6	; 0x06
    14b0:	4f 81       	ldd	r20, Y+7	; 0x07
    14b2:	58 85       	ldd	r21, Y+8	; 0x08
    14b4:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    14b8:	dc 01       	movw	r26, r24
    14ba:	cb 01       	movw	r24, r22
    14bc:	89 83       	std	Y+1, r24	; 0x01
    14be:	9a 83       	std	Y+2, r25	; 0x02
    14c0:	ab 83       	std	Y+3, r26	; 0x03
    14c2:	bc 83       	std	Y+4, r27	; 0x04
	return OutValue ;
    14c4:	89 81       	ldd	r24, Y+1	; 0x01
    14c6:	9a 81       	ldd	r25, Y+2	; 0x02
    14c8:	ab 81       	ldd	r26, Y+3	; 0x03
    14ca:	bc 81       	ldd	r27, Y+4	; 0x04
}
    14cc:	bc 01       	movw	r22, r24
    14ce:	cd 01       	movw	r24, r26
    14d0:	68 96       	adiw	r28, 0x18	; 24
    14d2:	0f b6       	in	r0, 0x3f	; 63
    14d4:	f8 94       	cli
    14d6:	de bf       	out	0x3e, r29	; 62
    14d8:	0f be       	out	0x3f, r0	; 63
    14da:	cd bf       	out	0x3d, r28	; 61
    14dc:	cf 91       	pop	r28
    14de:	df 91       	pop	r29
    14e0:	1f 91       	pop	r17
    14e2:	0f 91       	pop	r16
    14e4:	ff 90       	pop	r15
    14e6:	ef 90       	pop	r14
    14e8:	df 90       	pop	r13
    14ea:	cf 90       	pop	r12
    14ec:	bf 90       	pop	r11
    14ee:	af 90       	pop	r10
    14f0:	08 95       	ret

000014f2 <LCD_voidSendCommand>:
#include "DIO_interface.h"
#include "LCD_interface.h"
#include <util/delay.h>

void LCD_voidSendCommand(u8 Copy_u8Command)
{
    14f2:	df 93       	push	r29
    14f4:	cf 93       	push	r28
    14f6:	cd b7       	in	r28, 0x3d	; 61
    14f8:	de b7       	in	r29, 0x3e	; 62
    14fa:	2f 97       	sbiw	r28, 0x0f	; 15
    14fc:	0f b6       	in	r0, 0x3f	; 63
    14fe:	f8 94       	cli
    1500:	de bf       	out	0x3e, r29	; 62
    1502:	0f be       	out	0x3f, r0	; 63
    1504:	cd bf       	out	0x3d, r28	; 61
    1506:	8f 87       	std	Y+15, r24	; 0x0f
#if LCD_MODE ==EIGHT_BIT
	/*set RS pin low for Command*/
	DIO_u8SetPinValue(LCD_CTRL_PORT,LCD_RS_PIN,LOW);
    1508:	82 e0       	ldi	r24, 0x02	; 2
    150a:	60 e0       	ldi	r22, 0x00	; 0
    150c:	40 e0       	ldi	r20, 0x00	; 0
    150e:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_u8SetPinValue>
	/*Set RW pin LOW for Write*/
	DIO_u8SetPinValue(LCD_CTRL_PORT,LCD_RW_PIN,LOW);
    1512:	82 e0       	ldi	r24, 0x02	; 2
    1514:	61 e0       	ldi	r22, 0x01	; 1
    1516:	40 e0       	ldi	r20, 0x00	; 0
    1518:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_u8SetPinValue>
	/*Send Command in data PORT*/
	DIO_u8SetPortValue(LCD_DATA_PORT,Copy_u8Command);
    151c:	81 e0       	ldi	r24, 0x01	; 1
    151e:	6f 85       	ldd	r22, Y+15	; 0x0f
    1520:	0e 94 bd 08 	call	0x117a	; 0x117a <DIO_u8SetPortValue>
	/*Send Enable Pulse*/
	DIO_u8SetPinValue(LCD_CTRL_PORT,LCD_E_PIN,HIGH);
    1524:	82 e0       	ldi	r24, 0x02	; 2
    1526:	62 e0       	ldi	r22, 0x02	; 2
    1528:	41 e0       	ldi	r20, 0x01	; 1
    152a:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_u8SetPinValue>
    152e:	80 e0       	ldi	r24, 0x00	; 0
    1530:	90 e0       	ldi	r25, 0x00	; 0
    1532:	a0 e0       	ldi	r26, 0x00	; 0
    1534:	b0 e4       	ldi	r27, 0x40	; 64
    1536:	8b 87       	std	Y+11, r24	; 0x0b
    1538:	9c 87       	std	Y+12, r25	; 0x0c
    153a:	ad 87       	std	Y+13, r26	; 0x0d
    153c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    153e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1540:	7c 85       	ldd	r23, Y+12	; 0x0c
    1542:	8d 85       	ldd	r24, Y+13	; 0x0d
    1544:	9e 85       	ldd	r25, Y+14	; 0x0e
    1546:	20 e0       	ldi	r18, 0x00	; 0
    1548:	30 e0       	ldi	r19, 0x00	; 0
    154a:	4a ef       	ldi	r20, 0xFA	; 250
    154c:	54 e4       	ldi	r21, 0x44	; 68
    154e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1552:	dc 01       	movw	r26, r24
    1554:	cb 01       	movw	r24, r22
    1556:	8f 83       	std	Y+7, r24	; 0x07
    1558:	98 87       	std	Y+8, r25	; 0x08
    155a:	a9 87       	std	Y+9, r26	; 0x09
    155c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    155e:	6f 81       	ldd	r22, Y+7	; 0x07
    1560:	78 85       	ldd	r23, Y+8	; 0x08
    1562:	89 85       	ldd	r24, Y+9	; 0x09
    1564:	9a 85       	ldd	r25, Y+10	; 0x0a
    1566:	20 e0       	ldi	r18, 0x00	; 0
    1568:	30 e0       	ldi	r19, 0x00	; 0
    156a:	40 e8       	ldi	r20, 0x80	; 128
    156c:	5f e3       	ldi	r21, 0x3F	; 63
    156e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1572:	88 23       	and	r24, r24
    1574:	2c f4       	brge	.+10     	; 0x1580 <LCD_voidSendCommand+0x8e>
		__ticks = 1;
    1576:	81 e0       	ldi	r24, 0x01	; 1
    1578:	90 e0       	ldi	r25, 0x00	; 0
    157a:	9e 83       	std	Y+6, r25	; 0x06
    157c:	8d 83       	std	Y+5, r24	; 0x05
    157e:	3f c0       	rjmp	.+126    	; 0x15fe <LCD_voidSendCommand+0x10c>
	else if (__tmp > 65535)
    1580:	6f 81       	ldd	r22, Y+7	; 0x07
    1582:	78 85       	ldd	r23, Y+8	; 0x08
    1584:	89 85       	ldd	r24, Y+9	; 0x09
    1586:	9a 85       	ldd	r25, Y+10	; 0x0a
    1588:	20 e0       	ldi	r18, 0x00	; 0
    158a:	3f ef       	ldi	r19, 0xFF	; 255
    158c:	4f e7       	ldi	r20, 0x7F	; 127
    158e:	57 e4       	ldi	r21, 0x47	; 71
    1590:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1594:	18 16       	cp	r1, r24
    1596:	4c f5       	brge	.+82     	; 0x15ea <LCD_voidSendCommand+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1598:	6b 85       	ldd	r22, Y+11	; 0x0b
    159a:	7c 85       	ldd	r23, Y+12	; 0x0c
    159c:	8d 85       	ldd	r24, Y+13	; 0x0d
    159e:	9e 85       	ldd	r25, Y+14	; 0x0e
    15a0:	20 e0       	ldi	r18, 0x00	; 0
    15a2:	30 e0       	ldi	r19, 0x00	; 0
    15a4:	40 e2       	ldi	r20, 0x20	; 32
    15a6:	51 e4       	ldi	r21, 0x41	; 65
    15a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    15ac:	dc 01       	movw	r26, r24
    15ae:	cb 01       	movw	r24, r22
    15b0:	bc 01       	movw	r22, r24
    15b2:	cd 01       	movw	r24, r26
    15b4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    15b8:	dc 01       	movw	r26, r24
    15ba:	cb 01       	movw	r24, r22
    15bc:	9e 83       	std	Y+6, r25	; 0x06
    15be:	8d 83       	std	Y+5, r24	; 0x05
    15c0:	0f c0       	rjmp	.+30     	; 0x15e0 <LCD_voidSendCommand+0xee>
    15c2:	88 ec       	ldi	r24, 0xC8	; 200
    15c4:	90 e0       	ldi	r25, 0x00	; 0
    15c6:	9c 83       	std	Y+4, r25	; 0x04
    15c8:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    15ca:	8b 81       	ldd	r24, Y+3	; 0x03
    15cc:	9c 81       	ldd	r25, Y+4	; 0x04
    15ce:	01 97       	sbiw	r24, 0x01	; 1
    15d0:	f1 f7       	brne	.-4      	; 0x15ce <LCD_voidSendCommand+0xdc>
    15d2:	9c 83       	std	Y+4, r25	; 0x04
    15d4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    15d6:	8d 81       	ldd	r24, Y+5	; 0x05
    15d8:	9e 81       	ldd	r25, Y+6	; 0x06
    15da:	01 97       	sbiw	r24, 0x01	; 1
    15dc:	9e 83       	std	Y+6, r25	; 0x06
    15de:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    15e0:	8d 81       	ldd	r24, Y+5	; 0x05
    15e2:	9e 81       	ldd	r25, Y+6	; 0x06
    15e4:	00 97       	sbiw	r24, 0x00	; 0
    15e6:	69 f7       	brne	.-38     	; 0x15c2 <LCD_voidSendCommand+0xd0>
    15e8:	14 c0       	rjmp	.+40     	; 0x1612 <LCD_voidSendCommand+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    15ea:	6f 81       	ldd	r22, Y+7	; 0x07
    15ec:	78 85       	ldd	r23, Y+8	; 0x08
    15ee:	89 85       	ldd	r24, Y+9	; 0x09
    15f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    15f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    15f6:	dc 01       	movw	r26, r24
    15f8:	cb 01       	movw	r24, r22
    15fa:	9e 83       	std	Y+6, r25	; 0x06
    15fc:	8d 83       	std	Y+5, r24	; 0x05
    15fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1600:	9e 81       	ldd	r25, Y+6	; 0x06
    1602:	9a 83       	std	Y+2, r25	; 0x02
    1604:	89 83       	std	Y+1, r24	; 0x01
    1606:	89 81       	ldd	r24, Y+1	; 0x01
    1608:	9a 81       	ldd	r25, Y+2	; 0x02
    160a:	01 97       	sbiw	r24, 0x01	; 1
    160c:	f1 f7       	brne	.-4      	; 0x160a <LCD_voidSendCommand+0x118>
    160e:	9a 83       	std	Y+2, r25	; 0x02
    1610:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	DIO_u8SetPinValue(LCD_CTRL_PORT,LCD_E_PIN,LOW);
    1612:	82 e0       	ldi	r24, 0x02	; 2
    1614:	62 e0       	ldi	r22, 0x02	; 2
    1616:	40 e0       	ldi	r20, 0x00	; 0
    1618:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_CTRL_PORT,LCD_E_PIN,HIGH);
	_delay_ms(5);
	DIO_u8SetPinValue(LCD_CTRL_PORT,LCD_E_PIN,LOW);
	_delay_ms(50);
#endif
}
    161c:	2f 96       	adiw	r28, 0x0f	; 15
    161e:	0f b6       	in	r0, 0x3f	; 63
    1620:	f8 94       	cli
    1622:	de bf       	out	0x3e, r29	; 62
    1624:	0f be       	out	0x3f, r0	; 63
    1626:	cd bf       	out	0x3d, r28	; 61
    1628:	cf 91       	pop	r28
    162a:	df 91       	pop	r29
    162c:	08 95       	ret

0000162e <LCD_voidSendData>:

void LCD_voidSendData(u8 Copy_u8Data)
{
    162e:	df 93       	push	r29
    1630:	cf 93       	push	r28
    1632:	cd b7       	in	r28, 0x3d	; 61
    1634:	de b7       	in	r29, 0x3e	; 62
    1636:	2f 97       	sbiw	r28, 0x0f	; 15
    1638:	0f b6       	in	r0, 0x3f	; 63
    163a:	f8 94       	cli
    163c:	de bf       	out	0x3e, r29	; 62
    163e:	0f be       	out	0x3f, r0	; 63
    1640:	cd bf       	out	0x3d, r28	; 61
    1642:	8f 87       	std	Y+15, r24	; 0x0f
#if LCD_MODE == EIGHT_BIT
	/*set RS pin HIGH for DATA*/
	DIO_u8SetPinValue(LCD_CTRL_PORT,LCD_RS_PIN,HIGH );
    1644:	82 e0       	ldi	r24, 0x02	; 2
    1646:	60 e0       	ldi	r22, 0x00	; 0
    1648:	41 e0       	ldi	r20, 0x01	; 1
    164a:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_u8SetPinValue>
	/*Set RW pin LOW for Write*/
	DIO_u8SetPinValue(LCD_CTRL_PORT,LCD_RW_PIN,LOW);
    164e:	82 e0       	ldi	r24, 0x02	; 2
    1650:	61 e0       	ldi	r22, 0x01	; 1
    1652:	40 e0       	ldi	r20, 0x00	; 0
    1654:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_u8SetPinValue>
	/*Send Command in data PORT*/
	DIO_u8SetPortValue(LCD_DATA_PORT,Copy_u8Data);
    1658:	81 e0       	ldi	r24, 0x01	; 1
    165a:	6f 85       	ldd	r22, Y+15	; 0x0f
    165c:	0e 94 bd 08 	call	0x117a	; 0x117a <DIO_u8SetPortValue>
	/*Send Enable Pulse*/
	DIO_u8SetPinValue(LCD_CTRL_PORT,LCD_E_PIN,HIGH);
    1660:	82 e0       	ldi	r24, 0x02	; 2
    1662:	62 e0       	ldi	r22, 0x02	; 2
    1664:	41 e0       	ldi	r20, 0x01	; 1
    1666:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_u8SetPinValue>
    166a:	80 e0       	ldi	r24, 0x00	; 0
    166c:	90 e0       	ldi	r25, 0x00	; 0
    166e:	a0 e0       	ldi	r26, 0x00	; 0
    1670:	b0 e4       	ldi	r27, 0x40	; 64
    1672:	8b 87       	std	Y+11, r24	; 0x0b
    1674:	9c 87       	std	Y+12, r25	; 0x0c
    1676:	ad 87       	std	Y+13, r26	; 0x0d
    1678:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    167a:	6b 85       	ldd	r22, Y+11	; 0x0b
    167c:	7c 85       	ldd	r23, Y+12	; 0x0c
    167e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1680:	9e 85       	ldd	r25, Y+14	; 0x0e
    1682:	20 e0       	ldi	r18, 0x00	; 0
    1684:	30 e0       	ldi	r19, 0x00	; 0
    1686:	4a ef       	ldi	r20, 0xFA	; 250
    1688:	54 e4       	ldi	r21, 0x44	; 68
    168a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    168e:	dc 01       	movw	r26, r24
    1690:	cb 01       	movw	r24, r22
    1692:	8f 83       	std	Y+7, r24	; 0x07
    1694:	98 87       	std	Y+8, r25	; 0x08
    1696:	a9 87       	std	Y+9, r26	; 0x09
    1698:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    169a:	6f 81       	ldd	r22, Y+7	; 0x07
    169c:	78 85       	ldd	r23, Y+8	; 0x08
    169e:	89 85       	ldd	r24, Y+9	; 0x09
    16a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    16a2:	20 e0       	ldi	r18, 0x00	; 0
    16a4:	30 e0       	ldi	r19, 0x00	; 0
    16a6:	40 e8       	ldi	r20, 0x80	; 128
    16a8:	5f e3       	ldi	r21, 0x3F	; 63
    16aa:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    16ae:	88 23       	and	r24, r24
    16b0:	2c f4       	brge	.+10     	; 0x16bc <LCD_voidSendData+0x8e>
		__ticks = 1;
    16b2:	81 e0       	ldi	r24, 0x01	; 1
    16b4:	90 e0       	ldi	r25, 0x00	; 0
    16b6:	9e 83       	std	Y+6, r25	; 0x06
    16b8:	8d 83       	std	Y+5, r24	; 0x05
    16ba:	3f c0       	rjmp	.+126    	; 0x173a <LCD_voidSendData+0x10c>
	else if (__tmp > 65535)
    16bc:	6f 81       	ldd	r22, Y+7	; 0x07
    16be:	78 85       	ldd	r23, Y+8	; 0x08
    16c0:	89 85       	ldd	r24, Y+9	; 0x09
    16c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    16c4:	20 e0       	ldi	r18, 0x00	; 0
    16c6:	3f ef       	ldi	r19, 0xFF	; 255
    16c8:	4f e7       	ldi	r20, 0x7F	; 127
    16ca:	57 e4       	ldi	r21, 0x47	; 71
    16cc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    16d0:	18 16       	cp	r1, r24
    16d2:	4c f5       	brge	.+82     	; 0x1726 <LCD_voidSendData+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    16d4:	6b 85       	ldd	r22, Y+11	; 0x0b
    16d6:	7c 85       	ldd	r23, Y+12	; 0x0c
    16d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    16da:	9e 85       	ldd	r25, Y+14	; 0x0e
    16dc:	20 e0       	ldi	r18, 0x00	; 0
    16de:	30 e0       	ldi	r19, 0x00	; 0
    16e0:	40 e2       	ldi	r20, 0x20	; 32
    16e2:	51 e4       	ldi	r21, 0x41	; 65
    16e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    16e8:	dc 01       	movw	r26, r24
    16ea:	cb 01       	movw	r24, r22
    16ec:	bc 01       	movw	r22, r24
    16ee:	cd 01       	movw	r24, r26
    16f0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16f4:	dc 01       	movw	r26, r24
    16f6:	cb 01       	movw	r24, r22
    16f8:	9e 83       	std	Y+6, r25	; 0x06
    16fa:	8d 83       	std	Y+5, r24	; 0x05
    16fc:	0f c0       	rjmp	.+30     	; 0x171c <LCD_voidSendData+0xee>
    16fe:	88 ec       	ldi	r24, 0xC8	; 200
    1700:	90 e0       	ldi	r25, 0x00	; 0
    1702:	9c 83       	std	Y+4, r25	; 0x04
    1704:	8b 83       	std	Y+3, r24	; 0x03
    1706:	8b 81       	ldd	r24, Y+3	; 0x03
    1708:	9c 81       	ldd	r25, Y+4	; 0x04
    170a:	01 97       	sbiw	r24, 0x01	; 1
    170c:	f1 f7       	brne	.-4      	; 0x170a <LCD_voidSendData+0xdc>
    170e:	9c 83       	std	Y+4, r25	; 0x04
    1710:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1712:	8d 81       	ldd	r24, Y+5	; 0x05
    1714:	9e 81       	ldd	r25, Y+6	; 0x06
    1716:	01 97       	sbiw	r24, 0x01	; 1
    1718:	9e 83       	std	Y+6, r25	; 0x06
    171a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    171c:	8d 81       	ldd	r24, Y+5	; 0x05
    171e:	9e 81       	ldd	r25, Y+6	; 0x06
    1720:	00 97       	sbiw	r24, 0x00	; 0
    1722:	69 f7       	brne	.-38     	; 0x16fe <LCD_voidSendData+0xd0>
    1724:	14 c0       	rjmp	.+40     	; 0x174e <LCD_voidSendData+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1726:	6f 81       	ldd	r22, Y+7	; 0x07
    1728:	78 85       	ldd	r23, Y+8	; 0x08
    172a:	89 85       	ldd	r24, Y+9	; 0x09
    172c:	9a 85       	ldd	r25, Y+10	; 0x0a
    172e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1732:	dc 01       	movw	r26, r24
    1734:	cb 01       	movw	r24, r22
    1736:	9e 83       	std	Y+6, r25	; 0x06
    1738:	8d 83       	std	Y+5, r24	; 0x05
    173a:	8d 81       	ldd	r24, Y+5	; 0x05
    173c:	9e 81       	ldd	r25, Y+6	; 0x06
    173e:	9a 83       	std	Y+2, r25	; 0x02
    1740:	89 83       	std	Y+1, r24	; 0x01
    1742:	89 81       	ldd	r24, Y+1	; 0x01
    1744:	9a 81       	ldd	r25, Y+2	; 0x02
    1746:	01 97       	sbiw	r24, 0x01	; 1
    1748:	f1 f7       	brne	.-4      	; 0x1746 <LCD_voidSendData+0x118>
    174a:	9a 83       	std	Y+2, r25	; 0x02
    174c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	DIO_u8SetPinValue(LCD_CTRL_PORT,LCD_E_PIN,LOW);
    174e:	82 e0       	ldi	r24, 0x02	; 2
    1750:	62 e0       	ldi	r22, 0x02	; 2
    1752:	40 e0       	ldi	r20, 0x00	; 0
    1754:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_u8SetPinValue>
	/*Send Enable Pulse*/
	DIO_u8SetPinValue(LCD_CTRL_PORT,LCD_E_PIN,HIGH);
	_delay_ms(2);
	DIO_u8SetPinValue(LCD_CTRL_PORT,LCD_E_PIN,LOW);
#endif
}
    1758:	2f 96       	adiw	r28, 0x0f	; 15
    175a:	0f b6       	in	r0, 0x3f	; 63
    175c:	f8 94       	cli
    175e:	de bf       	out	0x3e, r29	; 62
    1760:	0f be       	out	0x3f, r0	; 63
    1762:	cd bf       	out	0x3d, r28	; 61
    1764:	cf 91       	pop	r28
    1766:	df 91       	pop	r29
    1768:	08 95       	ret

0000176a <LCD_voidInit>:

void LCD_voidInit(void)
{
    176a:	df 93       	push	r29
    176c:	cf 93       	push	r28
    176e:	cd b7       	in	r28, 0x3d	; 61
    1770:	de b7       	in	r29, 0x3e	; 62
    1772:	2e 97       	sbiw	r28, 0x0e	; 14
    1774:	0f b6       	in	r0, 0x3f	; 63
    1776:	f8 94       	cli
    1778:	de bf       	out	0x3e, r29	; 62
    177a:	0f be       	out	0x3f, r0	; 63
    177c:	cd bf       	out	0x3d, r28	; 61
    177e:	80 e0       	ldi	r24, 0x00	; 0
    1780:	90 e0       	ldi	r25, 0x00	; 0
    1782:	a0 ef       	ldi	r26, 0xF0	; 240
    1784:	b1 e4       	ldi	r27, 0x41	; 65
    1786:	8b 87       	std	Y+11, r24	; 0x0b
    1788:	9c 87       	std	Y+12, r25	; 0x0c
    178a:	ad 87       	std	Y+13, r26	; 0x0d
    178c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    178e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1790:	7c 85       	ldd	r23, Y+12	; 0x0c
    1792:	8d 85       	ldd	r24, Y+13	; 0x0d
    1794:	9e 85       	ldd	r25, Y+14	; 0x0e
    1796:	20 e0       	ldi	r18, 0x00	; 0
    1798:	30 e0       	ldi	r19, 0x00	; 0
    179a:	4a ef       	ldi	r20, 0xFA	; 250
    179c:	54 e4       	ldi	r21, 0x44	; 68
    179e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17a2:	dc 01       	movw	r26, r24
    17a4:	cb 01       	movw	r24, r22
    17a6:	8f 83       	std	Y+7, r24	; 0x07
    17a8:	98 87       	std	Y+8, r25	; 0x08
    17aa:	a9 87       	std	Y+9, r26	; 0x09
    17ac:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    17ae:	6f 81       	ldd	r22, Y+7	; 0x07
    17b0:	78 85       	ldd	r23, Y+8	; 0x08
    17b2:	89 85       	ldd	r24, Y+9	; 0x09
    17b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    17b6:	20 e0       	ldi	r18, 0x00	; 0
    17b8:	30 e0       	ldi	r19, 0x00	; 0
    17ba:	40 e8       	ldi	r20, 0x80	; 128
    17bc:	5f e3       	ldi	r21, 0x3F	; 63
    17be:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    17c2:	88 23       	and	r24, r24
    17c4:	2c f4       	brge	.+10     	; 0x17d0 <LCD_voidInit+0x66>
		__ticks = 1;
    17c6:	81 e0       	ldi	r24, 0x01	; 1
    17c8:	90 e0       	ldi	r25, 0x00	; 0
    17ca:	9e 83       	std	Y+6, r25	; 0x06
    17cc:	8d 83       	std	Y+5, r24	; 0x05
    17ce:	3f c0       	rjmp	.+126    	; 0x184e <LCD_voidInit+0xe4>
	else if (__tmp > 65535)
    17d0:	6f 81       	ldd	r22, Y+7	; 0x07
    17d2:	78 85       	ldd	r23, Y+8	; 0x08
    17d4:	89 85       	ldd	r24, Y+9	; 0x09
    17d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    17d8:	20 e0       	ldi	r18, 0x00	; 0
    17da:	3f ef       	ldi	r19, 0xFF	; 255
    17dc:	4f e7       	ldi	r20, 0x7F	; 127
    17de:	57 e4       	ldi	r21, 0x47	; 71
    17e0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    17e4:	18 16       	cp	r1, r24
    17e6:	4c f5       	brge	.+82     	; 0x183a <LCD_voidInit+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    17e8:	6b 85       	ldd	r22, Y+11	; 0x0b
    17ea:	7c 85       	ldd	r23, Y+12	; 0x0c
    17ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    17ee:	9e 85       	ldd	r25, Y+14	; 0x0e
    17f0:	20 e0       	ldi	r18, 0x00	; 0
    17f2:	30 e0       	ldi	r19, 0x00	; 0
    17f4:	40 e2       	ldi	r20, 0x20	; 32
    17f6:	51 e4       	ldi	r21, 0x41	; 65
    17f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17fc:	dc 01       	movw	r26, r24
    17fe:	cb 01       	movw	r24, r22
    1800:	bc 01       	movw	r22, r24
    1802:	cd 01       	movw	r24, r26
    1804:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1808:	dc 01       	movw	r26, r24
    180a:	cb 01       	movw	r24, r22
    180c:	9e 83       	std	Y+6, r25	; 0x06
    180e:	8d 83       	std	Y+5, r24	; 0x05
    1810:	0f c0       	rjmp	.+30     	; 0x1830 <LCD_voidInit+0xc6>
    1812:	88 ec       	ldi	r24, 0xC8	; 200
    1814:	90 e0       	ldi	r25, 0x00	; 0
    1816:	9c 83       	std	Y+4, r25	; 0x04
    1818:	8b 83       	std	Y+3, r24	; 0x03
    181a:	8b 81       	ldd	r24, Y+3	; 0x03
    181c:	9c 81       	ldd	r25, Y+4	; 0x04
    181e:	01 97       	sbiw	r24, 0x01	; 1
    1820:	f1 f7       	brne	.-4      	; 0x181e <LCD_voidInit+0xb4>
    1822:	9c 83       	std	Y+4, r25	; 0x04
    1824:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1826:	8d 81       	ldd	r24, Y+5	; 0x05
    1828:	9e 81       	ldd	r25, Y+6	; 0x06
    182a:	01 97       	sbiw	r24, 0x01	; 1
    182c:	9e 83       	std	Y+6, r25	; 0x06
    182e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1830:	8d 81       	ldd	r24, Y+5	; 0x05
    1832:	9e 81       	ldd	r25, Y+6	; 0x06
    1834:	00 97       	sbiw	r24, 0x00	; 0
    1836:	69 f7       	brne	.-38     	; 0x1812 <LCD_voidInit+0xa8>
    1838:	14 c0       	rjmp	.+40     	; 0x1862 <LCD_voidInit+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    183a:	6f 81       	ldd	r22, Y+7	; 0x07
    183c:	78 85       	ldd	r23, Y+8	; 0x08
    183e:	89 85       	ldd	r24, Y+9	; 0x09
    1840:	9a 85       	ldd	r25, Y+10	; 0x0a
    1842:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1846:	dc 01       	movw	r26, r24
    1848:	cb 01       	movw	r24, r22
    184a:	9e 83       	std	Y+6, r25	; 0x06
    184c:	8d 83       	std	Y+5, r24	; 0x05
    184e:	8d 81       	ldd	r24, Y+5	; 0x05
    1850:	9e 81       	ldd	r25, Y+6	; 0x06
    1852:	9a 83       	std	Y+2, r25	; 0x02
    1854:	89 83       	std	Y+1, r24	; 0x01
    1856:	89 81       	ldd	r24, Y+1	; 0x01
    1858:	9a 81       	ldd	r25, Y+2	; 0x02
    185a:	01 97       	sbiw	r24, 0x01	; 1
    185c:	f1 f7       	brne	.-4      	; 0x185a <LCD_voidInit+0xf0>
    185e:	9a 83       	std	Y+2, r25	; 0x02
    1860:	89 83       	std	Y+1, r24	; 0x01

	/*Put function set command 0011NFXX XX dont care
	 * N for number of line 0-->one line 1-->2 lines
	 * F for font size 0-->5x8 1-->5x11 */

	LCD_voidSendCommand(0b00111000);
    1862:	88 e3       	ldi	r24, 0x38	; 56
    1864:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <LCD_voidSendCommand>
	/*Display ON/OFF control 00001DCB
	 * D For display control 0--> Disable 1-->Enable
	 * C For cursor Enable 0-->Disable 1-->Enable
	 * B For Blink cursor enable 0-->Disable 1-->Enable*/

	LCD_voidSendCommand(0b00001100);
    1868:	8c e0       	ldi	r24, 0x0C	; 12
    186a:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <LCD_voidSendCommand>

	/*Display clear*/

	LCD_voidSendCommand(1);
    186e:	81 e0       	ldi	r24, 0x01	; 1
    1870:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <LCD_voidSendCommand>
	LCD_voidSendCommand(0x0c);
	LCD_voidSendCommand(0x06);

#endif

}
    1874:	2e 96       	adiw	r28, 0x0e	; 14
    1876:	0f b6       	in	r0, 0x3f	; 63
    1878:	f8 94       	cli
    187a:	de bf       	out	0x3e, r29	; 62
    187c:	0f be       	out	0x3f, r0	; 63
    187e:	cd bf       	out	0x3d, r28	; 61
    1880:	cf 91       	pop	r28
    1882:	df 91       	pop	r29
    1884:	08 95       	ret

00001886 <LCD_voidSendString>:

void LCD_voidSendString(const char* String )
{
    1886:	df 93       	push	r29
    1888:	cf 93       	push	r28
    188a:	00 d0       	rcall	.+0      	; 0x188c <LCD_voidSendString+0x6>
    188c:	0f 92       	push	r0
    188e:	cd b7       	in	r28, 0x3d	; 61
    1890:	de b7       	in	r29, 0x3e	; 62
    1892:	9b 83       	std	Y+3, r25	; 0x03
    1894:	8a 83       	std	Y+2, r24	; 0x02
	u8 Counter =  0 ;
    1896:	19 82       	std	Y+1, r1	; 0x01
    1898:	0e c0       	rjmp	.+28     	; 0x18b6 <LCD_voidSendString+0x30>
	while(String[Counter])
	{
		LCD_voidSendData(String[Counter]);
    189a:	89 81       	ldd	r24, Y+1	; 0x01
    189c:	28 2f       	mov	r18, r24
    189e:	30 e0       	ldi	r19, 0x00	; 0
    18a0:	8a 81       	ldd	r24, Y+2	; 0x02
    18a2:	9b 81       	ldd	r25, Y+3	; 0x03
    18a4:	fc 01       	movw	r30, r24
    18a6:	e2 0f       	add	r30, r18
    18a8:	f3 1f       	adc	r31, r19
    18aa:	80 81       	ld	r24, Z
    18ac:	0e 94 17 0b 	call	0x162e	; 0x162e <LCD_voidSendData>
		Counter++;
    18b0:	89 81       	ldd	r24, Y+1	; 0x01
    18b2:	8f 5f       	subi	r24, 0xFF	; 255
    18b4:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_voidSendString(const char* String )
{
	u8 Counter =  0 ;
	while(String[Counter])
    18b6:	89 81       	ldd	r24, Y+1	; 0x01
    18b8:	28 2f       	mov	r18, r24
    18ba:	30 e0       	ldi	r19, 0x00	; 0
    18bc:	8a 81       	ldd	r24, Y+2	; 0x02
    18be:	9b 81       	ldd	r25, Y+3	; 0x03
    18c0:	fc 01       	movw	r30, r24
    18c2:	e2 0f       	add	r30, r18
    18c4:	f3 1f       	adc	r31, r19
    18c6:	80 81       	ld	r24, Z
    18c8:	88 23       	and	r24, r24
    18ca:	39 f7       	brne	.-50     	; 0x189a <LCD_voidSendString+0x14>
	{
		LCD_voidSendData(String[Counter]);
		Counter++;
	}
}
    18cc:	0f 90       	pop	r0
    18ce:	0f 90       	pop	r0
    18d0:	0f 90       	pop	r0
    18d2:	cf 91       	pop	r28
    18d4:	df 91       	pop	r29
    18d6:	08 95       	ret

000018d8 <LCD_voidGoToXY>:

void LCD_voidGoToXY(u8 X_position,u8 Y_Position)
{
    18d8:	df 93       	push	r29
    18da:	cf 93       	push	r28
    18dc:	00 d0       	rcall	.+0      	; 0x18de <LCD_voidGoToXY+0x6>
    18de:	0f 92       	push	r0
    18e0:	cd b7       	in	r28, 0x3d	; 61
    18e2:	de b7       	in	r29, 0x3e	; 62
    18e4:	8a 83       	std	Y+2, r24	; 0x02
    18e6:	6b 83       	std	Y+3, r22	; 0x03
	u8 Address;
	/*X position is the Row and Y is Col.
	 * Address of first row is from 0 to 0xf
	 * Second row is from 0x40 to 0x4f*/
	if(X_position==0)
    18e8:	8a 81       	ldd	r24, Y+2	; 0x02
    18ea:	88 23       	and	r24, r24
    18ec:	19 f4       	brne	.+6      	; 0x18f4 <LCD_voidGoToXY+0x1c>
	{
		Address =Y_Position;
    18ee:	8b 81       	ldd	r24, Y+3	; 0x03
    18f0:	89 83       	std	Y+1, r24	; 0x01
    18f2:	06 c0       	rjmp	.+12     	; 0x1900 <LCD_voidGoToXY+0x28>
	}
	else if(X_position==1)
    18f4:	8a 81       	ldd	r24, Y+2	; 0x02
    18f6:	81 30       	cpi	r24, 0x01	; 1
    18f8:	19 f4       	brne	.+6      	; 0x1900 <LCD_voidGoToXY+0x28>
	{
		Address =0x40 + Y_Position ;
    18fa:	8b 81       	ldd	r24, Y+3	; 0x03
    18fc:	80 5c       	subi	r24, 0xC0	; 192
    18fe:	89 83       	std	Y+1, r24	; 0x01
	}
	/*The command to set address that you want is 0b10000000
	 * So we add 128 to the address*/
	LCD_voidSendCommand((Address|0b10000000));
    1900:	89 81       	ldd	r24, Y+1	; 0x01
    1902:	80 68       	ori	r24, 0x80	; 128
    1904:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <LCD_voidSendCommand>
}
    1908:	0f 90       	pop	r0
    190a:	0f 90       	pop	r0
    190c:	0f 90       	pop	r0
    190e:	cf 91       	pop	r28
    1910:	df 91       	pop	r29
    1912:	08 95       	ret

00001914 <LCD_voidSpecialChar>:

void LCD_voidSpecialChar(u8* Pattern,u8 Block_no,u8 Xposition,u8 Yposition)
{
    1914:	df 93       	push	r29
    1916:	cf 93       	push	r28
    1918:	cd b7       	in	r28, 0x3d	; 61
    191a:	de b7       	in	r29, 0x3e	; 62
    191c:	27 97       	sbiw	r28, 0x07	; 7
    191e:	0f b6       	in	r0, 0x3f	; 63
    1920:	f8 94       	cli
    1922:	de bf       	out	0x3e, r29	; 62
    1924:	0f be       	out	0x3f, r0	; 63
    1926:	cd bf       	out	0x3d, r28	; 61
    1928:	9c 83       	std	Y+4, r25	; 0x04
    192a:	8b 83       	std	Y+3, r24	; 0x03
    192c:	6d 83       	std	Y+5, r22	; 0x05
    192e:	4e 83       	std	Y+6, r20	; 0x06
    1930:	2f 83       	std	Y+7, r18	; 0x07
	u8 Address = Block_no*8;
    1932:	8d 81       	ldd	r24, Y+5	; 0x05
    1934:	88 2f       	mov	r24, r24
    1936:	90 e0       	ldi	r25, 0x00	; 0
    1938:	88 0f       	add	r24, r24
    193a:	99 1f       	adc	r25, r25
    193c:	88 0f       	add	r24, r24
    193e:	99 1f       	adc	r25, r25
    1940:	88 0f       	add	r24, r24
    1942:	99 1f       	adc	r25, r25
    1944:	8a 83       	std	Y+2, r24	; 0x02
	LCD_voidSendCommand(Address+64);
    1946:	8a 81       	ldd	r24, Y+2	; 0x02
    1948:	80 5c       	subi	r24, 0xC0	; 192
    194a:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <LCD_voidSendCommand>
	for(u8 i=0 ;i<8;i++)
    194e:	19 82       	std	Y+1, r1	; 0x01
    1950:	0e c0       	rjmp	.+28     	; 0x196e <LCD_voidSpecialChar+0x5a>
	{
		LCD_voidSendData(Pattern[i]);
    1952:	89 81       	ldd	r24, Y+1	; 0x01
    1954:	28 2f       	mov	r18, r24
    1956:	30 e0       	ldi	r19, 0x00	; 0
    1958:	8b 81       	ldd	r24, Y+3	; 0x03
    195a:	9c 81       	ldd	r25, Y+4	; 0x04
    195c:	fc 01       	movw	r30, r24
    195e:	e2 0f       	add	r30, r18
    1960:	f3 1f       	adc	r31, r19
    1962:	80 81       	ld	r24, Z
    1964:	0e 94 17 0b 	call	0x162e	; 0x162e <LCD_voidSendData>

void LCD_voidSpecialChar(u8* Pattern,u8 Block_no,u8 Xposition,u8 Yposition)
{
	u8 Address = Block_no*8;
	LCD_voidSendCommand(Address+64);
	for(u8 i=0 ;i<8;i++)
    1968:	89 81       	ldd	r24, Y+1	; 0x01
    196a:	8f 5f       	subi	r24, 0xFF	; 255
    196c:	89 83       	std	Y+1, r24	; 0x01
    196e:	89 81       	ldd	r24, Y+1	; 0x01
    1970:	88 30       	cpi	r24, 0x08	; 8
    1972:	78 f3       	brcs	.-34     	; 0x1952 <LCD_voidSpecialChar+0x3e>
	{
		LCD_voidSendData(Pattern[i]);
	}
	LCD_voidGoToXY(Xposition,Yposition);
    1974:	8e 81       	ldd	r24, Y+6	; 0x06
    1976:	6f 81       	ldd	r22, Y+7	; 0x07
    1978:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <LCD_voidGoToXY>
	LCD_voidSendData(Block_no);
    197c:	8d 81       	ldd	r24, Y+5	; 0x05
    197e:	0e 94 17 0b 	call	0x162e	; 0x162e <LCD_voidSendData>
}
    1982:	27 96       	adiw	r28, 0x07	; 7
    1984:	0f b6       	in	r0, 0x3f	; 63
    1986:	f8 94       	cli
    1988:	de bf       	out	0x3e, r29	; 62
    198a:	0f be       	out	0x3f, r0	; 63
    198c:	cd bf       	out	0x3d, r28	; 61
    198e:	cf 91       	pop	r28
    1990:	df 91       	pop	r29
    1992:	08 95       	ret

00001994 <LCD_voidWriteNumber>:
void LCD_voidWriteNumber(u32 Number)
{
    1994:	df 93       	push	r29
    1996:	cf 93       	push	r28
    1998:	cd b7       	in	r28, 0x3d	; 61
    199a:	de b7       	in	r29, 0x3e	; 62
    199c:	63 97       	sbiw	r28, 0x13	; 19
    199e:	0f b6       	in	r0, 0x3f	; 63
    19a0:	f8 94       	cli
    19a2:	de bf       	out	0x3e, r29	; 62
    19a4:	0f be       	out	0x3f, r0	; 63
    19a6:	cd bf       	out	0x3d, r28	; 61
    19a8:	68 8b       	std	Y+16, r22	; 0x10
    19aa:	79 8b       	std	Y+17, r23	; 0x11
    19ac:	8a 8b       	std	Y+18, r24	; 0x12
    19ae:	9b 8b       	std	Y+19, r25	; 0x13
	u8 str[8];
	u8 i;
	u32 num;
	u8 rem;
	u8 len =0;
    19b0:	19 82       	std	Y+1, r1	; 0x01
	num=Number;
    19b2:	88 89       	ldd	r24, Y+16	; 0x10
    19b4:	99 89       	ldd	r25, Y+17	; 0x11
    19b6:	aa 89       	ldd	r26, Y+18	; 0x12
    19b8:	bb 89       	ldd	r27, Y+19	; 0x13
    19ba:	8b 83       	std	Y+3, r24	; 0x03
    19bc:	9c 83       	std	Y+4, r25	; 0x04
    19be:	ad 83       	std	Y+5, r26	; 0x05
    19c0:	be 83       	std	Y+6, r27	; 0x06
    19c2:	15 c0       	rjmp	.+42     	; 0x19ee <LCD_voidWriteNumber+0x5a>
	while(num != 0)
	{
		len++;
    19c4:	89 81       	ldd	r24, Y+1	; 0x01
    19c6:	8f 5f       	subi	r24, 0xFF	; 255
    19c8:	89 83       	std	Y+1, r24	; 0x01
		num=num/10;
    19ca:	8b 81       	ldd	r24, Y+3	; 0x03
    19cc:	9c 81       	ldd	r25, Y+4	; 0x04
    19ce:	ad 81       	ldd	r26, Y+5	; 0x05
    19d0:	be 81       	ldd	r27, Y+6	; 0x06
    19d2:	2a e0       	ldi	r18, 0x0A	; 10
    19d4:	30 e0       	ldi	r19, 0x00	; 0
    19d6:	40 e0       	ldi	r20, 0x00	; 0
    19d8:	50 e0       	ldi	r21, 0x00	; 0
    19da:	bc 01       	movw	r22, r24
    19dc:	cd 01       	movw	r24, r26
    19de:	0e 94 a9 20 	call	0x4152	; 0x4152 <__udivmodsi4>
    19e2:	da 01       	movw	r26, r20
    19e4:	c9 01       	movw	r24, r18
    19e6:	8b 83       	std	Y+3, r24	; 0x03
    19e8:	9c 83       	std	Y+4, r25	; 0x04
    19ea:	ad 83       	std	Y+5, r26	; 0x05
    19ec:	be 83       	std	Y+6, r27	; 0x06
	u8 i;
	u32 num;
	u8 rem;
	u8 len =0;
	num=Number;
	while(num != 0)
    19ee:	8b 81       	ldd	r24, Y+3	; 0x03
    19f0:	9c 81       	ldd	r25, Y+4	; 0x04
    19f2:	ad 81       	ldd	r26, Y+5	; 0x05
    19f4:	be 81       	ldd	r27, Y+6	; 0x06
    19f6:	00 97       	sbiw	r24, 0x00	; 0
    19f8:	a1 05       	cpc	r26, r1
    19fa:	b1 05       	cpc	r27, r1
    19fc:	19 f7       	brne	.-58     	; 0x19c4 <LCD_voidWriteNumber+0x30>
	{
		len++;
		num=num/10;
	}
	if(len==0)
    19fe:	89 81       	ldd	r24, Y+1	; 0x01
    1a00:	88 23       	and	r24, r24
    1a02:	19 f4       	brne	.+6      	; 0x1a0a <LCD_voidWriteNumber+0x76>
	{
		LCD_voidSendData('0');
    1a04:	80 e3       	ldi	r24, 0x30	; 48
    1a06:	0e 94 17 0b 	call	0x162e	; 0x162e <LCD_voidSendData>

	}
	for(i=0;i<len;i++)
    1a0a:	1f 82       	std	Y+7, r1	; 0x07
    1a0c:	37 c0       	rjmp	.+110    	; 0x1a7c <LCD_voidWriteNumber+0xe8>
	{
		rem=Number%10;
    1a0e:	88 89       	ldd	r24, Y+16	; 0x10
    1a10:	99 89       	ldd	r25, Y+17	; 0x11
    1a12:	aa 89       	ldd	r26, Y+18	; 0x12
    1a14:	bb 89       	ldd	r27, Y+19	; 0x13
    1a16:	2a e0       	ldi	r18, 0x0A	; 10
    1a18:	30 e0       	ldi	r19, 0x00	; 0
    1a1a:	40 e0       	ldi	r20, 0x00	; 0
    1a1c:	50 e0       	ldi	r21, 0x00	; 0
    1a1e:	bc 01       	movw	r22, r24
    1a20:	cd 01       	movw	r24, r26
    1a22:	0e 94 a9 20 	call	0x4152	; 0x4152 <__udivmodsi4>
    1a26:	dc 01       	movw	r26, r24
    1a28:	cb 01       	movw	r24, r22
    1a2a:	8a 83       	std	Y+2, r24	; 0x02
		Number=Number/10;
    1a2c:	88 89       	ldd	r24, Y+16	; 0x10
    1a2e:	99 89       	ldd	r25, Y+17	; 0x11
    1a30:	aa 89       	ldd	r26, Y+18	; 0x12
    1a32:	bb 89       	ldd	r27, Y+19	; 0x13
    1a34:	2a e0       	ldi	r18, 0x0A	; 10
    1a36:	30 e0       	ldi	r19, 0x00	; 0
    1a38:	40 e0       	ldi	r20, 0x00	; 0
    1a3a:	50 e0       	ldi	r21, 0x00	; 0
    1a3c:	bc 01       	movw	r22, r24
    1a3e:	cd 01       	movw	r24, r26
    1a40:	0e 94 a9 20 	call	0x4152	; 0x4152 <__udivmodsi4>
    1a44:	da 01       	movw	r26, r20
    1a46:	c9 01       	movw	r24, r18
    1a48:	88 8b       	std	Y+16, r24	; 0x10
    1a4a:	99 8b       	std	Y+17, r25	; 0x11
    1a4c:	aa 8b       	std	Y+18, r26	; 0x12
    1a4e:	bb 8b       	std	Y+19, r27	; 0x13
		str[len-(i+1)]=rem+'0';
    1a50:	89 81       	ldd	r24, Y+1	; 0x01
    1a52:	28 2f       	mov	r18, r24
    1a54:	30 e0       	ldi	r19, 0x00	; 0
    1a56:	8f 81       	ldd	r24, Y+7	; 0x07
    1a58:	88 2f       	mov	r24, r24
    1a5a:	90 e0       	ldi	r25, 0x00	; 0
    1a5c:	80 95       	com	r24
    1a5e:	90 95       	com	r25
    1a60:	28 0f       	add	r18, r24
    1a62:	39 1f       	adc	r19, r25
    1a64:	8a 81       	ldd	r24, Y+2	; 0x02
    1a66:	48 2f       	mov	r20, r24
    1a68:	40 5d       	subi	r20, 0xD0	; 208
    1a6a:	ce 01       	movw	r24, r28
    1a6c:	08 96       	adiw	r24, 0x08	; 8
    1a6e:	fc 01       	movw	r30, r24
    1a70:	e2 0f       	add	r30, r18
    1a72:	f3 1f       	adc	r31, r19
    1a74:	40 83       	st	Z, r20
	if(len==0)
	{
		LCD_voidSendData('0');

	}
	for(i=0;i<len;i++)
    1a76:	8f 81       	ldd	r24, Y+7	; 0x07
    1a78:	8f 5f       	subi	r24, 0xFF	; 255
    1a7a:	8f 83       	std	Y+7, r24	; 0x07
    1a7c:	9f 81       	ldd	r25, Y+7	; 0x07
    1a7e:	89 81       	ldd	r24, Y+1	; 0x01
    1a80:	98 17       	cp	r25, r24
    1a82:	28 f2       	brcs	.-118    	; 0x1a0e <LCD_voidWriteNumber+0x7a>
	{
		rem=Number%10;
		Number=Number/10;
		str[len-(i+1)]=rem+'0';
	}
	str[len]='\0';
    1a84:	89 81       	ldd	r24, Y+1	; 0x01
    1a86:	28 2f       	mov	r18, r24
    1a88:	30 e0       	ldi	r19, 0x00	; 0
    1a8a:	ce 01       	movw	r24, r28
    1a8c:	08 96       	adiw	r24, 0x08	; 8
    1a8e:	fc 01       	movw	r30, r24
    1a90:	e2 0f       	add	r30, r18
    1a92:	f3 1f       	adc	r31, r19
    1a94:	10 82       	st	Z, r1
	LCD_voidSendString(str);
    1a96:	ce 01       	movw	r24, r28
    1a98:	08 96       	adiw	r24, 0x08	; 8
    1a9a:	0e 94 43 0c 	call	0x1886	; 0x1886 <LCD_voidSendString>
}
    1a9e:	63 96       	adiw	r28, 0x13	; 19
    1aa0:	0f b6       	in	r0, 0x3f	; 63
    1aa2:	f8 94       	cli
    1aa4:	de bf       	out	0x3e, r29	; 62
    1aa6:	0f be       	out	0x3f, r0	; 63
    1aa8:	cd bf       	out	0x3d, r28	; 61
    1aaa:	cf 91       	pop	r28
    1aac:	df 91       	pop	r29
    1aae:	08 95       	ret

00001ab0 <PORT_voidInit>:
/*********************************************************************************/
/*********************************************************************************/
#include "Port_interface.h"

void PORT_voidInit(void)
{
    1ab0:	df 93       	push	r29
    1ab2:	cf 93       	push	r28
    1ab4:	cd b7       	in	r28, 0x3d	; 61
    1ab6:	de b7       	in	r29, 0x3e	; 62
	DDRA = PORTA_DIR ;
    1ab8:	ea e3       	ldi	r30, 0x3A	; 58
    1aba:	f0 e0       	ldi	r31, 0x00	; 0
    1abc:	8f ef       	ldi	r24, 0xFF	; 255
    1abe:	80 83       	st	Z, r24
	DDRB = PORTB_DIR ;
    1ac0:	e7 e3       	ldi	r30, 0x37	; 55
    1ac2:	f0 e0       	ldi	r31, 0x00	; 0
    1ac4:	87 e0       	ldi	r24, 0x07	; 7
    1ac6:	80 83       	st	Z, r24
	DDRC = PORTC_DIR ;
    1ac8:	e4 e3       	ldi	r30, 0x34	; 52
    1aca:	f0 e0       	ldi	r31, 0x00	; 0
    1acc:	10 82       	st	Z, r1
	DDRD = PORTD_DIR ;
    1ace:	e1 e3       	ldi	r30, 0x31	; 49
    1ad0:	f0 e0       	ldi	r31, 0x00	; 0
    1ad2:	10 82       	st	Z, r1

	PORTA = PORTA_INT;
    1ad4:	eb e3       	ldi	r30, 0x3B	; 59
    1ad6:	f0 e0       	ldi	r31, 0x00	; 0
    1ad8:	10 82       	st	Z, r1
	PORTB = PORTB_INT;
    1ada:	e8 e3       	ldi	r30, 0x38	; 56
    1adc:	f0 e0       	ldi	r31, 0x00	; 0
    1ade:	10 82       	st	Z, r1
	PORTC = PORTC_INT;
    1ae0:	e5 e3       	ldi	r30, 0x35	; 53
    1ae2:	f0 e0       	ldi	r31, 0x00	; 0
    1ae4:	10 82       	st	Z, r1
	PORTD = PORTD_INT;
    1ae6:	e2 e3       	ldi	r30, 0x32	; 50
    1ae8:	f0 e0       	ldi	r31, 0x00	; 0
    1aea:	10 82       	st	Z, r1
}
    1aec:	cf 91       	pop	r28
    1aee:	df 91       	pop	r29
    1af0:	08 95       	ret

00001af2 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1af2:	df 93       	push	r29
    1af4:	cf 93       	push	r28
    1af6:	cd b7       	in	r28, 0x3d	; 61
    1af8:	de b7       	in	r29, 0x3e	; 62
    1afa:	27 97       	sbiw	r28, 0x07	; 7
    1afc:	0f b6       	in	r0, 0x3f	; 63
    1afe:	f8 94       	cli
    1b00:	de bf       	out	0x3e, r29	; 62
    1b02:	0f be       	out	0x3f, r0	; 63
    1b04:	cd bf       	out	0x3d, r28	; 61
    1b06:	9d 83       	std	Y+5, r25	; 0x05
    1b08:	8c 83       	std	Y+4, r24	; 0x04
    1b0a:	6e 83       	std	Y+6, r22	; 0x06
    1b0c:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1b0e:	8a e1       	ldi	r24, 0x1A	; 26
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	0e 94 51 10 	call	0x20a2	; 0x20a2 <pvPortMalloc>
    1b16:	9a 83       	std	Y+2, r25	; 0x02
    1b18:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    1b1a:	89 81       	ldd	r24, Y+1	; 0x01
    1b1c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b1e:	00 97       	sbiw	r24, 0x00	; 0
    1b20:	09 f4       	brne	.+2      	; 0x1b24 <xCoRoutineCreate+0x32>
    1b22:	6f c0       	rjmp	.+222    	; 0x1c02 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1b24:	80 91 82 01 	lds	r24, 0x0182
    1b28:	90 91 83 01 	lds	r25, 0x0183
    1b2c:	00 97       	sbiw	r24, 0x00	; 0
    1b2e:	41 f4       	brne	.+16     	; 0x1b40 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1b30:	89 81       	ldd	r24, Y+1	; 0x01
    1b32:	9a 81       	ldd	r25, Y+2	; 0x02
    1b34:	90 93 83 01 	sts	0x0183, r25
    1b38:	80 93 82 01 	sts	0x0182, r24
			prvInitialiseCoRoutineLists();
    1b3c:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    1b40:	8e 81       	ldd	r24, Y+6	; 0x06
    1b42:	82 30       	cpi	r24, 0x02	; 2
    1b44:	10 f0       	brcs	.+4      	; 0x1b4a <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    1b46:	81 e0       	ldi	r24, 0x01	; 1
    1b48:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1b4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1b4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1b4e:	11 8e       	std	Z+25, r1	; 0x19
    1b50:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1b52:	e9 81       	ldd	r30, Y+1	; 0x01
    1b54:	fa 81       	ldd	r31, Y+2	; 0x02
    1b56:	8e 81       	ldd	r24, Y+6	; 0x06
    1b58:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1b5a:	e9 81       	ldd	r30, Y+1	; 0x01
    1b5c:	fa 81       	ldd	r31, Y+2	; 0x02
    1b5e:	8f 81       	ldd	r24, Y+7	; 0x07
    1b60:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1b62:	e9 81       	ldd	r30, Y+1	; 0x01
    1b64:	fa 81       	ldd	r31, Y+2	; 0x02
    1b66:	8c 81       	ldd	r24, Y+4	; 0x04
    1b68:	9d 81       	ldd	r25, Y+5	; 0x05
    1b6a:	91 83       	std	Z+1, r25	; 0x01
    1b6c:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1b6e:	89 81       	ldd	r24, Y+1	; 0x01
    1b70:	9a 81       	ldd	r25, Y+2	; 0x02
    1b72:	02 96       	adiw	r24, 0x02	; 2
    1b74:	0e 94 e7 10 	call	0x21ce	; 0x21ce <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1b78:	89 81       	ldd	r24, Y+1	; 0x01
    1b7a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b7c:	0c 96       	adiw	r24, 0x0c	; 12
    1b7e:	0e 94 e7 10 	call	0x21ce	; 0x21ce <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1b82:	e9 81       	ldd	r30, Y+1	; 0x01
    1b84:	fa 81       	ldd	r31, Y+2	; 0x02
    1b86:	89 81       	ldd	r24, Y+1	; 0x01
    1b88:	9a 81       	ldd	r25, Y+2	; 0x02
    1b8a:	91 87       	std	Z+9, r25	; 0x09
    1b8c:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b90:	fa 81       	ldd	r31, Y+2	; 0x02
    1b92:	89 81       	ldd	r24, Y+1	; 0x01
    1b94:	9a 81       	ldd	r25, Y+2	; 0x02
    1b96:	93 8b       	std	Z+19, r25	; 0x13
    1b98:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1b9a:	8e 81       	ldd	r24, Y+6	; 0x06
    1b9c:	28 2f       	mov	r18, r24
    1b9e:	30 e0       	ldi	r19, 0x00	; 0
    1ba0:	84 e0       	ldi	r24, 0x04	; 4
    1ba2:	90 e0       	ldi	r25, 0x00	; 0
    1ba4:	82 1b       	sub	r24, r18
    1ba6:	93 0b       	sbc	r25, r19
    1ba8:	e9 81       	ldd	r30, Y+1	; 0x01
    1baa:	fa 81       	ldd	r31, Y+2	; 0x02
    1bac:	95 87       	std	Z+13, r25	; 0x0d
    1bae:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1bb0:	e9 81       	ldd	r30, Y+1	; 0x01
    1bb2:	fa 81       	ldd	r31, Y+2	; 0x02
    1bb4:	96 89       	ldd	r25, Z+22	; 0x16
    1bb6:	80 91 84 01 	lds	r24, 0x0184
    1bba:	89 17       	cp	r24, r25
    1bbc:	28 f4       	brcc	.+10     	; 0x1bc8 <xCoRoutineCreate+0xd6>
    1bbe:	e9 81       	ldd	r30, Y+1	; 0x01
    1bc0:	fa 81       	ldd	r31, Y+2	; 0x02
    1bc2:	86 89       	ldd	r24, Z+22	; 0x16
    1bc4:	80 93 84 01 	sts	0x0184, r24
    1bc8:	e9 81       	ldd	r30, Y+1	; 0x01
    1bca:	fa 81       	ldd	r31, Y+2	; 0x02
    1bcc:	86 89       	ldd	r24, Z+22	; 0x16
    1bce:	28 2f       	mov	r18, r24
    1bd0:	30 e0       	ldi	r19, 0x00	; 0
    1bd2:	c9 01       	movw	r24, r18
    1bd4:	88 0f       	add	r24, r24
    1bd6:	99 1f       	adc	r25, r25
    1bd8:	88 0f       	add	r24, r24
    1bda:	99 1f       	adc	r25, r25
    1bdc:	88 0f       	add	r24, r24
    1bde:	99 1f       	adc	r25, r25
    1be0:	82 0f       	add	r24, r18
    1be2:	93 1f       	adc	r25, r19
    1be4:	ac 01       	movw	r20, r24
    1be6:	45 57       	subi	r20, 0x75	; 117
    1be8:	5e 4f       	sbci	r21, 0xFE	; 254
    1bea:	89 81       	ldd	r24, Y+1	; 0x01
    1bec:	9a 81       	ldd	r25, Y+2	; 0x02
    1bee:	9c 01       	movw	r18, r24
    1bf0:	2e 5f       	subi	r18, 0xFE	; 254
    1bf2:	3f 4f       	sbci	r19, 0xFF	; 255
    1bf4:	ca 01       	movw	r24, r20
    1bf6:	b9 01       	movw	r22, r18
    1bf8:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vListInsertEnd>

		xReturn = pdPASS;
    1bfc:	81 e0       	ldi	r24, 0x01	; 1
    1bfe:	8b 83       	std	Y+3, r24	; 0x03
    1c00:	02 c0       	rjmp	.+4      	; 0x1c06 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1c02:	8f ef       	ldi	r24, 0xFF	; 255
    1c04:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    1c06:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1c08:	27 96       	adiw	r28, 0x07	; 7
    1c0a:	0f b6       	in	r0, 0x3f	; 63
    1c0c:	f8 94       	cli
    1c0e:	de bf       	out	0x3e, r29	; 62
    1c10:	0f be       	out	0x3f, r0	; 63
    1c12:	cd bf       	out	0x3d, r28	; 61
    1c14:	cf 91       	pop	r28
    1c16:	df 91       	pop	r29
    1c18:	08 95       	ret

00001c1a <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1c1a:	df 93       	push	r29
    1c1c:	cf 93       	push	r28
    1c1e:	00 d0       	rcall	.+0      	; 0x1c20 <vCoRoutineAddToDelayedList+0x6>
    1c20:	00 d0       	rcall	.+0      	; 0x1c22 <vCoRoutineAddToDelayedList+0x8>
    1c22:	00 d0       	rcall	.+0      	; 0x1c24 <vCoRoutineAddToDelayedList+0xa>
    1c24:	cd b7       	in	r28, 0x3d	; 61
    1c26:	de b7       	in	r29, 0x3e	; 62
    1c28:	9c 83       	std	Y+4, r25	; 0x04
    1c2a:	8b 83       	std	Y+3, r24	; 0x03
    1c2c:	7e 83       	std	Y+6, r23	; 0x06
    1c2e:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1c30:	20 91 85 01 	lds	r18, 0x0185
    1c34:	30 91 86 01 	lds	r19, 0x0186
    1c38:	8b 81       	ldd	r24, Y+3	; 0x03
    1c3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c3c:	82 0f       	add	r24, r18
    1c3e:	93 1f       	adc	r25, r19
    1c40:	9a 83       	std	Y+2, r25	; 0x02
    1c42:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1c44:	80 91 82 01 	lds	r24, 0x0182
    1c48:	90 91 83 01 	lds	r25, 0x0183
    1c4c:	02 96       	adiw	r24, 0x02	; 2
    1c4e:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1c52:	e0 91 82 01 	lds	r30, 0x0182
    1c56:	f0 91 83 01 	lds	r31, 0x0183
    1c5a:	89 81       	ldd	r24, Y+1	; 0x01
    1c5c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c5e:	93 83       	std	Z+3, r25	; 0x03
    1c60:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1c62:	20 91 85 01 	lds	r18, 0x0185
    1c66:	30 91 86 01 	lds	r19, 0x0186
    1c6a:	89 81       	ldd	r24, Y+1	; 0x01
    1c6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c6e:	82 17       	cp	r24, r18
    1c70:	93 07       	cpc	r25, r19
    1c72:	70 f4       	brcc	.+28     	; 0x1c90 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1c74:	80 91 b1 01 	lds	r24, 0x01B1
    1c78:	90 91 b2 01 	lds	r25, 0x01B2
    1c7c:	20 91 82 01 	lds	r18, 0x0182
    1c80:	30 91 83 01 	lds	r19, 0x0183
    1c84:	2e 5f       	subi	r18, 0xFE	; 254
    1c86:	3f 4f       	sbci	r19, 0xFF	; 255
    1c88:	b9 01       	movw	r22, r18
    1c8a:	0e 94 43 11 	call	0x2286	; 0x2286 <vListInsert>
    1c8e:	0d c0       	rjmp	.+26     	; 0x1caa <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1c90:	80 91 af 01 	lds	r24, 0x01AF
    1c94:	90 91 b0 01 	lds	r25, 0x01B0
    1c98:	20 91 82 01 	lds	r18, 0x0182
    1c9c:	30 91 83 01 	lds	r19, 0x0183
    1ca0:	2e 5f       	subi	r18, 0xFE	; 254
    1ca2:	3f 4f       	sbci	r19, 0xFF	; 255
    1ca4:	b9 01       	movw	r22, r18
    1ca6:	0e 94 43 11 	call	0x2286	; 0x2286 <vListInsert>
	}

	if( pxEventList )
    1caa:	8d 81       	ldd	r24, Y+5	; 0x05
    1cac:	9e 81       	ldd	r25, Y+6	; 0x06
    1cae:	00 97       	sbiw	r24, 0x00	; 0
    1cb0:	61 f0       	breq	.+24     	; 0x1cca <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1cb2:	80 91 82 01 	lds	r24, 0x0182
    1cb6:	90 91 83 01 	lds	r25, 0x0183
    1cba:	9c 01       	movw	r18, r24
    1cbc:	24 5f       	subi	r18, 0xF4	; 244
    1cbe:	3f 4f       	sbci	r19, 0xFF	; 255
    1cc0:	8d 81       	ldd	r24, Y+5	; 0x05
    1cc2:	9e 81       	ldd	r25, Y+6	; 0x06
    1cc4:	b9 01       	movw	r22, r18
    1cc6:	0e 94 43 11 	call	0x2286	; 0x2286 <vListInsert>
	}
}
    1cca:	26 96       	adiw	r28, 0x06	; 6
    1ccc:	0f b6       	in	r0, 0x3f	; 63
    1cce:	f8 94       	cli
    1cd0:	de bf       	out	0x3e, r29	; 62
    1cd2:	0f be       	out	0x3f, r0	; 63
    1cd4:	cd bf       	out	0x3d, r28	; 61
    1cd6:	cf 91       	pop	r28
    1cd8:	df 91       	pop	r29
    1cda:	08 95       	ret

00001cdc <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    1cdc:	df 93       	push	r29
    1cde:	cf 93       	push	r28
    1ce0:	00 d0       	rcall	.+0      	; 0x1ce2 <prvCheckPendingReadyList+0x6>
    1ce2:	cd b7       	in	r28, 0x3d	; 61
    1ce4:	de b7       	in	r29, 0x3e	; 62
    1ce6:	3a c0       	rjmp	.+116    	; 0x1d5c <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1ce8:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1cea:	e0 91 b8 01 	lds	r30, 0x01B8
    1cee:	f0 91 b9 01 	lds	r31, 0x01B9
    1cf2:	86 81       	ldd	r24, Z+6	; 0x06
    1cf4:	97 81       	ldd	r25, Z+7	; 0x07
    1cf6:	9a 83       	std	Y+2, r25	; 0x02
    1cf8:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1cfa:	89 81       	ldd	r24, Y+1	; 0x01
    1cfc:	9a 81       	ldd	r25, Y+2	; 0x02
    1cfe:	0c 96       	adiw	r24, 0x0c	; 12
    1d00:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
		}
		portENABLE_INTERRUPTS();
    1d04:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1d06:	89 81       	ldd	r24, Y+1	; 0x01
    1d08:	9a 81       	ldd	r25, Y+2	; 0x02
    1d0a:	02 96       	adiw	r24, 0x02	; 2
    1d0c:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1d10:	e9 81       	ldd	r30, Y+1	; 0x01
    1d12:	fa 81       	ldd	r31, Y+2	; 0x02
    1d14:	96 89       	ldd	r25, Z+22	; 0x16
    1d16:	80 91 84 01 	lds	r24, 0x0184
    1d1a:	89 17       	cp	r24, r25
    1d1c:	28 f4       	brcc	.+10     	; 0x1d28 <prvCheckPendingReadyList+0x4c>
    1d1e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d20:	fa 81       	ldd	r31, Y+2	; 0x02
    1d22:	86 89       	ldd	r24, Z+22	; 0x16
    1d24:	80 93 84 01 	sts	0x0184, r24
    1d28:	e9 81       	ldd	r30, Y+1	; 0x01
    1d2a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d2c:	86 89       	ldd	r24, Z+22	; 0x16
    1d2e:	28 2f       	mov	r18, r24
    1d30:	30 e0       	ldi	r19, 0x00	; 0
    1d32:	c9 01       	movw	r24, r18
    1d34:	88 0f       	add	r24, r24
    1d36:	99 1f       	adc	r25, r25
    1d38:	88 0f       	add	r24, r24
    1d3a:	99 1f       	adc	r25, r25
    1d3c:	88 0f       	add	r24, r24
    1d3e:	99 1f       	adc	r25, r25
    1d40:	82 0f       	add	r24, r18
    1d42:	93 1f       	adc	r25, r19
    1d44:	ac 01       	movw	r20, r24
    1d46:	45 57       	subi	r20, 0x75	; 117
    1d48:	5e 4f       	sbci	r21, 0xFE	; 254
    1d4a:	89 81       	ldd	r24, Y+1	; 0x01
    1d4c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d4e:	9c 01       	movw	r18, r24
    1d50:	2e 5f       	subi	r18, 0xFE	; 254
    1d52:	3f 4f       	sbci	r19, 0xFF	; 255
    1d54:	ca 01       	movw	r24, r20
    1d56:	b9 01       	movw	r22, r18
    1d58:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1d5c:	80 91 b3 01 	lds	r24, 0x01B3
    1d60:	88 23       	and	r24, r24
    1d62:	09 f0       	breq	.+2      	; 0x1d66 <prvCheckPendingReadyList+0x8a>
    1d64:	c1 cf       	rjmp	.-126    	; 0x1ce8 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    1d66:	0f 90       	pop	r0
    1d68:	0f 90       	pop	r0
    1d6a:	cf 91       	pop	r28
    1d6c:	df 91       	pop	r29
    1d6e:	08 95       	ret

00001d70 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    1d70:	df 93       	push	r29
    1d72:	cf 93       	push	r28
    1d74:	00 d0       	rcall	.+0      	; 0x1d76 <prvCheckDelayedList+0x6>
    1d76:	00 d0       	rcall	.+0      	; 0x1d78 <prvCheckDelayedList+0x8>
    1d78:	cd b7       	in	r28, 0x3d	; 61
    1d7a:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1d7c:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <xTaskGetTickCount>
    1d80:	20 91 87 01 	lds	r18, 0x0187
    1d84:	30 91 88 01 	lds	r19, 0x0188
    1d88:	82 1b       	sub	r24, r18
    1d8a:	93 0b       	sbc	r25, r19
    1d8c:	90 93 8a 01 	sts	0x018A, r25
    1d90:	80 93 89 01 	sts	0x0189, r24
    1d94:	85 c0       	rjmp	.+266    	; 0x1ea0 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    1d96:	80 91 85 01 	lds	r24, 0x0185
    1d9a:	90 91 86 01 	lds	r25, 0x0186
    1d9e:	01 96       	adiw	r24, 0x01	; 1
    1da0:	90 93 86 01 	sts	0x0186, r25
    1da4:	80 93 85 01 	sts	0x0185, r24
		xPassedTicks--;
    1da8:	80 91 89 01 	lds	r24, 0x0189
    1dac:	90 91 8a 01 	lds	r25, 0x018A
    1db0:	01 97       	sbiw	r24, 0x01	; 1
    1db2:	90 93 8a 01 	sts	0x018A, r25
    1db6:	80 93 89 01 	sts	0x0189, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1dba:	80 91 85 01 	lds	r24, 0x0185
    1dbe:	90 91 86 01 	lds	r25, 0x0186
    1dc2:	00 97       	sbiw	r24, 0x00	; 0
    1dc4:	09 f0       	breq	.+2      	; 0x1dc8 <prvCheckDelayedList+0x58>
    1dc6:	64 c0       	rjmp	.+200    	; 0x1e90 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1dc8:	80 91 af 01 	lds	r24, 0x01AF
    1dcc:	90 91 b0 01 	lds	r25, 0x01B0
    1dd0:	9a 83       	std	Y+2, r25	; 0x02
    1dd2:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1dd4:	80 91 b1 01 	lds	r24, 0x01B1
    1dd8:	90 91 b2 01 	lds	r25, 0x01B2
    1ddc:	90 93 b0 01 	sts	0x01B0, r25
    1de0:	80 93 af 01 	sts	0x01AF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    1de4:	89 81       	ldd	r24, Y+1	; 0x01
    1de6:	9a 81       	ldd	r25, Y+2	; 0x02
    1de8:	90 93 b2 01 	sts	0x01B2, r25
    1dec:	80 93 b1 01 	sts	0x01B1, r24
    1df0:	4f c0       	rjmp	.+158    	; 0x1e90 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1df2:	e0 91 af 01 	lds	r30, 0x01AF
    1df6:	f0 91 b0 01 	lds	r31, 0x01B0
    1dfa:	05 80       	ldd	r0, Z+5	; 0x05
    1dfc:	f6 81       	ldd	r31, Z+6	; 0x06
    1dfe:	e0 2d       	mov	r30, r0
    1e00:	86 81       	ldd	r24, Z+6	; 0x06
    1e02:	97 81       	ldd	r25, Z+7	; 0x07
    1e04:	9c 83       	std	Y+4, r25	; 0x04
    1e06:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1e08:	eb 81       	ldd	r30, Y+3	; 0x03
    1e0a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e0c:	22 81       	ldd	r18, Z+2	; 0x02
    1e0e:	33 81       	ldd	r19, Z+3	; 0x03
    1e10:	80 91 85 01 	lds	r24, 0x0185
    1e14:	90 91 86 01 	lds	r25, 0x0186
    1e18:	82 17       	cp	r24, r18
    1e1a:	93 07       	cpc	r25, r19
    1e1c:	08 f4       	brcc	.+2      	; 0x1e20 <prvCheckDelayedList+0xb0>
    1e1e:	40 c0       	rjmp	.+128    	; 0x1ea0 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    1e20:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    1e22:	8b 81       	ldd	r24, Y+3	; 0x03
    1e24:	9c 81       	ldd	r25, Y+4	; 0x04
    1e26:	02 96       	adiw	r24, 0x02	; 2
    1e28:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    1e2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e30:	84 89       	ldd	r24, Z+20	; 0x14
    1e32:	95 89       	ldd	r25, Z+21	; 0x15
    1e34:	00 97       	sbiw	r24, 0x00	; 0
    1e36:	29 f0       	breq	.+10     	; 0x1e42 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    1e38:	8b 81       	ldd	r24, Y+3	; 0x03
    1e3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e3c:	0c 96       	adiw	r24, 0x0c	; 12
    1e3e:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1e42:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1e44:	eb 81       	ldd	r30, Y+3	; 0x03
    1e46:	fc 81       	ldd	r31, Y+4	; 0x04
    1e48:	96 89       	ldd	r25, Z+22	; 0x16
    1e4a:	80 91 84 01 	lds	r24, 0x0184
    1e4e:	89 17       	cp	r24, r25
    1e50:	28 f4       	brcc	.+10     	; 0x1e5c <prvCheckDelayedList+0xec>
    1e52:	eb 81       	ldd	r30, Y+3	; 0x03
    1e54:	fc 81       	ldd	r31, Y+4	; 0x04
    1e56:	86 89       	ldd	r24, Z+22	; 0x16
    1e58:	80 93 84 01 	sts	0x0184, r24
    1e5c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e5e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e60:	86 89       	ldd	r24, Z+22	; 0x16
    1e62:	28 2f       	mov	r18, r24
    1e64:	30 e0       	ldi	r19, 0x00	; 0
    1e66:	c9 01       	movw	r24, r18
    1e68:	88 0f       	add	r24, r24
    1e6a:	99 1f       	adc	r25, r25
    1e6c:	88 0f       	add	r24, r24
    1e6e:	99 1f       	adc	r25, r25
    1e70:	88 0f       	add	r24, r24
    1e72:	99 1f       	adc	r25, r25
    1e74:	82 0f       	add	r24, r18
    1e76:	93 1f       	adc	r25, r19
    1e78:	ac 01       	movw	r20, r24
    1e7a:	45 57       	subi	r20, 0x75	; 117
    1e7c:	5e 4f       	sbci	r21, 0xFE	; 254
    1e7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e80:	9c 81       	ldd	r25, Y+4	; 0x04
    1e82:	9c 01       	movw	r18, r24
    1e84:	2e 5f       	subi	r18, 0xFE	; 254
    1e86:	3f 4f       	sbci	r19, 0xFF	; 255
    1e88:	ca 01       	movw	r24, r20
    1e8a:	b9 01       	movw	r22, r18
    1e8c:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1e90:	e0 91 af 01 	lds	r30, 0x01AF
    1e94:	f0 91 b0 01 	lds	r31, 0x01B0
    1e98:	80 81       	ld	r24, Z
    1e9a:	88 23       	and	r24, r24
    1e9c:	09 f0       	breq	.+2      	; 0x1ea0 <prvCheckDelayedList+0x130>
    1e9e:	a9 cf       	rjmp	.-174    	; 0x1df2 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1ea0:	80 91 89 01 	lds	r24, 0x0189
    1ea4:	90 91 8a 01 	lds	r25, 0x018A
    1ea8:	00 97       	sbiw	r24, 0x00	; 0
    1eaa:	09 f0       	breq	.+2      	; 0x1eae <prvCheckDelayedList+0x13e>
    1eac:	74 cf       	rjmp	.-280    	; 0x1d96 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    1eae:	80 91 85 01 	lds	r24, 0x0185
    1eb2:	90 91 86 01 	lds	r25, 0x0186
    1eb6:	90 93 88 01 	sts	0x0188, r25
    1eba:	80 93 87 01 	sts	0x0187, r24
}
    1ebe:	0f 90       	pop	r0
    1ec0:	0f 90       	pop	r0
    1ec2:	0f 90       	pop	r0
    1ec4:	0f 90       	pop	r0
    1ec6:	cf 91       	pop	r28
    1ec8:	df 91       	pop	r29
    1eca:	08 95       	ret

00001ecc <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1ecc:	df 93       	push	r29
    1ece:	cf 93       	push	r28
    1ed0:	00 d0       	rcall	.+0      	; 0x1ed2 <vCoRoutineSchedule+0x6>
    1ed2:	cd b7       	in	r28, 0x3d	; 61
    1ed4:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    1ed6:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    1eda:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvCheckDelayedList>
    1ede:	0a c0       	rjmp	.+20     	; 0x1ef4 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1ee0:	80 91 84 01 	lds	r24, 0x0184
    1ee4:	88 23       	and	r24, r24
    1ee6:	09 f4       	brne	.+2      	; 0x1eea <vCoRoutineSchedule+0x1e>
    1ee8:	66 c0       	rjmp	.+204    	; 0x1fb6 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1eea:	80 91 84 01 	lds	r24, 0x0184
    1eee:	81 50       	subi	r24, 0x01	; 1
    1ef0:	80 93 84 01 	sts	0x0184, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1ef4:	80 91 84 01 	lds	r24, 0x0184
    1ef8:	28 2f       	mov	r18, r24
    1efa:	30 e0       	ldi	r19, 0x00	; 0
    1efc:	c9 01       	movw	r24, r18
    1efe:	88 0f       	add	r24, r24
    1f00:	99 1f       	adc	r25, r25
    1f02:	88 0f       	add	r24, r24
    1f04:	99 1f       	adc	r25, r25
    1f06:	88 0f       	add	r24, r24
    1f08:	99 1f       	adc	r25, r25
    1f0a:	82 0f       	add	r24, r18
    1f0c:	93 1f       	adc	r25, r19
    1f0e:	fc 01       	movw	r30, r24
    1f10:	e5 57       	subi	r30, 0x75	; 117
    1f12:	fe 4f       	sbci	r31, 0xFE	; 254
    1f14:	80 81       	ld	r24, Z
    1f16:	88 23       	and	r24, r24
    1f18:	19 f3       	breq	.-58     	; 0x1ee0 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1f1a:	80 91 84 01 	lds	r24, 0x0184
    1f1e:	28 2f       	mov	r18, r24
    1f20:	30 e0       	ldi	r19, 0x00	; 0
    1f22:	c9 01       	movw	r24, r18
    1f24:	88 0f       	add	r24, r24
    1f26:	99 1f       	adc	r25, r25
    1f28:	88 0f       	add	r24, r24
    1f2a:	99 1f       	adc	r25, r25
    1f2c:	88 0f       	add	r24, r24
    1f2e:	99 1f       	adc	r25, r25
    1f30:	82 0f       	add	r24, r18
    1f32:	93 1f       	adc	r25, r19
    1f34:	85 57       	subi	r24, 0x75	; 117
    1f36:	9e 4f       	sbci	r25, 0xFE	; 254
    1f38:	9a 83       	std	Y+2, r25	; 0x02
    1f3a:	89 83       	std	Y+1, r24	; 0x01
    1f3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f40:	01 80       	ldd	r0, Z+1	; 0x01
    1f42:	f2 81       	ldd	r31, Z+2	; 0x02
    1f44:	e0 2d       	mov	r30, r0
    1f46:	82 81       	ldd	r24, Z+2	; 0x02
    1f48:	93 81       	ldd	r25, Z+3	; 0x03
    1f4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f4e:	92 83       	std	Z+2, r25	; 0x02
    1f50:	81 83       	std	Z+1, r24	; 0x01
    1f52:	e9 81       	ldd	r30, Y+1	; 0x01
    1f54:	fa 81       	ldd	r31, Y+2	; 0x02
    1f56:	21 81       	ldd	r18, Z+1	; 0x01
    1f58:	32 81       	ldd	r19, Z+2	; 0x02
    1f5a:	89 81       	ldd	r24, Y+1	; 0x01
    1f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f5e:	03 96       	adiw	r24, 0x03	; 3
    1f60:	28 17       	cp	r18, r24
    1f62:	39 07       	cpc	r19, r25
    1f64:	59 f4       	brne	.+22     	; 0x1f7c <vCoRoutineSchedule+0xb0>
    1f66:	e9 81       	ldd	r30, Y+1	; 0x01
    1f68:	fa 81       	ldd	r31, Y+2	; 0x02
    1f6a:	01 80       	ldd	r0, Z+1	; 0x01
    1f6c:	f2 81       	ldd	r31, Z+2	; 0x02
    1f6e:	e0 2d       	mov	r30, r0
    1f70:	82 81       	ldd	r24, Z+2	; 0x02
    1f72:	93 81       	ldd	r25, Z+3	; 0x03
    1f74:	e9 81       	ldd	r30, Y+1	; 0x01
    1f76:	fa 81       	ldd	r31, Y+2	; 0x02
    1f78:	92 83       	std	Z+2, r25	; 0x02
    1f7a:	81 83       	std	Z+1, r24	; 0x01
    1f7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f80:	01 80       	ldd	r0, Z+1	; 0x01
    1f82:	f2 81       	ldd	r31, Z+2	; 0x02
    1f84:	e0 2d       	mov	r30, r0
    1f86:	86 81       	ldd	r24, Z+6	; 0x06
    1f88:	97 81       	ldd	r25, Z+7	; 0x07
    1f8a:	90 93 83 01 	sts	0x0183, r25
    1f8e:	80 93 82 01 	sts	0x0182, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1f92:	e0 91 82 01 	lds	r30, 0x0182
    1f96:	f0 91 83 01 	lds	r31, 0x0183
    1f9a:	40 81       	ld	r20, Z
    1f9c:	51 81       	ldd	r21, Z+1	; 0x01
    1f9e:	80 91 82 01 	lds	r24, 0x0182
    1fa2:	90 91 83 01 	lds	r25, 0x0183
    1fa6:	e0 91 82 01 	lds	r30, 0x0182
    1faa:	f0 91 83 01 	lds	r31, 0x0183
    1fae:	27 89       	ldd	r18, Z+23	; 0x17
    1fb0:	62 2f       	mov	r22, r18
    1fb2:	fa 01       	movw	r30, r20
    1fb4:	09 95       	icall

	return;
}
    1fb6:	0f 90       	pop	r0
    1fb8:	0f 90       	pop	r0
    1fba:	cf 91       	pop	r28
    1fbc:	df 91       	pop	r29
    1fbe:	08 95       	ret

00001fc0 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    1fc0:	df 93       	push	r29
    1fc2:	cf 93       	push	r28
    1fc4:	0f 92       	push	r0
    1fc6:	cd b7       	in	r28, 0x3d	; 61
    1fc8:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1fca:	19 82       	std	Y+1, r1	; 0x01
    1fcc:	13 c0       	rjmp	.+38     	; 0x1ff4 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1fce:	89 81       	ldd	r24, Y+1	; 0x01
    1fd0:	28 2f       	mov	r18, r24
    1fd2:	30 e0       	ldi	r19, 0x00	; 0
    1fd4:	c9 01       	movw	r24, r18
    1fd6:	88 0f       	add	r24, r24
    1fd8:	99 1f       	adc	r25, r25
    1fda:	88 0f       	add	r24, r24
    1fdc:	99 1f       	adc	r25, r25
    1fde:	88 0f       	add	r24, r24
    1fe0:	99 1f       	adc	r25, r25
    1fe2:	82 0f       	add	r24, r18
    1fe4:	93 1f       	adc	r25, r19
    1fe6:	85 57       	subi	r24, 0x75	; 117
    1fe8:	9e 4f       	sbci	r25, 0xFE	; 254
    1fea:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1fee:	89 81       	ldd	r24, Y+1	; 0x01
    1ff0:	8f 5f       	subi	r24, 0xFF	; 255
    1ff2:	89 83       	std	Y+1, r24	; 0x01
    1ff4:	89 81       	ldd	r24, Y+1	; 0x01
    1ff6:	82 30       	cpi	r24, 0x02	; 2
    1ff8:	50 f3       	brcs	.-44     	; 0x1fce <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1ffa:	8d e9       	ldi	r24, 0x9D	; 157
    1ffc:	91 e0       	ldi	r25, 0x01	; 1
    1ffe:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2002:	86 ea       	ldi	r24, 0xA6	; 166
    2004:	91 e0       	ldi	r25, 0x01	; 1
    2006:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    200a:	83 eb       	ldi	r24, 0xB3	; 179
    200c:	91 e0       	ldi	r25, 0x01	; 1
    200e:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2012:	8d e9       	ldi	r24, 0x9D	; 157
    2014:	91 e0       	ldi	r25, 0x01	; 1
    2016:	90 93 b0 01 	sts	0x01B0, r25
    201a:	80 93 af 01 	sts	0x01AF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    201e:	86 ea       	ldi	r24, 0xA6	; 166
    2020:	91 e0       	ldi	r25, 0x01	; 1
    2022:	90 93 b2 01 	sts	0x01B2, r25
    2026:	80 93 b1 01 	sts	0x01B1, r24
}
    202a:	0f 90       	pop	r0
    202c:	cf 91       	pop	r28
    202e:	df 91       	pop	r29
    2030:	08 95       	ret

00002032 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2032:	df 93       	push	r29
    2034:	cf 93       	push	r28
    2036:	00 d0       	rcall	.+0      	; 0x2038 <xCoRoutineRemoveFromEventList+0x6>
    2038:	00 d0       	rcall	.+0      	; 0x203a <xCoRoutineRemoveFromEventList+0x8>
    203a:	0f 92       	push	r0
    203c:	cd b7       	in	r28, 0x3d	; 61
    203e:	de b7       	in	r29, 0x3e	; 62
    2040:	9d 83       	std	Y+5, r25	; 0x05
    2042:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2044:	ec 81       	ldd	r30, Y+4	; 0x04
    2046:	fd 81       	ldd	r31, Y+5	; 0x05
    2048:	05 80       	ldd	r0, Z+5	; 0x05
    204a:	f6 81       	ldd	r31, Z+6	; 0x06
    204c:	e0 2d       	mov	r30, r0
    204e:	86 81       	ldd	r24, Z+6	; 0x06
    2050:	97 81       	ldd	r25, Z+7	; 0x07
    2052:	9b 83       	std	Y+3, r25	; 0x03
    2054:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2056:	8a 81       	ldd	r24, Y+2	; 0x02
    2058:	9b 81       	ldd	r25, Y+3	; 0x03
    205a:	0c 96       	adiw	r24, 0x0c	; 12
    205c:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2060:	8a 81       	ldd	r24, Y+2	; 0x02
    2062:	9b 81       	ldd	r25, Y+3	; 0x03
    2064:	9c 01       	movw	r18, r24
    2066:	24 5f       	subi	r18, 0xF4	; 244
    2068:	3f 4f       	sbci	r19, 0xFF	; 255
    206a:	83 eb       	ldi	r24, 0xB3	; 179
    206c:	91 e0       	ldi	r25, 0x01	; 1
    206e:	b9 01       	movw	r22, r18
    2070:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2074:	ea 81       	ldd	r30, Y+2	; 0x02
    2076:	fb 81       	ldd	r31, Y+3	; 0x03
    2078:	96 89       	ldd	r25, Z+22	; 0x16
    207a:	e0 91 82 01 	lds	r30, 0x0182
    207e:	f0 91 83 01 	lds	r31, 0x0183
    2082:	86 89       	ldd	r24, Z+22	; 0x16
    2084:	98 17       	cp	r25, r24
    2086:	18 f0       	brcs	.+6      	; 0x208e <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2088:	81 e0       	ldi	r24, 0x01	; 1
    208a:	89 83       	std	Y+1, r24	; 0x01
    208c:	01 c0       	rjmp	.+2      	; 0x2090 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    208e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2090:	89 81       	ldd	r24, Y+1	; 0x01
}
    2092:	0f 90       	pop	r0
    2094:	0f 90       	pop	r0
    2096:	0f 90       	pop	r0
    2098:	0f 90       	pop	r0
    209a:	0f 90       	pop	r0
    209c:	cf 91       	pop	r28
    209e:	df 91       	pop	r29
    20a0:	08 95       	ret

000020a2 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    20a2:	df 93       	push	r29
    20a4:	cf 93       	push	r28
    20a6:	00 d0       	rcall	.+0      	; 0x20a8 <pvPortMalloc+0x6>
    20a8:	00 d0       	rcall	.+0      	; 0x20aa <pvPortMalloc+0x8>
    20aa:	cd b7       	in	r28, 0x3d	; 61
    20ac:	de b7       	in	r29, 0x3e	; 62
    20ae:	9c 83       	std	Y+4, r25	; 0x04
    20b0:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    20b2:	1a 82       	std	Y+2, r1	; 0x02
    20b4:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    20b6:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    20ba:	80 91 bc 01 	lds	r24, 0x01BC
    20be:	90 91 bd 01 	lds	r25, 0x01BD
    20c2:	2b 81       	ldd	r18, Y+3	; 0x03
    20c4:	3c 81       	ldd	r19, Y+4	; 0x04
    20c6:	82 0f       	add	r24, r18
    20c8:	93 1f       	adc	r25, r19
    20ca:	23 e0       	ldi	r18, 0x03	; 3
    20cc:	88 3e       	cpi	r24, 0xE8	; 232
    20ce:	92 07       	cpc	r25, r18
    20d0:	18 f5       	brcc	.+70     	; 0x2118 <pvPortMalloc+0x76>
    20d2:	20 91 bc 01 	lds	r18, 0x01BC
    20d6:	30 91 bd 01 	lds	r19, 0x01BD
    20da:	8b 81       	ldd	r24, Y+3	; 0x03
    20dc:	9c 81       	ldd	r25, Y+4	; 0x04
    20de:	28 0f       	add	r18, r24
    20e0:	39 1f       	adc	r19, r25
    20e2:	80 91 bc 01 	lds	r24, 0x01BC
    20e6:	90 91 bd 01 	lds	r25, 0x01BD
    20ea:	82 17       	cp	r24, r18
    20ec:	93 07       	cpc	r25, r19
    20ee:	a0 f4       	brcc	.+40     	; 0x2118 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    20f0:	80 91 bc 01 	lds	r24, 0x01BC
    20f4:	90 91 bd 01 	lds	r25, 0x01BD
    20f8:	82 54       	subi	r24, 0x42	; 66
    20fa:	9e 4f       	sbci	r25, 0xFE	; 254
    20fc:	9a 83       	std	Y+2, r25	; 0x02
    20fe:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    2100:	20 91 bc 01 	lds	r18, 0x01BC
    2104:	30 91 bd 01 	lds	r19, 0x01BD
    2108:	8b 81       	ldd	r24, Y+3	; 0x03
    210a:	9c 81       	ldd	r25, Y+4	; 0x04
    210c:	82 0f       	add	r24, r18
    210e:	93 1f       	adc	r25, r19
    2110:	90 93 bd 01 	sts	0x01BD, r25
    2114:	80 93 bc 01 	sts	0x01BC, r24
		}	
	}
	xTaskResumeAll();
    2118:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    211c:	89 81       	ldd	r24, Y+1	; 0x01
    211e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2120:	0f 90       	pop	r0
    2122:	0f 90       	pop	r0
    2124:	0f 90       	pop	r0
    2126:	0f 90       	pop	r0
    2128:	cf 91       	pop	r28
    212a:	df 91       	pop	r29
    212c:	08 95       	ret

0000212e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    212e:	df 93       	push	r29
    2130:	cf 93       	push	r28
    2132:	00 d0       	rcall	.+0      	; 0x2134 <vPortFree+0x6>
    2134:	cd b7       	in	r28, 0x3d	; 61
    2136:	de b7       	in	r29, 0x3e	; 62
    2138:	9a 83       	std	Y+2, r25	; 0x02
    213a:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    213c:	0f 90       	pop	r0
    213e:	0f 90       	pop	r0
    2140:	cf 91       	pop	r28
    2142:	df 91       	pop	r29
    2144:	08 95       	ret

00002146 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2146:	df 93       	push	r29
    2148:	cf 93       	push	r28
    214a:	cd b7       	in	r28, 0x3d	; 61
    214c:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    214e:	10 92 bd 01 	sts	0x01BD, r1
    2152:	10 92 bc 01 	sts	0x01BC, r1
}
    2156:	cf 91       	pop	r28
    2158:	df 91       	pop	r29
    215a:	08 95       	ret

0000215c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    215c:	df 93       	push	r29
    215e:	cf 93       	push	r28
    2160:	cd b7       	in	r28, 0x3d	; 61
    2162:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2164:	20 91 bc 01 	lds	r18, 0x01BC
    2168:	30 91 bd 01 	lds	r19, 0x01BD
    216c:	88 ee       	ldi	r24, 0xE8	; 232
    216e:	93 e0       	ldi	r25, 0x03	; 3
    2170:	82 1b       	sub	r24, r18
    2172:	93 0b       	sbc	r25, r19
}
    2174:	cf 91       	pop	r28
    2176:	df 91       	pop	r29
    2178:	08 95       	ret

0000217a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    217a:	df 93       	push	r29
    217c:	cf 93       	push	r28
    217e:	00 d0       	rcall	.+0      	; 0x2180 <vListInitialise+0x6>
    2180:	cd b7       	in	r28, 0x3d	; 61
    2182:	de b7       	in	r29, 0x3e	; 62
    2184:	9a 83       	std	Y+2, r25	; 0x02
    2186:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2188:	89 81       	ldd	r24, Y+1	; 0x01
    218a:	9a 81       	ldd	r25, Y+2	; 0x02
    218c:	03 96       	adiw	r24, 0x03	; 3
    218e:	e9 81       	ldd	r30, Y+1	; 0x01
    2190:	fa 81       	ldd	r31, Y+2	; 0x02
    2192:	92 83       	std	Z+2, r25	; 0x02
    2194:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2196:	e9 81       	ldd	r30, Y+1	; 0x01
    2198:	fa 81       	ldd	r31, Y+2	; 0x02
    219a:	8f ef       	ldi	r24, 0xFF	; 255
    219c:	9f ef       	ldi	r25, 0xFF	; 255
    219e:	94 83       	std	Z+4, r25	; 0x04
    21a0:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    21a2:	89 81       	ldd	r24, Y+1	; 0x01
    21a4:	9a 81       	ldd	r25, Y+2	; 0x02
    21a6:	03 96       	adiw	r24, 0x03	; 3
    21a8:	e9 81       	ldd	r30, Y+1	; 0x01
    21aa:	fa 81       	ldd	r31, Y+2	; 0x02
    21ac:	96 83       	std	Z+6, r25	; 0x06
    21ae:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    21b0:	89 81       	ldd	r24, Y+1	; 0x01
    21b2:	9a 81       	ldd	r25, Y+2	; 0x02
    21b4:	03 96       	adiw	r24, 0x03	; 3
    21b6:	e9 81       	ldd	r30, Y+1	; 0x01
    21b8:	fa 81       	ldd	r31, Y+2	; 0x02
    21ba:	90 87       	std	Z+8, r25	; 0x08
    21bc:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    21be:	e9 81       	ldd	r30, Y+1	; 0x01
    21c0:	fa 81       	ldd	r31, Y+2	; 0x02
    21c2:	10 82       	st	Z, r1
}
    21c4:	0f 90       	pop	r0
    21c6:	0f 90       	pop	r0
    21c8:	cf 91       	pop	r28
    21ca:	df 91       	pop	r29
    21cc:	08 95       	ret

000021ce <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    21ce:	df 93       	push	r29
    21d0:	cf 93       	push	r28
    21d2:	00 d0       	rcall	.+0      	; 0x21d4 <vListInitialiseItem+0x6>
    21d4:	cd b7       	in	r28, 0x3d	; 61
    21d6:	de b7       	in	r29, 0x3e	; 62
    21d8:	9a 83       	std	Y+2, r25	; 0x02
    21da:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    21dc:	e9 81       	ldd	r30, Y+1	; 0x01
    21de:	fa 81       	ldd	r31, Y+2	; 0x02
    21e0:	11 86       	std	Z+9, r1	; 0x09
    21e2:	10 86       	std	Z+8, r1	; 0x08
}
    21e4:	0f 90       	pop	r0
    21e6:	0f 90       	pop	r0
    21e8:	cf 91       	pop	r28
    21ea:	df 91       	pop	r29
    21ec:	08 95       	ret

000021ee <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    21ee:	df 93       	push	r29
    21f0:	cf 93       	push	r28
    21f2:	00 d0       	rcall	.+0      	; 0x21f4 <vListInsertEnd+0x6>
    21f4:	00 d0       	rcall	.+0      	; 0x21f6 <vListInsertEnd+0x8>
    21f6:	00 d0       	rcall	.+0      	; 0x21f8 <vListInsertEnd+0xa>
    21f8:	cd b7       	in	r28, 0x3d	; 61
    21fa:	de b7       	in	r29, 0x3e	; 62
    21fc:	9c 83       	std	Y+4, r25	; 0x04
    21fe:	8b 83       	std	Y+3, r24	; 0x03
    2200:	7e 83       	std	Y+6, r23	; 0x06
    2202:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2204:	eb 81       	ldd	r30, Y+3	; 0x03
    2206:	fc 81       	ldd	r31, Y+4	; 0x04
    2208:	81 81       	ldd	r24, Z+1	; 0x01
    220a:	92 81       	ldd	r25, Z+2	; 0x02
    220c:	9a 83       	std	Y+2, r25	; 0x02
    220e:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    2210:	e9 81       	ldd	r30, Y+1	; 0x01
    2212:	fa 81       	ldd	r31, Y+2	; 0x02
    2214:	82 81       	ldd	r24, Z+2	; 0x02
    2216:	93 81       	ldd	r25, Z+3	; 0x03
    2218:	ed 81       	ldd	r30, Y+5	; 0x05
    221a:	fe 81       	ldd	r31, Y+6	; 0x06
    221c:	93 83       	std	Z+3, r25	; 0x03
    221e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2220:	eb 81       	ldd	r30, Y+3	; 0x03
    2222:	fc 81       	ldd	r31, Y+4	; 0x04
    2224:	81 81       	ldd	r24, Z+1	; 0x01
    2226:	92 81       	ldd	r25, Z+2	; 0x02
    2228:	ed 81       	ldd	r30, Y+5	; 0x05
    222a:	fe 81       	ldd	r31, Y+6	; 0x06
    222c:	95 83       	std	Z+5, r25	; 0x05
    222e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2230:	e9 81       	ldd	r30, Y+1	; 0x01
    2232:	fa 81       	ldd	r31, Y+2	; 0x02
    2234:	02 80       	ldd	r0, Z+2	; 0x02
    2236:	f3 81       	ldd	r31, Z+3	; 0x03
    2238:	e0 2d       	mov	r30, r0
    223a:	8d 81       	ldd	r24, Y+5	; 0x05
    223c:	9e 81       	ldd	r25, Y+6	; 0x06
    223e:	95 83       	std	Z+5, r25	; 0x05
    2240:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2242:	8d 81       	ldd	r24, Y+5	; 0x05
    2244:	9e 81       	ldd	r25, Y+6	; 0x06
    2246:	e9 81       	ldd	r30, Y+1	; 0x01
    2248:	fa 81       	ldd	r31, Y+2	; 0x02
    224a:	93 83       	std	Z+3, r25	; 0x03
    224c:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    224e:	8d 81       	ldd	r24, Y+5	; 0x05
    2250:	9e 81       	ldd	r25, Y+6	; 0x06
    2252:	eb 81       	ldd	r30, Y+3	; 0x03
    2254:	fc 81       	ldd	r31, Y+4	; 0x04
    2256:	92 83       	std	Z+2, r25	; 0x02
    2258:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    225a:	ed 81       	ldd	r30, Y+5	; 0x05
    225c:	fe 81       	ldd	r31, Y+6	; 0x06
    225e:	8b 81       	ldd	r24, Y+3	; 0x03
    2260:	9c 81       	ldd	r25, Y+4	; 0x04
    2262:	91 87       	std	Z+9, r25	; 0x09
    2264:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2266:	eb 81       	ldd	r30, Y+3	; 0x03
    2268:	fc 81       	ldd	r31, Y+4	; 0x04
    226a:	80 81       	ld	r24, Z
    226c:	8f 5f       	subi	r24, 0xFF	; 255
    226e:	eb 81       	ldd	r30, Y+3	; 0x03
    2270:	fc 81       	ldd	r31, Y+4	; 0x04
    2272:	80 83       	st	Z, r24
}
    2274:	26 96       	adiw	r28, 0x06	; 6
    2276:	0f b6       	in	r0, 0x3f	; 63
    2278:	f8 94       	cli
    227a:	de bf       	out	0x3e, r29	; 62
    227c:	0f be       	out	0x3f, r0	; 63
    227e:	cd bf       	out	0x3d, r28	; 61
    2280:	cf 91       	pop	r28
    2282:	df 91       	pop	r29
    2284:	08 95       	ret

00002286 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2286:	df 93       	push	r29
    2288:	cf 93       	push	r28
    228a:	cd b7       	in	r28, 0x3d	; 61
    228c:	de b7       	in	r29, 0x3e	; 62
    228e:	28 97       	sbiw	r28, 0x08	; 8
    2290:	0f b6       	in	r0, 0x3f	; 63
    2292:	f8 94       	cli
    2294:	de bf       	out	0x3e, r29	; 62
    2296:	0f be       	out	0x3f, r0	; 63
    2298:	cd bf       	out	0x3d, r28	; 61
    229a:	9e 83       	std	Y+6, r25	; 0x06
    229c:	8d 83       	std	Y+5, r24	; 0x05
    229e:	78 87       	std	Y+8, r23	; 0x08
    22a0:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    22a2:	ef 81       	ldd	r30, Y+7	; 0x07
    22a4:	f8 85       	ldd	r31, Y+8	; 0x08
    22a6:	80 81       	ld	r24, Z
    22a8:	91 81       	ldd	r25, Z+1	; 0x01
    22aa:	9a 83       	std	Y+2, r25	; 0x02
    22ac:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    22ae:	89 81       	ldd	r24, Y+1	; 0x01
    22b0:	9a 81       	ldd	r25, Y+2	; 0x02
    22b2:	2f ef       	ldi	r18, 0xFF	; 255
    22b4:	8f 3f       	cpi	r24, 0xFF	; 255
    22b6:	92 07       	cpc	r25, r18
    22b8:	39 f4       	brne	.+14     	; 0x22c8 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    22ba:	ed 81       	ldd	r30, Y+5	; 0x05
    22bc:	fe 81       	ldd	r31, Y+6	; 0x06
    22be:	87 81       	ldd	r24, Z+7	; 0x07
    22c0:	90 85       	ldd	r25, Z+8	; 0x08
    22c2:	9c 83       	std	Y+4, r25	; 0x04
    22c4:	8b 83       	std	Y+3, r24	; 0x03
    22c6:	18 c0       	rjmp	.+48     	; 0x22f8 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    22c8:	8d 81       	ldd	r24, Y+5	; 0x05
    22ca:	9e 81       	ldd	r25, Y+6	; 0x06
    22cc:	03 96       	adiw	r24, 0x03	; 3
    22ce:	9c 83       	std	Y+4, r25	; 0x04
    22d0:	8b 83       	std	Y+3, r24	; 0x03
    22d2:	06 c0       	rjmp	.+12     	; 0x22e0 <vListInsert+0x5a>
    22d4:	eb 81       	ldd	r30, Y+3	; 0x03
    22d6:	fc 81       	ldd	r31, Y+4	; 0x04
    22d8:	82 81       	ldd	r24, Z+2	; 0x02
    22da:	93 81       	ldd	r25, Z+3	; 0x03
    22dc:	9c 83       	std	Y+4, r25	; 0x04
    22de:	8b 83       	std	Y+3, r24	; 0x03
    22e0:	eb 81       	ldd	r30, Y+3	; 0x03
    22e2:	fc 81       	ldd	r31, Y+4	; 0x04
    22e4:	02 80       	ldd	r0, Z+2	; 0x02
    22e6:	f3 81       	ldd	r31, Z+3	; 0x03
    22e8:	e0 2d       	mov	r30, r0
    22ea:	20 81       	ld	r18, Z
    22ec:	31 81       	ldd	r19, Z+1	; 0x01
    22ee:	89 81       	ldd	r24, Y+1	; 0x01
    22f0:	9a 81       	ldd	r25, Y+2	; 0x02
    22f2:	82 17       	cp	r24, r18
    22f4:	93 07       	cpc	r25, r19
    22f6:	70 f7       	brcc	.-36     	; 0x22d4 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    22f8:	eb 81       	ldd	r30, Y+3	; 0x03
    22fa:	fc 81       	ldd	r31, Y+4	; 0x04
    22fc:	82 81       	ldd	r24, Z+2	; 0x02
    22fe:	93 81       	ldd	r25, Z+3	; 0x03
    2300:	ef 81       	ldd	r30, Y+7	; 0x07
    2302:	f8 85       	ldd	r31, Y+8	; 0x08
    2304:	93 83       	std	Z+3, r25	; 0x03
    2306:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2308:	ef 81       	ldd	r30, Y+7	; 0x07
    230a:	f8 85       	ldd	r31, Y+8	; 0x08
    230c:	02 80       	ldd	r0, Z+2	; 0x02
    230e:	f3 81       	ldd	r31, Z+3	; 0x03
    2310:	e0 2d       	mov	r30, r0
    2312:	8f 81       	ldd	r24, Y+7	; 0x07
    2314:	98 85       	ldd	r25, Y+8	; 0x08
    2316:	95 83       	std	Z+5, r25	; 0x05
    2318:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    231a:	ef 81       	ldd	r30, Y+7	; 0x07
    231c:	f8 85       	ldd	r31, Y+8	; 0x08
    231e:	8b 81       	ldd	r24, Y+3	; 0x03
    2320:	9c 81       	ldd	r25, Y+4	; 0x04
    2322:	95 83       	std	Z+5, r25	; 0x05
    2324:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2326:	8f 81       	ldd	r24, Y+7	; 0x07
    2328:	98 85       	ldd	r25, Y+8	; 0x08
    232a:	eb 81       	ldd	r30, Y+3	; 0x03
    232c:	fc 81       	ldd	r31, Y+4	; 0x04
    232e:	93 83       	std	Z+3, r25	; 0x03
    2330:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2332:	ef 81       	ldd	r30, Y+7	; 0x07
    2334:	f8 85       	ldd	r31, Y+8	; 0x08
    2336:	8d 81       	ldd	r24, Y+5	; 0x05
    2338:	9e 81       	ldd	r25, Y+6	; 0x06
    233a:	91 87       	std	Z+9, r25	; 0x09
    233c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    233e:	ed 81       	ldd	r30, Y+5	; 0x05
    2340:	fe 81       	ldd	r31, Y+6	; 0x06
    2342:	80 81       	ld	r24, Z
    2344:	8f 5f       	subi	r24, 0xFF	; 255
    2346:	ed 81       	ldd	r30, Y+5	; 0x05
    2348:	fe 81       	ldd	r31, Y+6	; 0x06
    234a:	80 83       	st	Z, r24
}
    234c:	28 96       	adiw	r28, 0x08	; 8
    234e:	0f b6       	in	r0, 0x3f	; 63
    2350:	f8 94       	cli
    2352:	de bf       	out	0x3e, r29	; 62
    2354:	0f be       	out	0x3f, r0	; 63
    2356:	cd bf       	out	0x3d, r28	; 61
    2358:	cf 91       	pop	r28
    235a:	df 91       	pop	r29
    235c:	08 95       	ret

0000235e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    235e:	df 93       	push	r29
    2360:	cf 93       	push	r28
    2362:	00 d0       	rcall	.+0      	; 0x2364 <vListRemove+0x6>
    2364:	00 d0       	rcall	.+0      	; 0x2366 <vListRemove+0x8>
    2366:	cd b7       	in	r28, 0x3d	; 61
    2368:	de b7       	in	r29, 0x3e	; 62
    236a:	9c 83       	std	Y+4, r25	; 0x04
    236c:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    236e:	eb 81       	ldd	r30, Y+3	; 0x03
    2370:	fc 81       	ldd	r31, Y+4	; 0x04
    2372:	a2 81       	ldd	r26, Z+2	; 0x02
    2374:	b3 81       	ldd	r27, Z+3	; 0x03
    2376:	eb 81       	ldd	r30, Y+3	; 0x03
    2378:	fc 81       	ldd	r31, Y+4	; 0x04
    237a:	84 81       	ldd	r24, Z+4	; 0x04
    237c:	95 81       	ldd	r25, Z+5	; 0x05
    237e:	15 96       	adiw	r26, 0x05	; 5
    2380:	9c 93       	st	X, r25
    2382:	8e 93       	st	-X, r24
    2384:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2386:	eb 81       	ldd	r30, Y+3	; 0x03
    2388:	fc 81       	ldd	r31, Y+4	; 0x04
    238a:	a4 81       	ldd	r26, Z+4	; 0x04
    238c:	b5 81       	ldd	r27, Z+5	; 0x05
    238e:	eb 81       	ldd	r30, Y+3	; 0x03
    2390:	fc 81       	ldd	r31, Y+4	; 0x04
    2392:	82 81       	ldd	r24, Z+2	; 0x02
    2394:	93 81       	ldd	r25, Z+3	; 0x03
    2396:	13 96       	adiw	r26, 0x03	; 3
    2398:	9c 93       	st	X, r25
    239a:	8e 93       	st	-X, r24
    239c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    239e:	eb 81       	ldd	r30, Y+3	; 0x03
    23a0:	fc 81       	ldd	r31, Y+4	; 0x04
    23a2:	80 85       	ldd	r24, Z+8	; 0x08
    23a4:	91 85       	ldd	r25, Z+9	; 0x09
    23a6:	9a 83       	std	Y+2, r25	; 0x02
    23a8:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    23aa:	e9 81       	ldd	r30, Y+1	; 0x01
    23ac:	fa 81       	ldd	r31, Y+2	; 0x02
    23ae:	21 81       	ldd	r18, Z+1	; 0x01
    23b0:	32 81       	ldd	r19, Z+2	; 0x02
    23b2:	8b 81       	ldd	r24, Y+3	; 0x03
    23b4:	9c 81       	ldd	r25, Y+4	; 0x04
    23b6:	28 17       	cp	r18, r24
    23b8:	39 07       	cpc	r19, r25
    23ba:	41 f4       	brne	.+16     	; 0x23cc <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    23bc:	eb 81       	ldd	r30, Y+3	; 0x03
    23be:	fc 81       	ldd	r31, Y+4	; 0x04
    23c0:	84 81       	ldd	r24, Z+4	; 0x04
    23c2:	95 81       	ldd	r25, Z+5	; 0x05
    23c4:	e9 81       	ldd	r30, Y+1	; 0x01
    23c6:	fa 81       	ldd	r31, Y+2	; 0x02
    23c8:	92 83       	std	Z+2, r25	; 0x02
    23ca:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    23cc:	eb 81       	ldd	r30, Y+3	; 0x03
    23ce:	fc 81       	ldd	r31, Y+4	; 0x04
    23d0:	11 86       	std	Z+9, r1	; 0x09
    23d2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    23d4:	e9 81       	ldd	r30, Y+1	; 0x01
    23d6:	fa 81       	ldd	r31, Y+2	; 0x02
    23d8:	80 81       	ld	r24, Z
    23da:	81 50       	subi	r24, 0x01	; 1
    23dc:	e9 81       	ldd	r30, Y+1	; 0x01
    23de:	fa 81       	ldd	r31, Y+2	; 0x02
    23e0:	80 83       	st	Z, r24
}
    23e2:	0f 90       	pop	r0
    23e4:	0f 90       	pop	r0
    23e6:	0f 90       	pop	r0
    23e8:	0f 90       	pop	r0
    23ea:	cf 91       	pop	r28
    23ec:	df 91       	pop	r29
    23ee:	08 95       	ret

000023f0 <main>:
void LCD1(void *pv);
void LCD2(void *pv);


void main (void)
{
    23f0:	af 92       	push	r10
    23f2:	bf 92       	push	r11
    23f4:	cf 92       	push	r12
    23f6:	df 92       	push	r13
    23f8:	ef 92       	push	r14
    23fa:	ff 92       	push	r15
    23fc:	0f 93       	push	r16
    23fe:	df 93       	push	r29
    2400:	cf 93       	push	r28
    2402:	cd b7       	in	r28, 0x3d	; 61
    2404:	de b7       	in	r29, 0x3e	; 62
	PORT_voidInit();
    2406:	0e 94 58 0d 	call	0x1ab0	; 0x1ab0 <PORT_voidInit>
	LCD_voidInit();
    240a:	0e 94 b5 0b 	call	0x176a	; 0x176a <LCD_voidInit>

	xTaskCreate(&LCD1,NULL,250,NULL,0,NULL);
    240e:	8c e2       	ldi	r24, 0x2C	; 44
    2410:	92 e1       	ldi	r25, 0x12	; 18
    2412:	60 e0       	ldi	r22, 0x00	; 0
    2414:	70 e0       	ldi	r23, 0x00	; 0
    2416:	4a ef       	ldi	r20, 0xFA	; 250
    2418:	50 e0       	ldi	r21, 0x00	; 0
    241a:	20 e0       	ldi	r18, 0x00	; 0
    241c:	30 e0       	ldi	r19, 0x00	; 0
    241e:	00 e0       	ldi	r16, 0x00	; 0
    2420:	ee 24       	eor	r14, r14
    2422:	ff 24       	eor	r15, r15
    2424:	cc 24       	eor	r12, r12
    2426:	dd 24       	eor	r13, r13
    2428:	aa 24       	eor	r10, r10
    242a:	bb 24       	eor	r11, r11
    242c:	0e 94 9f 19 	call	0x333e	; 0x333e <xTaskGenericCreate>
	xTaskCreate(&LCD2,NULL,250,NULL,0,NULL);
    2430:	8c e3       	ldi	r24, 0x3C	; 60
    2432:	92 e1       	ldi	r25, 0x12	; 18
    2434:	60 e0       	ldi	r22, 0x00	; 0
    2436:	70 e0       	ldi	r23, 0x00	; 0
    2438:	4a ef       	ldi	r20, 0xFA	; 250
    243a:	50 e0       	ldi	r21, 0x00	; 0
    243c:	20 e0       	ldi	r18, 0x00	; 0
    243e:	30 e0       	ldi	r19, 0x00	; 0
    2440:	00 e0       	ldi	r16, 0x00	; 0
    2442:	ee 24       	eor	r14, r14
    2444:	ff 24       	eor	r15, r15
    2446:	cc 24       	eor	r12, r12
    2448:	dd 24       	eor	r13, r13
    244a:	aa 24       	eor	r10, r10
    244c:	bb 24       	eor	r11, r11
    244e:	0e 94 9f 19 	call	0x333e	; 0x333e <xTaskGenericCreate>
	vTaskStartScheduler();
    2452:	0e 94 98 1b 	call	0x3730	; 0x3730 <vTaskStartScheduler>
    2456:	ff cf       	rjmp	.-2      	; 0x2456 <main+0x66>

00002458 <LCD1>:

	}
}

void LCD1(void *pv)
{
    2458:	df 93       	push	r29
    245a:	cf 93       	push	r28
    245c:	00 d0       	rcall	.+0      	; 0x245e <LCD1+0x6>
    245e:	cd b7       	in	r28, 0x3d	; 61
    2460:	de b7       	in	r29, 0x3e	; 62
    2462:	9a 83       	std	Y+2, r25	; 0x02
    2464:	89 83       	std	Y+1, r24	; 0x01
	while (1)
	{
		LCD_voidSendString("IAMTASK1");
    2466:	80 e6       	ldi	r24, 0x60	; 96
    2468:	90 e0       	ldi	r25, 0x00	; 0
    246a:	0e 94 43 0c 	call	0x1886	; 0x1886 <LCD_voidSendString>
		vTaskDelay(1000);
    246e:	88 ee       	ldi	r24, 0xE8	; 232
    2470:	93 e0       	ldi	r25, 0x03	; 3
    2472:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <vTaskDelay>
    2476:	f7 cf       	rjmp	.-18     	; 0x2466 <LCD1+0xe>

00002478 <LCD2>:
	}

}
void LCD2(void *pv)
{
    2478:	df 93       	push	r29
    247a:	cf 93       	push	r28
    247c:	00 d0       	rcall	.+0      	; 0x247e <LCD2+0x6>
    247e:	cd b7       	in	r28, 0x3d	; 61
    2480:	de b7       	in	r29, 0x3e	; 62
    2482:	9a 83       	std	Y+2, r25	; 0x02
    2484:	89 83       	std	Y+1, r24	; 0x01
	while (1)
	{
		LCD_voidSendString("IAMTASK2");
    2486:	89 e6       	ldi	r24, 0x69	; 105
    2488:	90 e0       	ldi	r25, 0x00	; 0
    248a:	0e 94 43 0c 	call	0x1886	; 0x1886 <LCD_voidSendString>
		vTaskDelay(1000);
    248e:	88 ee       	ldi	r24, 0xE8	; 232
    2490:	93 e0       	ldi	r25, 0x03	; 3
    2492:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <vTaskDelay>
    2496:	f7 cf       	rjmp	.-18     	; 0x2486 <LCD2+0xe>

00002498 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2498:	df 93       	push	r29
    249a:	cf 93       	push	r28
    249c:	cd b7       	in	r28, 0x3d	; 61
    249e:	de b7       	in	r29, 0x3e	; 62
    24a0:	28 97       	sbiw	r28, 0x08	; 8
    24a2:	0f b6       	in	r0, 0x3f	; 63
    24a4:	f8 94       	cli
    24a6:	de bf       	out	0x3e, r29	; 62
    24a8:	0f be       	out	0x3f, r0	; 63
    24aa:	cd bf       	out	0x3d, r28	; 61
    24ac:	9c 83       	std	Y+4, r25	; 0x04
    24ae:	8b 83       	std	Y+3, r24	; 0x03
    24b0:	7e 83       	std	Y+6, r23	; 0x06
    24b2:	6d 83       	std	Y+5, r22	; 0x05
    24b4:	58 87       	std	Y+8, r21	; 0x08
    24b6:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    24b8:	eb 81       	ldd	r30, Y+3	; 0x03
    24ba:	fc 81       	ldd	r31, Y+4	; 0x04
    24bc:	81 e1       	ldi	r24, 0x11	; 17
    24be:	80 83       	st	Z, r24
	pxTopOfStack--;
    24c0:	8b 81       	ldd	r24, Y+3	; 0x03
    24c2:	9c 81       	ldd	r25, Y+4	; 0x04
    24c4:	01 97       	sbiw	r24, 0x01	; 1
    24c6:	9c 83       	std	Y+4, r25	; 0x04
    24c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    24ca:	eb 81       	ldd	r30, Y+3	; 0x03
    24cc:	fc 81       	ldd	r31, Y+4	; 0x04
    24ce:	82 e2       	ldi	r24, 0x22	; 34
    24d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    24d2:	8b 81       	ldd	r24, Y+3	; 0x03
    24d4:	9c 81       	ldd	r25, Y+4	; 0x04
    24d6:	01 97       	sbiw	r24, 0x01	; 1
    24d8:	9c 83       	std	Y+4, r25	; 0x04
    24da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    24dc:	eb 81       	ldd	r30, Y+3	; 0x03
    24de:	fc 81       	ldd	r31, Y+4	; 0x04
    24e0:	83 e3       	ldi	r24, 0x33	; 51
    24e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    24e4:	8b 81       	ldd	r24, Y+3	; 0x03
    24e6:	9c 81       	ldd	r25, Y+4	; 0x04
    24e8:	01 97       	sbiw	r24, 0x01	; 1
    24ea:	9c 83       	std	Y+4, r25	; 0x04
    24ec:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    24ee:	8d 81       	ldd	r24, Y+5	; 0x05
    24f0:	9e 81       	ldd	r25, Y+6	; 0x06
    24f2:	9a 83       	std	Y+2, r25	; 0x02
    24f4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    24f6:	89 81       	ldd	r24, Y+1	; 0x01
    24f8:	eb 81       	ldd	r30, Y+3	; 0x03
    24fa:	fc 81       	ldd	r31, Y+4	; 0x04
    24fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    24fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2500:	9c 81       	ldd	r25, Y+4	; 0x04
    2502:	01 97       	sbiw	r24, 0x01	; 1
    2504:	9c 83       	std	Y+4, r25	; 0x04
    2506:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2508:	89 81       	ldd	r24, Y+1	; 0x01
    250a:	9a 81       	ldd	r25, Y+2	; 0x02
    250c:	89 2f       	mov	r24, r25
    250e:	99 27       	eor	r25, r25
    2510:	9a 83       	std	Y+2, r25	; 0x02
    2512:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2514:	89 81       	ldd	r24, Y+1	; 0x01
    2516:	eb 81       	ldd	r30, Y+3	; 0x03
    2518:	fc 81       	ldd	r31, Y+4	; 0x04
    251a:	80 83       	st	Z, r24
	pxTopOfStack--;
    251c:	8b 81       	ldd	r24, Y+3	; 0x03
    251e:	9c 81       	ldd	r25, Y+4	; 0x04
    2520:	01 97       	sbiw	r24, 0x01	; 1
    2522:	9c 83       	std	Y+4, r25	; 0x04
    2524:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2526:	eb 81       	ldd	r30, Y+3	; 0x03
    2528:	fc 81       	ldd	r31, Y+4	; 0x04
    252a:	10 82       	st	Z, r1
	pxTopOfStack--;
    252c:	8b 81       	ldd	r24, Y+3	; 0x03
    252e:	9c 81       	ldd	r25, Y+4	; 0x04
    2530:	01 97       	sbiw	r24, 0x01	; 1
    2532:	9c 83       	std	Y+4, r25	; 0x04
    2534:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2536:	eb 81       	ldd	r30, Y+3	; 0x03
    2538:	fc 81       	ldd	r31, Y+4	; 0x04
    253a:	80 e8       	ldi	r24, 0x80	; 128
    253c:	80 83       	st	Z, r24
	pxTopOfStack--;
    253e:	8b 81       	ldd	r24, Y+3	; 0x03
    2540:	9c 81       	ldd	r25, Y+4	; 0x04
    2542:	01 97       	sbiw	r24, 0x01	; 1
    2544:	9c 83       	std	Y+4, r25	; 0x04
    2546:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2548:	eb 81       	ldd	r30, Y+3	; 0x03
    254a:	fc 81       	ldd	r31, Y+4	; 0x04
    254c:	10 82       	st	Z, r1
	pxTopOfStack--;
    254e:	8b 81       	ldd	r24, Y+3	; 0x03
    2550:	9c 81       	ldd	r25, Y+4	; 0x04
    2552:	01 97       	sbiw	r24, 0x01	; 1
    2554:	9c 83       	std	Y+4, r25	; 0x04
    2556:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2558:	eb 81       	ldd	r30, Y+3	; 0x03
    255a:	fc 81       	ldd	r31, Y+4	; 0x04
    255c:	82 e0       	ldi	r24, 0x02	; 2
    255e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2560:	8b 81       	ldd	r24, Y+3	; 0x03
    2562:	9c 81       	ldd	r25, Y+4	; 0x04
    2564:	01 97       	sbiw	r24, 0x01	; 1
    2566:	9c 83       	std	Y+4, r25	; 0x04
    2568:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    256a:	eb 81       	ldd	r30, Y+3	; 0x03
    256c:	fc 81       	ldd	r31, Y+4	; 0x04
    256e:	83 e0       	ldi	r24, 0x03	; 3
    2570:	80 83       	st	Z, r24
	pxTopOfStack--;
    2572:	8b 81       	ldd	r24, Y+3	; 0x03
    2574:	9c 81       	ldd	r25, Y+4	; 0x04
    2576:	01 97       	sbiw	r24, 0x01	; 1
    2578:	9c 83       	std	Y+4, r25	; 0x04
    257a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    257c:	eb 81       	ldd	r30, Y+3	; 0x03
    257e:	fc 81       	ldd	r31, Y+4	; 0x04
    2580:	84 e0       	ldi	r24, 0x04	; 4
    2582:	80 83       	st	Z, r24
	pxTopOfStack--;
    2584:	8b 81       	ldd	r24, Y+3	; 0x03
    2586:	9c 81       	ldd	r25, Y+4	; 0x04
    2588:	01 97       	sbiw	r24, 0x01	; 1
    258a:	9c 83       	std	Y+4, r25	; 0x04
    258c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    258e:	eb 81       	ldd	r30, Y+3	; 0x03
    2590:	fc 81       	ldd	r31, Y+4	; 0x04
    2592:	85 e0       	ldi	r24, 0x05	; 5
    2594:	80 83       	st	Z, r24
	pxTopOfStack--;
    2596:	8b 81       	ldd	r24, Y+3	; 0x03
    2598:	9c 81       	ldd	r25, Y+4	; 0x04
    259a:	01 97       	sbiw	r24, 0x01	; 1
    259c:	9c 83       	std	Y+4, r25	; 0x04
    259e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    25a0:	eb 81       	ldd	r30, Y+3	; 0x03
    25a2:	fc 81       	ldd	r31, Y+4	; 0x04
    25a4:	86 e0       	ldi	r24, 0x06	; 6
    25a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    25a8:	8b 81       	ldd	r24, Y+3	; 0x03
    25aa:	9c 81       	ldd	r25, Y+4	; 0x04
    25ac:	01 97       	sbiw	r24, 0x01	; 1
    25ae:	9c 83       	std	Y+4, r25	; 0x04
    25b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    25b2:	eb 81       	ldd	r30, Y+3	; 0x03
    25b4:	fc 81       	ldd	r31, Y+4	; 0x04
    25b6:	87 e0       	ldi	r24, 0x07	; 7
    25b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    25ba:	8b 81       	ldd	r24, Y+3	; 0x03
    25bc:	9c 81       	ldd	r25, Y+4	; 0x04
    25be:	01 97       	sbiw	r24, 0x01	; 1
    25c0:	9c 83       	std	Y+4, r25	; 0x04
    25c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    25c4:	eb 81       	ldd	r30, Y+3	; 0x03
    25c6:	fc 81       	ldd	r31, Y+4	; 0x04
    25c8:	88 e0       	ldi	r24, 0x08	; 8
    25ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    25cc:	8b 81       	ldd	r24, Y+3	; 0x03
    25ce:	9c 81       	ldd	r25, Y+4	; 0x04
    25d0:	01 97       	sbiw	r24, 0x01	; 1
    25d2:	9c 83       	std	Y+4, r25	; 0x04
    25d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    25d6:	eb 81       	ldd	r30, Y+3	; 0x03
    25d8:	fc 81       	ldd	r31, Y+4	; 0x04
    25da:	89 e0       	ldi	r24, 0x09	; 9
    25dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    25de:	8b 81       	ldd	r24, Y+3	; 0x03
    25e0:	9c 81       	ldd	r25, Y+4	; 0x04
    25e2:	01 97       	sbiw	r24, 0x01	; 1
    25e4:	9c 83       	std	Y+4, r25	; 0x04
    25e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    25e8:	eb 81       	ldd	r30, Y+3	; 0x03
    25ea:	fc 81       	ldd	r31, Y+4	; 0x04
    25ec:	80 e1       	ldi	r24, 0x10	; 16
    25ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    25f0:	8b 81       	ldd	r24, Y+3	; 0x03
    25f2:	9c 81       	ldd	r25, Y+4	; 0x04
    25f4:	01 97       	sbiw	r24, 0x01	; 1
    25f6:	9c 83       	std	Y+4, r25	; 0x04
    25f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    25fa:	eb 81       	ldd	r30, Y+3	; 0x03
    25fc:	fc 81       	ldd	r31, Y+4	; 0x04
    25fe:	81 e1       	ldi	r24, 0x11	; 17
    2600:	80 83       	st	Z, r24
	pxTopOfStack--;
    2602:	8b 81       	ldd	r24, Y+3	; 0x03
    2604:	9c 81       	ldd	r25, Y+4	; 0x04
    2606:	01 97       	sbiw	r24, 0x01	; 1
    2608:	9c 83       	std	Y+4, r25	; 0x04
    260a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    260c:	eb 81       	ldd	r30, Y+3	; 0x03
    260e:	fc 81       	ldd	r31, Y+4	; 0x04
    2610:	82 e1       	ldi	r24, 0x12	; 18
    2612:	80 83       	st	Z, r24
	pxTopOfStack--;
    2614:	8b 81       	ldd	r24, Y+3	; 0x03
    2616:	9c 81       	ldd	r25, Y+4	; 0x04
    2618:	01 97       	sbiw	r24, 0x01	; 1
    261a:	9c 83       	std	Y+4, r25	; 0x04
    261c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    261e:	eb 81       	ldd	r30, Y+3	; 0x03
    2620:	fc 81       	ldd	r31, Y+4	; 0x04
    2622:	83 e1       	ldi	r24, 0x13	; 19
    2624:	80 83       	st	Z, r24
	pxTopOfStack--;
    2626:	8b 81       	ldd	r24, Y+3	; 0x03
    2628:	9c 81       	ldd	r25, Y+4	; 0x04
    262a:	01 97       	sbiw	r24, 0x01	; 1
    262c:	9c 83       	std	Y+4, r25	; 0x04
    262e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2630:	eb 81       	ldd	r30, Y+3	; 0x03
    2632:	fc 81       	ldd	r31, Y+4	; 0x04
    2634:	84 e1       	ldi	r24, 0x14	; 20
    2636:	80 83       	st	Z, r24
	pxTopOfStack--;
    2638:	8b 81       	ldd	r24, Y+3	; 0x03
    263a:	9c 81       	ldd	r25, Y+4	; 0x04
    263c:	01 97       	sbiw	r24, 0x01	; 1
    263e:	9c 83       	std	Y+4, r25	; 0x04
    2640:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2642:	eb 81       	ldd	r30, Y+3	; 0x03
    2644:	fc 81       	ldd	r31, Y+4	; 0x04
    2646:	85 e1       	ldi	r24, 0x15	; 21
    2648:	80 83       	st	Z, r24
	pxTopOfStack--;
    264a:	8b 81       	ldd	r24, Y+3	; 0x03
    264c:	9c 81       	ldd	r25, Y+4	; 0x04
    264e:	01 97       	sbiw	r24, 0x01	; 1
    2650:	9c 83       	std	Y+4, r25	; 0x04
    2652:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2654:	eb 81       	ldd	r30, Y+3	; 0x03
    2656:	fc 81       	ldd	r31, Y+4	; 0x04
    2658:	86 e1       	ldi	r24, 0x16	; 22
    265a:	80 83       	st	Z, r24
	pxTopOfStack--;
    265c:	8b 81       	ldd	r24, Y+3	; 0x03
    265e:	9c 81       	ldd	r25, Y+4	; 0x04
    2660:	01 97       	sbiw	r24, 0x01	; 1
    2662:	9c 83       	std	Y+4, r25	; 0x04
    2664:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2666:	eb 81       	ldd	r30, Y+3	; 0x03
    2668:	fc 81       	ldd	r31, Y+4	; 0x04
    266a:	87 e1       	ldi	r24, 0x17	; 23
    266c:	80 83       	st	Z, r24
	pxTopOfStack--;
    266e:	8b 81       	ldd	r24, Y+3	; 0x03
    2670:	9c 81       	ldd	r25, Y+4	; 0x04
    2672:	01 97       	sbiw	r24, 0x01	; 1
    2674:	9c 83       	std	Y+4, r25	; 0x04
    2676:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2678:	eb 81       	ldd	r30, Y+3	; 0x03
    267a:	fc 81       	ldd	r31, Y+4	; 0x04
    267c:	88 e1       	ldi	r24, 0x18	; 24
    267e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2680:	8b 81       	ldd	r24, Y+3	; 0x03
    2682:	9c 81       	ldd	r25, Y+4	; 0x04
    2684:	01 97       	sbiw	r24, 0x01	; 1
    2686:	9c 83       	std	Y+4, r25	; 0x04
    2688:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    268a:	eb 81       	ldd	r30, Y+3	; 0x03
    268c:	fc 81       	ldd	r31, Y+4	; 0x04
    268e:	89 e1       	ldi	r24, 0x19	; 25
    2690:	80 83       	st	Z, r24
	pxTopOfStack--;
    2692:	8b 81       	ldd	r24, Y+3	; 0x03
    2694:	9c 81       	ldd	r25, Y+4	; 0x04
    2696:	01 97       	sbiw	r24, 0x01	; 1
    2698:	9c 83       	std	Y+4, r25	; 0x04
    269a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    269c:	eb 81       	ldd	r30, Y+3	; 0x03
    269e:	fc 81       	ldd	r31, Y+4	; 0x04
    26a0:	80 e2       	ldi	r24, 0x20	; 32
    26a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    26a4:	8b 81       	ldd	r24, Y+3	; 0x03
    26a6:	9c 81       	ldd	r25, Y+4	; 0x04
    26a8:	01 97       	sbiw	r24, 0x01	; 1
    26aa:	9c 83       	std	Y+4, r25	; 0x04
    26ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    26ae:	eb 81       	ldd	r30, Y+3	; 0x03
    26b0:	fc 81       	ldd	r31, Y+4	; 0x04
    26b2:	81 e2       	ldi	r24, 0x21	; 33
    26b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    26b6:	8b 81       	ldd	r24, Y+3	; 0x03
    26b8:	9c 81       	ldd	r25, Y+4	; 0x04
    26ba:	01 97       	sbiw	r24, 0x01	; 1
    26bc:	9c 83       	std	Y+4, r25	; 0x04
    26be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    26c0:	eb 81       	ldd	r30, Y+3	; 0x03
    26c2:	fc 81       	ldd	r31, Y+4	; 0x04
    26c4:	82 e2       	ldi	r24, 0x22	; 34
    26c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    26c8:	8b 81       	ldd	r24, Y+3	; 0x03
    26ca:	9c 81       	ldd	r25, Y+4	; 0x04
    26cc:	01 97       	sbiw	r24, 0x01	; 1
    26ce:	9c 83       	std	Y+4, r25	; 0x04
    26d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    26d2:	eb 81       	ldd	r30, Y+3	; 0x03
    26d4:	fc 81       	ldd	r31, Y+4	; 0x04
    26d6:	83 e2       	ldi	r24, 0x23	; 35
    26d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    26da:	8b 81       	ldd	r24, Y+3	; 0x03
    26dc:	9c 81       	ldd	r25, Y+4	; 0x04
    26de:	01 97       	sbiw	r24, 0x01	; 1
    26e0:	9c 83       	std	Y+4, r25	; 0x04
    26e2:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    26e4:	8f 81       	ldd	r24, Y+7	; 0x07
    26e6:	98 85       	ldd	r25, Y+8	; 0x08
    26e8:	9a 83       	std	Y+2, r25	; 0x02
    26ea:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    26ec:	89 81       	ldd	r24, Y+1	; 0x01
    26ee:	eb 81       	ldd	r30, Y+3	; 0x03
    26f0:	fc 81       	ldd	r31, Y+4	; 0x04
    26f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    26f4:	8b 81       	ldd	r24, Y+3	; 0x03
    26f6:	9c 81       	ldd	r25, Y+4	; 0x04
    26f8:	01 97       	sbiw	r24, 0x01	; 1
    26fa:	9c 83       	std	Y+4, r25	; 0x04
    26fc:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    26fe:	89 81       	ldd	r24, Y+1	; 0x01
    2700:	9a 81       	ldd	r25, Y+2	; 0x02
    2702:	89 2f       	mov	r24, r25
    2704:	99 27       	eor	r25, r25
    2706:	9a 83       	std	Y+2, r25	; 0x02
    2708:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    270a:	89 81       	ldd	r24, Y+1	; 0x01
    270c:	eb 81       	ldd	r30, Y+3	; 0x03
    270e:	fc 81       	ldd	r31, Y+4	; 0x04
    2710:	80 83       	st	Z, r24
	pxTopOfStack--;
    2712:	8b 81       	ldd	r24, Y+3	; 0x03
    2714:	9c 81       	ldd	r25, Y+4	; 0x04
    2716:	01 97       	sbiw	r24, 0x01	; 1
    2718:	9c 83       	std	Y+4, r25	; 0x04
    271a:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    271c:	eb 81       	ldd	r30, Y+3	; 0x03
    271e:	fc 81       	ldd	r31, Y+4	; 0x04
    2720:	86 e2       	ldi	r24, 0x26	; 38
    2722:	80 83       	st	Z, r24
	pxTopOfStack--;
    2724:	8b 81       	ldd	r24, Y+3	; 0x03
    2726:	9c 81       	ldd	r25, Y+4	; 0x04
    2728:	01 97       	sbiw	r24, 0x01	; 1
    272a:	9c 83       	std	Y+4, r25	; 0x04
    272c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    272e:	eb 81       	ldd	r30, Y+3	; 0x03
    2730:	fc 81       	ldd	r31, Y+4	; 0x04
    2732:	87 e2       	ldi	r24, 0x27	; 39
    2734:	80 83       	st	Z, r24
	pxTopOfStack--;
    2736:	8b 81       	ldd	r24, Y+3	; 0x03
    2738:	9c 81       	ldd	r25, Y+4	; 0x04
    273a:	01 97       	sbiw	r24, 0x01	; 1
    273c:	9c 83       	std	Y+4, r25	; 0x04
    273e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2740:	eb 81       	ldd	r30, Y+3	; 0x03
    2742:	fc 81       	ldd	r31, Y+4	; 0x04
    2744:	88 e2       	ldi	r24, 0x28	; 40
    2746:	80 83       	st	Z, r24
	pxTopOfStack--;
    2748:	8b 81       	ldd	r24, Y+3	; 0x03
    274a:	9c 81       	ldd	r25, Y+4	; 0x04
    274c:	01 97       	sbiw	r24, 0x01	; 1
    274e:	9c 83       	std	Y+4, r25	; 0x04
    2750:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2752:	eb 81       	ldd	r30, Y+3	; 0x03
    2754:	fc 81       	ldd	r31, Y+4	; 0x04
    2756:	89 e2       	ldi	r24, 0x29	; 41
    2758:	80 83       	st	Z, r24
	pxTopOfStack--;
    275a:	8b 81       	ldd	r24, Y+3	; 0x03
    275c:	9c 81       	ldd	r25, Y+4	; 0x04
    275e:	01 97       	sbiw	r24, 0x01	; 1
    2760:	9c 83       	std	Y+4, r25	; 0x04
    2762:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2764:	eb 81       	ldd	r30, Y+3	; 0x03
    2766:	fc 81       	ldd	r31, Y+4	; 0x04
    2768:	80 e3       	ldi	r24, 0x30	; 48
    276a:	80 83       	st	Z, r24
	pxTopOfStack--;
    276c:	8b 81       	ldd	r24, Y+3	; 0x03
    276e:	9c 81       	ldd	r25, Y+4	; 0x04
    2770:	01 97       	sbiw	r24, 0x01	; 1
    2772:	9c 83       	std	Y+4, r25	; 0x04
    2774:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2776:	eb 81       	ldd	r30, Y+3	; 0x03
    2778:	fc 81       	ldd	r31, Y+4	; 0x04
    277a:	81 e3       	ldi	r24, 0x31	; 49
    277c:	80 83       	st	Z, r24
	pxTopOfStack--;
    277e:	8b 81       	ldd	r24, Y+3	; 0x03
    2780:	9c 81       	ldd	r25, Y+4	; 0x04
    2782:	01 97       	sbiw	r24, 0x01	; 1
    2784:	9c 83       	std	Y+4, r25	; 0x04
    2786:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2788:	8b 81       	ldd	r24, Y+3	; 0x03
    278a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    278c:	28 96       	adiw	r28, 0x08	; 8
    278e:	0f b6       	in	r0, 0x3f	; 63
    2790:	f8 94       	cli
    2792:	de bf       	out	0x3e, r29	; 62
    2794:	0f be       	out	0x3f, r0	; 63
    2796:	cd bf       	out	0x3d, r28	; 61
    2798:	cf 91       	pop	r28
    279a:	df 91       	pop	r29
    279c:	08 95       	ret

0000279e <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    279e:	df 93       	push	r29
    27a0:	cf 93       	push	r28
    27a2:	cd b7       	in	r28, 0x3d	; 61
    27a4:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    27a6:	0e 94 bf 14 	call	0x297e	; 0x297e <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    27aa:	a0 91 a6 05 	lds	r26, 0x05A6
    27ae:	b0 91 a7 05 	lds	r27, 0x05A7
    27b2:	cd 91       	ld	r28, X+
    27b4:	cd bf       	out	0x3d, r28	; 61
    27b6:	dd 91       	ld	r29, X+
    27b8:	de bf       	out	0x3e, r29	; 62
    27ba:	ff 91       	pop	r31
    27bc:	ef 91       	pop	r30
    27be:	df 91       	pop	r29
    27c0:	cf 91       	pop	r28
    27c2:	bf 91       	pop	r27
    27c4:	af 91       	pop	r26
    27c6:	9f 91       	pop	r25
    27c8:	8f 91       	pop	r24
    27ca:	7f 91       	pop	r23
    27cc:	6f 91       	pop	r22
    27ce:	5f 91       	pop	r21
    27d0:	4f 91       	pop	r20
    27d2:	3f 91       	pop	r19
    27d4:	2f 91       	pop	r18
    27d6:	1f 91       	pop	r17
    27d8:	0f 91       	pop	r16
    27da:	ff 90       	pop	r15
    27dc:	ef 90       	pop	r14
    27de:	df 90       	pop	r13
    27e0:	cf 90       	pop	r12
    27e2:	bf 90       	pop	r11
    27e4:	af 90       	pop	r10
    27e6:	9f 90       	pop	r9
    27e8:	8f 90       	pop	r8
    27ea:	7f 90       	pop	r7
    27ec:	6f 90       	pop	r6
    27ee:	5f 90       	pop	r5
    27f0:	4f 90       	pop	r4
    27f2:	3f 90       	pop	r3
    27f4:	2f 90       	pop	r2
    27f6:	1f 90       	pop	r1
    27f8:	0f 90       	pop	r0
    27fa:	0f be       	out	0x3f, r0	; 63
    27fc:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    27fe:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2800:	81 e0       	ldi	r24, 0x01	; 1
}
    2802:	cf 91       	pop	r28
    2804:	df 91       	pop	r29
    2806:	08 95       	ret

00002808 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2808:	df 93       	push	r29
    280a:	cf 93       	push	r28
    280c:	cd b7       	in	r28, 0x3d	; 61
    280e:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2810:	cf 91       	pop	r28
    2812:	df 91       	pop	r29
    2814:	08 95       	ret

00002816 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2816:	0f 92       	push	r0
    2818:	0f b6       	in	r0, 0x3f	; 63
    281a:	f8 94       	cli
    281c:	0f 92       	push	r0
    281e:	1f 92       	push	r1
    2820:	11 24       	eor	r1, r1
    2822:	2f 92       	push	r2
    2824:	3f 92       	push	r3
    2826:	4f 92       	push	r4
    2828:	5f 92       	push	r5
    282a:	6f 92       	push	r6
    282c:	7f 92       	push	r7
    282e:	8f 92       	push	r8
    2830:	9f 92       	push	r9
    2832:	af 92       	push	r10
    2834:	bf 92       	push	r11
    2836:	cf 92       	push	r12
    2838:	df 92       	push	r13
    283a:	ef 92       	push	r14
    283c:	ff 92       	push	r15
    283e:	0f 93       	push	r16
    2840:	1f 93       	push	r17
    2842:	2f 93       	push	r18
    2844:	3f 93       	push	r19
    2846:	4f 93       	push	r20
    2848:	5f 93       	push	r21
    284a:	6f 93       	push	r22
    284c:	7f 93       	push	r23
    284e:	8f 93       	push	r24
    2850:	9f 93       	push	r25
    2852:	af 93       	push	r26
    2854:	bf 93       	push	r27
    2856:	cf 93       	push	r28
    2858:	df 93       	push	r29
    285a:	ef 93       	push	r30
    285c:	ff 93       	push	r31
    285e:	a0 91 a6 05 	lds	r26, 0x05A6
    2862:	b0 91 a7 05 	lds	r27, 0x05A7
    2866:	0d b6       	in	r0, 0x3d	; 61
    2868:	0d 92       	st	X+, r0
    286a:	0e b6       	in	r0, 0x3e	; 62
    286c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    286e:	0e 94 7b 1d 	call	0x3af6	; 0x3af6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2872:	a0 91 a6 05 	lds	r26, 0x05A6
    2876:	b0 91 a7 05 	lds	r27, 0x05A7
    287a:	cd 91       	ld	r28, X+
    287c:	cd bf       	out	0x3d, r28	; 61
    287e:	dd 91       	ld	r29, X+
    2880:	de bf       	out	0x3e, r29	; 62
    2882:	ff 91       	pop	r31
    2884:	ef 91       	pop	r30
    2886:	df 91       	pop	r29
    2888:	cf 91       	pop	r28
    288a:	bf 91       	pop	r27
    288c:	af 91       	pop	r26
    288e:	9f 91       	pop	r25
    2890:	8f 91       	pop	r24
    2892:	7f 91       	pop	r23
    2894:	6f 91       	pop	r22
    2896:	5f 91       	pop	r21
    2898:	4f 91       	pop	r20
    289a:	3f 91       	pop	r19
    289c:	2f 91       	pop	r18
    289e:	1f 91       	pop	r17
    28a0:	0f 91       	pop	r16
    28a2:	ff 90       	pop	r15
    28a4:	ef 90       	pop	r14
    28a6:	df 90       	pop	r13
    28a8:	cf 90       	pop	r12
    28aa:	bf 90       	pop	r11
    28ac:	af 90       	pop	r10
    28ae:	9f 90       	pop	r9
    28b0:	8f 90       	pop	r8
    28b2:	7f 90       	pop	r7
    28b4:	6f 90       	pop	r6
    28b6:	5f 90       	pop	r5
    28b8:	4f 90       	pop	r4
    28ba:	3f 90       	pop	r3
    28bc:	2f 90       	pop	r2
    28be:	1f 90       	pop	r1
    28c0:	0f 90       	pop	r0
    28c2:	0f be       	out	0x3f, r0	; 63
    28c4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    28c6:	08 95       	ret

000028c8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    28c8:	0f 92       	push	r0
    28ca:	0f b6       	in	r0, 0x3f	; 63
    28cc:	f8 94       	cli
    28ce:	0f 92       	push	r0
    28d0:	1f 92       	push	r1
    28d2:	11 24       	eor	r1, r1
    28d4:	2f 92       	push	r2
    28d6:	3f 92       	push	r3
    28d8:	4f 92       	push	r4
    28da:	5f 92       	push	r5
    28dc:	6f 92       	push	r6
    28de:	7f 92       	push	r7
    28e0:	8f 92       	push	r8
    28e2:	9f 92       	push	r9
    28e4:	af 92       	push	r10
    28e6:	bf 92       	push	r11
    28e8:	cf 92       	push	r12
    28ea:	df 92       	push	r13
    28ec:	ef 92       	push	r14
    28ee:	ff 92       	push	r15
    28f0:	0f 93       	push	r16
    28f2:	1f 93       	push	r17
    28f4:	2f 93       	push	r18
    28f6:	3f 93       	push	r19
    28f8:	4f 93       	push	r20
    28fa:	5f 93       	push	r21
    28fc:	6f 93       	push	r22
    28fe:	7f 93       	push	r23
    2900:	8f 93       	push	r24
    2902:	9f 93       	push	r25
    2904:	af 93       	push	r26
    2906:	bf 93       	push	r27
    2908:	cf 93       	push	r28
    290a:	df 93       	push	r29
    290c:	ef 93       	push	r30
    290e:	ff 93       	push	r31
    2910:	a0 91 a6 05 	lds	r26, 0x05A6
    2914:	b0 91 a7 05 	lds	r27, 0x05A7
    2918:	0d b6       	in	r0, 0x3d	; 61
    291a:	0d 92       	st	X+, r0
    291c:	0e b6       	in	r0, 0x3e	; 62
    291e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2920:	0e 94 a6 1c 	call	0x394c	; 0x394c <vTaskIncrementTick>
	vTaskSwitchContext();
    2924:	0e 94 7b 1d 	call	0x3af6	; 0x3af6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2928:	a0 91 a6 05 	lds	r26, 0x05A6
    292c:	b0 91 a7 05 	lds	r27, 0x05A7
    2930:	cd 91       	ld	r28, X+
    2932:	cd bf       	out	0x3d, r28	; 61
    2934:	dd 91       	ld	r29, X+
    2936:	de bf       	out	0x3e, r29	; 62
    2938:	ff 91       	pop	r31
    293a:	ef 91       	pop	r30
    293c:	df 91       	pop	r29
    293e:	cf 91       	pop	r28
    2940:	bf 91       	pop	r27
    2942:	af 91       	pop	r26
    2944:	9f 91       	pop	r25
    2946:	8f 91       	pop	r24
    2948:	7f 91       	pop	r23
    294a:	6f 91       	pop	r22
    294c:	5f 91       	pop	r21
    294e:	4f 91       	pop	r20
    2950:	3f 91       	pop	r19
    2952:	2f 91       	pop	r18
    2954:	1f 91       	pop	r17
    2956:	0f 91       	pop	r16
    2958:	ff 90       	pop	r15
    295a:	ef 90       	pop	r14
    295c:	df 90       	pop	r13
    295e:	cf 90       	pop	r12
    2960:	bf 90       	pop	r11
    2962:	af 90       	pop	r10
    2964:	9f 90       	pop	r9
    2966:	8f 90       	pop	r8
    2968:	7f 90       	pop	r7
    296a:	6f 90       	pop	r6
    296c:	5f 90       	pop	r5
    296e:	4f 90       	pop	r4
    2970:	3f 90       	pop	r3
    2972:	2f 90       	pop	r2
    2974:	1f 90       	pop	r1
    2976:	0f 90       	pop	r0
    2978:	0f be       	out	0x3f, r0	; 63
    297a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    297c:	08 95       	ret

0000297e <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    297e:	df 93       	push	r29
    2980:	cf 93       	push	r28
    2982:	00 d0       	rcall	.+0      	; 0x2984 <prvSetupTimerInterrupt+0x6>
    2984:	00 d0       	rcall	.+0      	; 0x2986 <prvSetupTimerInterrupt+0x8>
    2986:	00 d0       	rcall	.+0      	; 0x2988 <prvSetupTimerInterrupt+0xa>
    2988:	cd b7       	in	r28, 0x3d	; 61
    298a:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    298c:	80 e4       	ldi	r24, 0x40	; 64
    298e:	9f e1       	ldi	r25, 0x1F	; 31
    2990:	a0 e0       	ldi	r26, 0x00	; 0
    2992:	b0 e0       	ldi	r27, 0x00	; 0
    2994:	8b 83       	std	Y+3, r24	; 0x03
    2996:	9c 83       	std	Y+4, r25	; 0x04
    2998:	ad 83       	std	Y+5, r26	; 0x05
    299a:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    299c:	8b 81       	ldd	r24, Y+3	; 0x03
    299e:	9c 81       	ldd	r25, Y+4	; 0x04
    29a0:	ad 81       	ldd	r26, Y+5	; 0x05
    29a2:	be 81       	ldd	r27, Y+6	; 0x06
    29a4:	68 94       	set
    29a6:	15 f8       	bld	r1, 5
    29a8:	b6 95       	lsr	r27
    29aa:	a7 95       	ror	r26
    29ac:	97 95       	ror	r25
    29ae:	87 95       	ror	r24
    29b0:	16 94       	lsr	r1
    29b2:	d1 f7       	brne	.-12     	; 0x29a8 <prvSetupTimerInterrupt+0x2a>
    29b4:	8b 83       	std	Y+3, r24	; 0x03
    29b6:	9c 83       	std	Y+4, r25	; 0x04
    29b8:	ad 83       	std	Y+5, r26	; 0x05
    29ba:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    29bc:	8b 81       	ldd	r24, Y+3	; 0x03
    29be:	9c 81       	ldd	r25, Y+4	; 0x04
    29c0:	ad 81       	ldd	r26, Y+5	; 0x05
    29c2:	be 81       	ldd	r27, Y+6	; 0x06
    29c4:	01 97       	sbiw	r24, 0x01	; 1
    29c6:	a1 09       	sbc	r26, r1
    29c8:	b1 09       	sbc	r27, r1
    29ca:	8b 83       	std	Y+3, r24	; 0x03
    29cc:	9c 83       	std	Y+4, r25	; 0x04
    29ce:	ad 83       	std	Y+5, r26	; 0x05
    29d0:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    29d2:	8b 81       	ldd	r24, Y+3	; 0x03
    29d4:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    29d6:	8b 81       	ldd	r24, Y+3	; 0x03
    29d8:	9c 81       	ldd	r25, Y+4	; 0x04
    29da:	ad 81       	ldd	r26, Y+5	; 0x05
    29dc:	be 81       	ldd	r27, Y+6	; 0x06
    29de:	89 2f       	mov	r24, r25
    29e0:	9a 2f       	mov	r25, r26
    29e2:	ab 2f       	mov	r26, r27
    29e4:	bb 27       	eor	r27, r27
    29e6:	8b 83       	std	Y+3, r24	; 0x03
    29e8:	9c 83       	std	Y+4, r25	; 0x04
    29ea:	ad 83       	std	Y+5, r26	; 0x05
    29ec:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    29ee:	8b 81       	ldd	r24, Y+3	; 0x03
    29f0:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    29f2:	eb e4       	ldi	r30, 0x4B	; 75
    29f4:	f0 e0       	ldi	r31, 0x00	; 0
    29f6:	8a 81       	ldd	r24, Y+2	; 0x02
    29f8:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    29fa:	ea e4       	ldi	r30, 0x4A	; 74
    29fc:	f0 e0       	ldi	r31, 0x00	; 0
    29fe:	89 81       	ldd	r24, Y+1	; 0x01
    2a00:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2a02:	8b e0       	ldi	r24, 0x0B	; 11
    2a04:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2a06:	ee e4       	ldi	r30, 0x4E	; 78
    2a08:	f0 e0       	ldi	r31, 0x00	; 0
    2a0a:	89 81       	ldd	r24, Y+1	; 0x01
    2a0c:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2a0e:	e9 e5       	ldi	r30, 0x59	; 89
    2a10:	f0 e0       	ldi	r31, 0x00	; 0
    2a12:	80 81       	ld	r24, Z
    2a14:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2a16:	89 81       	ldd	r24, Y+1	; 0x01
    2a18:	80 61       	ori	r24, 0x10	; 16
    2a1a:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2a1c:	e9 e5       	ldi	r30, 0x59	; 89
    2a1e:	f0 e0       	ldi	r31, 0x00	; 0
    2a20:	89 81       	ldd	r24, Y+1	; 0x01
    2a22:	80 83       	st	Z, r24
}
    2a24:	26 96       	adiw	r28, 0x06	; 6
    2a26:	0f b6       	in	r0, 0x3f	; 63
    2a28:	f8 94       	cli
    2a2a:	de bf       	out	0x3e, r29	; 62
    2a2c:	0f be       	out	0x3f, r0	; 63
    2a2e:	cd bf       	out	0x3d, r28	; 61
    2a30:	cf 91       	pop	r28
    2a32:	df 91       	pop	r29
    2a34:	08 95       	ret

00002a36 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2a36:	0e 94 64 14 	call	0x28c8	; 0x28c8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2a3a:	18 95       	reti

00002a3c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    2a3c:	df 93       	push	r29
    2a3e:	cf 93       	push	r28
    2a40:	cd b7       	in	r28, 0x3d	; 61
    2a42:	de b7       	in	r29, 0x3e	; 62
    2a44:	28 97       	sbiw	r28, 0x08	; 8
    2a46:	0f b6       	in	r0, 0x3f	; 63
    2a48:	f8 94       	cli
    2a4a:	de bf       	out	0x3e, r29	; 62
    2a4c:	0f be       	out	0x3f, r0	; 63
    2a4e:	cd bf       	out	0x3d, r28	; 61
    2a50:	8f 83       	std	Y+7, r24	; 0x07
    2a52:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    2a54:	1a 82       	std	Y+2, r1	; 0x02
    2a56:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2a58:	8f 81       	ldd	r24, Y+7	; 0x07
    2a5a:	88 23       	and	r24, r24
    2a5c:	09 f4       	brne	.+2      	; 0x2a60 <xQueueCreate+0x24>
    2a5e:	8c c0       	rjmp	.+280    	; 0x2b78 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2a60:	8f e1       	ldi	r24, 0x1F	; 31
    2a62:	90 e0       	ldi	r25, 0x00	; 0
    2a64:	0e 94 51 10 	call	0x20a2	; 0x20a2 <pvPortMalloc>
    2a68:	9e 83       	std	Y+6, r25	; 0x06
    2a6a:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    2a6c:	8d 81       	ldd	r24, Y+5	; 0x05
    2a6e:	9e 81       	ldd	r25, Y+6	; 0x06
    2a70:	00 97       	sbiw	r24, 0x00	; 0
    2a72:	09 f4       	brne	.+2      	; 0x2a76 <xQueueCreate+0x3a>
    2a74:	81 c0       	rjmp	.+258    	; 0x2b78 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2a76:	8f 81       	ldd	r24, Y+7	; 0x07
    2a78:	28 2f       	mov	r18, r24
    2a7a:	30 e0       	ldi	r19, 0x00	; 0
    2a7c:	88 85       	ldd	r24, Y+8	; 0x08
    2a7e:	88 2f       	mov	r24, r24
    2a80:	90 e0       	ldi	r25, 0x00	; 0
    2a82:	ac 01       	movw	r20, r24
    2a84:	24 9f       	mul	r18, r20
    2a86:	c0 01       	movw	r24, r0
    2a88:	25 9f       	mul	r18, r21
    2a8a:	90 0d       	add	r25, r0
    2a8c:	34 9f       	mul	r19, r20
    2a8e:	90 0d       	add	r25, r0
    2a90:	11 24       	eor	r1, r1
    2a92:	01 96       	adiw	r24, 0x01	; 1
    2a94:	9c 83       	std	Y+4, r25	; 0x04
    2a96:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2a98:	8b 81       	ldd	r24, Y+3	; 0x03
    2a9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a9c:	0e 94 51 10 	call	0x20a2	; 0x20a2 <pvPortMalloc>
    2aa0:	ed 81       	ldd	r30, Y+5	; 0x05
    2aa2:	fe 81       	ldd	r31, Y+6	; 0x06
    2aa4:	91 83       	std	Z+1, r25	; 0x01
    2aa6:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    2aa8:	ed 81       	ldd	r30, Y+5	; 0x05
    2aaa:	fe 81       	ldd	r31, Y+6	; 0x06
    2aac:	80 81       	ld	r24, Z
    2aae:	91 81       	ldd	r25, Z+1	; 0x01
    2ab0:	00 97       	sbiw	r24, 0x00	; 0
    2ab2:	09 f4       	brne	.+2      	; 0x2ab6 <xQueueCreate+0x7a>
    2ab4:	5d c0       	rjmp	.+186    	; 0x2b70 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    2ab6:	ed 81       	ldd	r30, Y+5	; 0x05
    2ab8:	fe 81       	ldd	r31, Y+6	; 0x06
    2aba:	40 81       	ld	r20, Z
    2abc:	51 81       	ldd	r21, Z+1	; 0x01
    2abe:	8f 81       	ldd	r24, Y+7	; 0x07
    2ac0:	28 2f       	mov	r18, r24
    2ac2:	30 e0       	ldi	r19, 0x00	; 0
    2ac4:	88 85       	ldd	r24, Y+8	; 0x08
    2ac6:	88 2f       	mov	r24, r24
    2ac8:	90 e0       	ldi	r25, 0x00	; 0
    2aca:	bc 01       	movw	r22, r24
    2acc:	26 9f       	mul	r18, r22
    2ace:	c0 01       	movw	r24, r0
    2ad0:	27 9f       	mul	r18, r23
    2ad2:	90 0d       	add	r25, r0
    2ad4:	36 9f       	mul	r19, r22
    2ad6:	90 0d       	add	r25, r0
    2ad8:	11 24       	eor	r1, r1
    2ada:	84 0f       	add	r24, r20
    2adc:	95 1f       	adc	r25, r21
    2ade:	ed 81       	ldd	r30, Y+5	; 0x05
    2ae0:	fe 81       	ldd	r31, Y+6	; 0x06
    2ae2:	93 83       	std	Z+3, r25	; 0x03
    2ae4:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    2ae6:	ed 81       	ldd	r30, Y+5	; 0x05
    2ae8:	fe 81       	ldd	r31, Y+6	; 0x06
    2aea:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    2aec:	ed 81       	ldd	r30, Y+5	; 0x05
    2aee:	fe 81       	ldd	r31, Y+6	; 0x06
    2af0:	80 81       	ld	r24, Z
    2af2:	91 81       	ldd	r25, Z+1	; 0x01
    2af4:	ed 81       	ldd	r30, Y+5	; 0x05
    2af6:	fe 81       	ldd	r31, Y+6	; 0x06
    2af8:	95 83       	std	Z+5, r25	; 0x05
    2afa:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    2afc:	ed 81       	ldd	r30, Y+5	; 0x05
    2afe:	fe 81       	ldd	r31, Y+6	; 0x06
    2b00:	40 81       	ld	r20, Z
    2b02:	51 81       	ldd	r21, Z+1	; 0x01
    2b04:	8f 81       	ldd	r24, Y+7	; 0x07
    2b06:	88 2f       	mov	r24, r24
    2b08:	90 e0       	ldi	r25, 0x00	; 0
    2b0a:	9c 01       	movw	r18, r24
    2b0c:	21 50       	subi	r18, 0x01	; 1
    2b0e:	30 40       	sbci	r19, 0x00	; 0
    2b10:	88 85       	ldd	r24, Y+8	; 0x08
    2b12:	88 2f       	mov	r24, r24
    2b14:	90 e0       	ldi	r25, 0x00	; 0
    2b16:	bc 01       	movw	r22, r24
    2b18:	26 9f       	mul	r18, r22
    2b1a:	c0 01       	movw	r24, r0
    2b1c:	27 9f       	mul	r18, r23
    2b1e:	90 0d       	add	r25, r0
    2b20:	36 9f       	mul	r19, r22
    2b22:	90 0d       	add	r25, r0
    2b24:	11 24       	eor	r1, r1
    2b26:	84 0f       	add	r24, r20
    2b28:	95 1f       	adc	r25, r21
    2b2a:	ed 81       	ldd	r30, Y+5	; 0x05
    2b2c:	fe 81       	ldd	r31, Y+6	; 0x06
    2b2e:	97 83       	std	Z+7, r25	; 0x07
    2b30:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    2b32:	ed 81       	ldd	r30, Y+5	; 0x05
    2b34:	fe 81       	ldd	r31, Y+6	; 0x06
    2b36:	8f 81       	ldd	r24, Y+7	; 0x07
    2b38:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2b3a:	ed 81       	ldd	r30, Y+5	; 0x05
    2b3c:	fe 81       	ldd	r31, Y+6	; 0x06
    2b3e:	88 85       	ldd	r24, Y+8	; 0x08
    2b40:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    2b42:	ed 81       	ldd	r30, Y+5	; 0x05
    2b44:	fe 81       	ldd	r31, Y+6	; 0x06
    2b46:	8f ef       	ldi	r24, 0xFF	; 255
    2b48:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2b4a:	ed 81       	ldd	r30, Y+5	; 0x05
    2b4c:	fe 81       	ldd	r31, Y+6	; 0x06
    2b4e:	8f ef       	ldi	r24, 0xFF	; 255
    2b50:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2b52:	8d 81       	ldd	r24, Y+5	; 0x05
    2b54:	9e 81       	ldd	r25, Y+6	; 0x06
    2b56:	08 96       	adiw	r24, 0x08	; 8
    2b58:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2b5c:	8d 81       	ldd	r24, Y+5	; 0x05
    2b5e:	9e 81       	ldd	r25, Y+6	; 0x06
    2b60:	41 96       	adiw	r24, 0x11	; 17
    2b62:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2b66:	8d 81       	ldd	r24, Y+5	; 0x05
    2b68:	9e 81       	ldd	r25, Y+6	; 0x06
    2b6a:	9a 83       	std	Y+2, r25	; 0x02
    2b6c:	89 83       	std	Y+1, r24	; 0x01
    2b6e:	04 c0       	rjmp	.+8      	; 0x2b78 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    2b70:	8d 81       	ldd	r24, Y+5	; 0x05
    2b72:	9e 81       	ldd	r25, Y+6	; 0x06
    2b74:	0e 94 97 10 	call	0x212e	; 0x212e <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    2b78:	89 81       	ldd	r24, Y+1	; 0x01
    2b7a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2b7c:	28 96       	adiw	r28, 0x08	; 8
    2b7e:	0f b6       	in	r0, 0x3f	; 63
    2b80:	f8 94       	cli
    2b82:	de bf       	out	0x3e, r29	; 62
    2b84:	0f be       	out	0x3f, r0	; 63
    2b86:	cd bf       	out	0x3d, r28	; 61
    2b88:	cf 91       	pop	r28
    2b8a:	df 91       	pop	r29
    2b8c:	08 95       	ret

00002b8e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    2b8e:	df 93       	push	r29
    2b90:	cf 93       	push	r28
    2b92:	cd b7       	in	r28, 0x3d	; 61
    2b94:	de b7       	in	r29, 0x3e	; 62
    2b96:	2c 97       	sbiw	r28, 0x0c	; 12
    2b98:	0f b6       	in	r0, 0x3f	; 63
    2b9a:	f8 94       	cli
    2b9c:	de bf       	out	0x3e, r29	; 62
    2b9e:	0f be       	out	0x3f, r0	; 63
    2ba0:	cd bf       	out	0x3d, r28	; 61
    2ba2:	9e 83       	std	Y+6, r25	; 0x06
    2ba4:	8d 83       	std	Y+5, r24	; 0x05
    2ba6:	78 87       	std	Y+8, r23	; 0x08
    2ba8:	6f 83       	std	Y+7, r22	; 0x07
    2baa:	5a 87       	std	Y+10, r21	; 0x0a
    2bac:	49 87       	std	Y+9, r20	; 0x09
    2bae:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2bb0:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2bb2:	0f b6       	in	r0, 0x3f	; 63
    2bb4:	f8 94       	cli
    2bb6:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2bb8:	ed 81       	ldd	r30, Y+5	; 0x05
    2bba:	fe 81       	ldd	r31, Y+6	; 0x06
    2bbc:	92 8d       	ldd	r25, Z+26	; 0x1a
    2bbe:	ed 81       	ldd	r30, Y+5	; 0x05
    2bc0:	fe 81       	ldd	r31, Y+6	; 0x06
    2bc2:	83 8d       	ldd	r24, Z+27	; 0x1b
    2bc4:	98 17       	cp	r25, r24
    2bc6:	d8 f4       	brcc	.+54     	; 0x2bfe <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2bc8:	8d 81       	ldd	r24, Y+5	; 0x05
    2bca:	9e 81       	ldd	r25, Y+6	; 0x06
    2bcc:	2f 81       	ldd	r18, Y+7	; 0x07
    2bce:	38 85       	ldd	r19, Y+8	; 0x08
    2bd0:	b9 01       	movw	r22, r18
    2bd2:	4b 85       	ldd	r20, Y+11	; 0x0b
    2bd4:	0e 94 02 18 	call	0x3004	; 0x3004 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2bd8:	ed 81       	ldd	r30, Y+5	; 0x05
    2bda:	fe 81       	ldd	r31, Y+6	; 0x06
    2bdc:	81 89       	ldd	r24, Z+17	; 0x11
    2bde:	88 23       	and	r24, r24
    2be0:	49 f0       	breq	.+18     	; 0x2bf4 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2be2:	8d 81       	ldd	r24, Y+5	; 0x05
    2be4:	9e 81       	ldd	r25, Y+6	; 0x06
    2be6:	41 96       	adiw	r24, 0x11	; 17
    2be8:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <xTaskRemoveFromEventList>
    2bec:	81 30       	cpi	r24, 0x01	; 1
    2bee:	11 f4       	brne	.+4      	; 0x2bf4 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    2bf0:	0e 94 0b 14 	call	0x2816	; 0x2816 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    2bf4:	0f 90       	pop	r0
    2bf6:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    2bf8:	81 e0       	ldi	r24, 0x01	; 1
    2bfa:	8c 87       	std	Y+12, r24	; 0x0c
    2bfc:	5c c0       	rjmp	.+184    	; 0x2cb6 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2bfe:	89 85       	ldd	r24, Y+9	; 0x09
    2c00:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c02:	00 97       	sbiw	r24, 0x00	; 0
    2c04:	21 f4       	brne	.+8      	; 0x2c0e <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2c06:	0f 90       	pop	r0
    2c08:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2c0a:	1c 86       	std	Y+12, r1	; 0x0c
    2c0c:	54 c0       	rjmp	.+168    	; 0x2cb6 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    2c0e:	89 81       	ldd	r24, Y+1	; 0x01
    2c10:	88 23       	and	r24, r24
    2c12:	31 f4       	brne	.+12     	; 0x2c20 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2c14:	ce 01       	movw	r24, r28
    2c16:	02 96       	adiw	r24, 0x02	; 2
    2c18:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2c1c:	81 e0       	ldi	r24, 0x01	; 1
    2c1e:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    2c20:	0f 90       	pop	r0
    2c22:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2c24:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2c28:	0f b6       	in	r0, 0x3f	; 63
    2c2a:	f8 94       	cli
    2c2c:	0f 92       	push	r0
    2c2e:	ed 81       	ldd	r30, Y+5	; 0x05
    2c30:	fe 81       	ldd	r31, Y+6	; 0x06
    2c32:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c34:	8f 3f       	cpi	r24, 0xFF	; 255
    2c36:	19 f4       	brne	.+6      	; 0x2c3e <xQueueGenericSend+0xb0>
    2c38:	ed 81       	ldd	r30, Y+5	; 0x05
    2c3a:	fe 81       	ldd	r31, Y+6	; 0x06
    2c3c:	15 8e       	std	Z+29, r1	; 0x1d
    2c3e:	ed 81       	ldd	r30, Y+5	; 0x05
    2c40:	fe 81       	ldd	r31, Y+6	; 0x06
    2c42:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c44:	8f 3f       	cpi	r24, 0xFF	; 255
    2c46:	19 f4       	brne	.+6      	; 0x2c4e <xQueueGenericSend+0xc0>
    2c48:	ed 81       	ldd	r30, Y+5	; 0x05
    2c4a:	fe 81       	ldd	r31, Y+6	; 0x06
    2c4c:	16 8e       	std	Z+30, r1	; 0x1e
    2c4e:	0f 90       	pop	r0
    2c50:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2c52:	ce 01       	movw	r24, r28
    2c54:	02 96       	adiw	r24, 0x02	; 2
    2c56:	9e 01       	movw	r18, r28
    2c58:	27 5f       	subi	r18, 0xF7	; 247
    2c5a:	3f 4f       	sbci	r19, 0xFF	; 255
    2c5c:	b9 01       	movw	r22, r18
    2c5e:	0e 94 98 1e 	call	0x3d30	; 0x3d30 <xTaskCheckForTimeOut>
    2c62:	88 23       	and	r24, r24
    2c64:	09 f5       	brne	.+66     	; 0x2ca8 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2c66:	8d 81       	ldd	r24, Y+5	; 0x05
    2c68:	9e 81       	ldd	r25, Y+6	; 0x06
    2c6a:	0e 94 66 19 	call	0x32cc	; 0x32cc <prvIsQueueFull>
    2c6e:	88 23       	and	r24, r24
    2c70:	a1 f0       	breq	.+40     	; 0x2c9a <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2c72:	8d 81       	ldd	r24, Y+5	; 0x05
    2c74:	9e 81       	ldd	r25, Y+6	; 0x06
    2c76:	08 96       	adiw	r24, 0x08	; 8
    2c78:	29 85       	ldd	r18, Y+9	; 0x09
    2c7a:	3a 85       	ldd	r19, Y+10	; 0x0a
    2c7c:	b9 01       	movw	r22, r18
    2c7e:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2c82:	8d 81       	ldd	r24, Y+5	; 0x05
    2c84:	9e 81       	ldd	r25, Y+6	; 0x06
    2c86:	0e 94 df 18 	call	0x31be	; 0x31be <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2c8a:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xTaskResumeAll>
    2c8e:	88 23       	and	r24, r24
    2c90:	09 f0       	breq	.+2      	; 0x2c94 <xQueueGenericSend+0x106>
    2c92:	8f cf       	rjmp	.-226    	; 0x2bb2 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    2c94:	0e 94 0b 14 	call	0x2816	; 0x2816 <vPortYield>
    2c98:	8c cf       	rjmp	.-232    	; 0x2bb2 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2c9a:	8d 81       	ldd	r24, Y+5	; 0x05
    2c9c:	9e 81       	ldd	r25, Y+6	; 0x06
    2c9e:	0e 94 df 18 	call	0x31be	; 0x31be <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2ca2:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xTaskResumeAll>
    2ca6:	85 cf       	rjmp	.-246    	; 0x2bb2 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2ca8:	8d 81       	ldd	r24, Y+5	; 0x05
    2caa:	9e 81       	ldd	r25, Y+6	; 0x06
    2cac:	0e 94 df 18 	call	0x31be	; 0x31be <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2cb0:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2cb4:	1c 86       	std	Y+12, r1	; 0x0c
    2cb6:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    2cb8:	2c 96       	adiw	r28, 0x0c	; 12
    2cba:	0f b6       	in	r0, 0x3f	; 63
    2cbc:	f8 94       	cli
    2cbe:	de bf       	out	0x3e, r29	; 62
    2cc0:	0f be       	out	0x3f, r0	; 63
    2cc2:	cd bf       	out	0x3d, r28	; 61
    2cc4:	cf 91       	pop	r28
    2cc6:	df 91       	pop	r29
    2cc8:	08 95       	ret

00002cca <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    2cca:	df 93       	push	r29
    2ccc:	cf 93       	push	r28
    2cce:	cd b7       	in	r28, 0x3d	; 61
    2cd0:	de b7       	in	r29, 0x3e	; 62
    2cd2:	29 97       	sbiw	r28, 0x09	; 9
    2cd4:	0f b6       	in	r0, 0x3f	; 63
    2cd6:	f8 94       	cli
    2cd8:	de bf       	out	0x3e, r29	; 62
    2cda:	0f be       	out	0x3f, r0	; 63
    2cdc:	cd bf       	out	0x3d, r28	; 61
    2cde:	9c 83       	std	Y+4, r25	; 0x04
    2ce0:	8b 83       	std	Y+3, r24	; 0x03
    2ce2:	7e 83       	std	Y+6, r23	; 0x06
    2ce4:	6d 83       	std	Y+5, r22	; 0x05
    2ce6:	58 87       	std	Y+8, r21	; 0x08
    2ce8:	4f 83       	std	Y+7, r20	; 0x07
    2cea:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2cec:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2cee:	eb 81       	ldd	r30, Y+3	; 0x03
    2cf0:	fc 81       	ldd	r31, Y+4	; 0x04
    2cf2:	92 8d       	ldd	r25, Z+26	; 0x1a
    2cf4:	eb 81       	ldd	r30, Y+3	; 0x03
    2cf6:	fc 81       	ldd	r31, Y+4	; 0x04
    2cf8:	83 8d       	ldd	r24, Z+27	; 0x1b
    2cfa:	98 17       	cp	r25, r24
    2cfc:	40 f5       	brcc	.+80     	; 0x2d4e <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2cfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2d00:	9c 81       	ldd	r25, Y+4	; 0x04
    2d02:	2d 81       	ldd	r18, Y+5	; 0x05
    2d04:	3e 81       	ldd	r19, Y+6	; 0x06
    2d06:	b9 01       	movw	r22, r18
    2d08:	49 85       	ldd	r20, Y+9	; 0x09
    2d0a:	0e 94 02 18 	call	0x3004	; 0x3004 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2d0e:	eb 81       	ldd	r30, Y+3	; 0x03
    2d10:	fc 81       	ldd	r31, Y+4	; 0x04
    2d12:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d14:	8f 3f       	cpi	r24, 0xFF	; 255
    2d16:	89 f4       	brne	.+34     	; 0x2d3a <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2d18:	eb 81       	ldd	r30, Y+3	; 0x03
    2d1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d1c:	81 89       	ldd	r24, Z+17	; 0x11
    2d1e:	88 23       	and	r24, r24
    2d20:	99 f0       	breq	.+38     	; 0x2d48 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2d22:	8b 81       	ldd	r24, Y+3	; 0x03
    2d24:	9c 81       	ldd	r25, Y+4	; 0x04
    2d26:	41 96       	adiw	r24, 0x11	; 17
    2d28:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <xTaskRemoveFromEventList>
    2d2c:	88 23       	and	r24, r24
    2d2e:	61 f0       	breq	.+24     	; 0x2d48 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    2d30:	ef 81       	ldd	r30, Y+7	; 0x07
    2d32:	f8 85       	ldd	r31, Y+8	; 0x08
    2d34:	81 e0       	ldi	r24, 0x01	; 1
    2d36:	80 83       	st	Z, r24
    2d38:	07 c0       	rjmp	.+14     	; 0x2d48 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2d3a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d3c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d3e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d40:	8f 5f       	subi	r24, 0xFF	; 255
    2d42:	eb 81       	ldd	r30, Y+3	; 0x03
    2d44:	fc 81       	ldd	r31, Y+4	; 0x04
    2d46:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2d48:	81 e0       	ldi	r24, 0x01	; 1
    2d4a:	8a 83       	std	Y+2, r24	; 0x02
    2d4c:	01 c0       	rjmp	.+2      	; 0x2d50 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2d4e:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2d50:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2d52:	29 96       	adiw	r28, 0x09	; 9
    2d54:	0f b6       	in	r0, 0x3f	; 63
    2d56:	f8 94       	cli
    2d58:	de bf       	out	0x3e, r29	; 62
    2d5a:	0f be       	out	0x3f, r0	; 63
    2d5c:	cd bf       	out	0x3d, r28	; 61
    2d5e:	cf 91       	pop	r28
    2d60:	df 91       	pop	r29
    2d62:	08 95       	ret

00002d64 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2d64:	df 93       	push	r29
    2d66:	cf 93       	push	r28
    2d68:	cd b7       	in	r28, 0x3d	; 61
    2d6a:	de b7       	in	r29, 0x3e	; 62
    2d6c:	2e 97       	sbiw	r28, 0x0e	; 14
    2d6e:	0f b6       	in	r0, 0x3f	; 63
    2d70:	f8 94       	cli
    2d72:	de bf       	out	0x3e, r29	; 62
    2d74:	0f be       	out	0x3f, r0	; 63
    2d76:	cd bf       	out	0x3d, r28	; 61
    2d78:	98 87       	std	Y+8, r25	; 0x08
    2d7a:	8f 83       	std	Y+7, r24	; 0x07
    2d7c:	7a 87       	std	Y+10, r23	; 0x0a
    2d7e:	69 87       	std	Y+9, r22	; 0x09
    2d80:	5c 87       	std	Y+12, r21	; 0x0c
    2d82:	4b 87       	std	Y+11, r20	; 0x0b
    2d84:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2d86:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2d88:	0f b6       	in	r0, 0x3f	; 63
    2d8a:	f8 94       	cli
    2d8c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2d8e:	ef 81       	ldd	r30, Y+7	; 0x07
    2d90:	f8 85       	ldd	r31, Y+8	; 0x08
    2d92:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d94:	88 23       	and	r24, r24
    2d96:	09 f4       	brne	.+2      	; 0x2d9a <xQueueGenericReceive+0x36>
    2d98:	3f c0       	rjmp	.+126    	; 0x2e18 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    2d9a:	ef 81       	ldd	r30, Y+7	; 0x07
    2d9c:	f8 85       	ldd	r31, Y+8	; 0x08
    2d9e:	86 81       	ldd	r24, Z+6	; 0x06
    2da0:	97 81       	ldd	r25, Z+7	; 0x07
    2da2:	9a 83       	std	Y+2, r25	; 0x02
    2da4:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2da6:	8f 81       	ldd	r24, Y+7	; 0x07
    2da8:	98 85       	ldd	r25, Y+8	; 0x08
    2daa:	29 85       	ldd	r18, Y+9	; 0x09
    2dac:	3a 85       	ldd	r19, Y+10	; 0x0a
    2dae:	b9 01       	movw	r22, r18
    2db0:	0e 94 97 18 	call	0x312e	; 0x312e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2db4:	8d 85       	ldd	r24, Y+13	; 0x0d
    2db6:	88 23       	and	r24, r24
    2db8:	b1 f4       	brne	.+44     	; 0x2de6 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    2dba:	ef 81       	ldd	r30, Y+7	; 0x07
    2dbc:	f8 85       	ldd	r31, Y+8	; 0x08
    2dbe:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dc0:	81 50       	subi	r24, 0x01	; 1
    2dc2:	ef 81       	ldd	r30, Y+7	; 0x07
    2dc4:	f8 85       	ldd	r31, Y+8	; 0x08
    2dc6:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2dc8:	ef 81       	ldd	r30, Y+7	; 0x07
    2dca:	f8 85       	ldd	r31, Y+8	; 0x08
    2dcc:	80 85       	ldd	r24, Z+8	; 0x08
    2dce:	88 23       	and	r24, r24
    2dd0:	f1 f0       	breq	.+60     	; 0x2e0e <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2dd2:	8f 81       	ldd	r24, Y+7	; 0x07
    2dd4:	98 85       	ldd	r25, Y+8	; 0x08
    2dd6:	08 96       	adiw	r24, 0x08	; 8
    2dd8:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <xTaskRemoveFromEventList>
    2ddc:	81 30       	cpi	r24, 0x01	; 1
    2dde:	b9 f4       	brne	.+46     	; 0x2e0e <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    2de0:	0e 94 0b 14 	call	0x2816	; 0x2816 <vPortYield>
    2de4:	14 c0       	rjmp	.+40     	; 0x2e0e <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    2de6:	ef 81       	ldd	r30, Y+7	; 0x07
    2de8:	f8 85       	ldd	r31, Y+8	; 0x08
    2dea:	89 81       	ldd	r24, Y+1	; 0x01
    2dec:	9a 81       	ldd	r25, Y+2	; 0x02
    2dee:	97 83       	std	Z+7, r25	; 0x07
    2df0:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2df2:	ef 81       	ldd	r30, Y+7	; 0x07
    2df4:	f8 85       	ldd	r31, Y+8	; 0x08
    2df6:	81 89       	ldd	r24, Z+17	; 0x11
    2df8:	88 23       	and	r24, r24
    2dfa:	49 f0       	breq	.+18     	; 0x2e0e <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2dfc:	8f 81       	ldd	r24, Y+7	; 0x07
    2dfe:	98 85       	ldd	r25, Y+8	; 0x08
    2e00:	41 96       	adiw	r24, 0x11	; 17
    2e02:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <xTaskRemoveFromEventList>
    2e06:	88 23       	and	r24, r24
    2e08:	11 f0       	breq	.+4      	; 0x2e0e <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2e0a:	0e 94 0b 14 	call	0x2816	; 0x2816 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    2e0e:	0f 90       	pop	r0
    2e10:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2e12:	81 e0       	ldi	r24, 0x01	; 1
    2e14:	8e 87       	std	Y+14, r24	; 0x0e
    2e16:	5c c0       	rjmp	.+184    	; 0x2ed0 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2e18:	8b 85       	ldd	r24, Y+11	; 0x0b
    2e1a:	9c 85       	ldd	r25, Y+12	; 0x0c
    2e1c:	00 97       	sbiw	r24, 0x00	; 0
    2e1e:	21 f4       	brne	.+8      	; 0x2e28 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2e20:	0f 90       	pop	r0
    2e22:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2e24:	1e 86       	std	Y+14, r1	; 0x0e
    2e26:	54 c0       	rjmp	.+168    	; 0x2ed0 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    2e28:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2a:	88 23       	and	r24, r24
    2e2c:	31 f4       	brne	.+12     	; 0x2e3a <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2e2e:	ce 01       	movw	r24, r28
    2e30:	04 96       	adiw	r24, 0x04	; 4
    2e32:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2e36:	81 e0       	ldi	r24, 0x01	; 1
    2e38:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    2e3a:	0f 90       	pop	r0
    2e3c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2e3e:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2e42:	0f b6       	in	r0, 0x3f	; 63
    2e44:	f8 94       	cli
    2e46:	0f 92       	push	r0
    2e48:	ef 81       	ldd	r30, Y+7	; 0x07
    2e4a:	f8 85       	ldd	r31, Y+8	; 0x08
    2e4c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e4e:	8f 3f       	cpi	r24, 0xFF	; 255
    2e50:	19 f4       	brne	.+6      	; 0x2e58 <xQueueGenericReceive+0xf4>
    2e52:	ef 81       	ldd	r30, Y+7	; 0x07
    2e54:	f8 85       	ldd	r31, Y+8	; 0x08
    2e56:	15 8e       	std	Z+29, r1	; 0x1d
    2e58:	ef 81       	ldd	r30, Y+7	; 0x07
    2e5a:	f8 85       	ldd	r31, Y+8	; 0x08
    2e5c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e5e:	8f 3f       	cpi	r24, 0xFF	; 255
    2e60:	19 f4       	brne	.+6      	; 0x2e68 <xQueueGenericReceive+0x104>
    2e62:	ef 81       	ldd	r30, Y+7	; 0x07
    2e64:	f8 85       	ldd	r31, Y+8	; 0x08
    2e66:	16 8e       	std	Z+30, r1	; 0x1e
    2e68:	0f 90       	pop	r0
    2e6a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2e6c:	ce 01       	movw	r24, r28
    2e6e:	04 96       	adiw	r24, 0x04	; 4
    2e70:	9e 01       	movw	r18, r28
    2e72:	25 5f       	subi	r18, 0xF5	; 245
    2e74:	3f 4f       	sbci	r19, 0xFF	; 255
    2e76:	b9 01       	movw	r22, r18
    2e78:	0e 94 98 1e 	call	0x3d30	; 0x3d30 <xTaskCheckForTimeOut>
    2e7c:	88 23       	and	r24, r24
    2e7e:	09 f5       	brne	.+66     	; 0x2ec2 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2e80:	8f 81       	ldd	r24, Y+7	; 0x07
    2e82:	98 85       	ldd	r25, Y+8	; 0x08
    2e84:	0e 94 33 19 	call	0x3266	; 0x3266 <prvIsQueueEmpty>
    2e88:	88 23       	and	r24, r24
    2e8a:	a1 f0       	breq	.+40     	; 0x2eb4 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2e8c:	8f 81       	ldd	r24, Y+7	; 0x07
    2e8e:	98 85       	ldd	r25, Y+8	; 0x08
    2e90:	41 96       	adiw	r24, 0x11	; 17
    2e92:	2b 85       	ldd	r18, Y+11	; 0x0b
    2e94:	3c 85       	ldd	r19, Y+12	; 0x0c
    2e96:	b9 01       	movw	r22, r18
    2e98:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2e9c:	8f 81       	ldd	r24, Y+7	; 0x07
    2e9e:	98 85       	ldd	r25, Y+8	; 0x08
    2ea0:	0e 94 df 18 	call	0x31be	; 0x31be <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2ea4:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xTaskResumeAll>
    2ea8:	88 23       	and	r24, r24
    2eaa:	09 f0       	breq	.+2      	; 0x2eae <xQueueGenericReceive+0x14a>
    2eac:	6d cf       	rjmp	.-294    	; 0x2d88 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    2eae:	0e 94 0b 14 	call	0x2816	; 0x2816 <vPortYield>
    2eb2:	6a cf       	rjmp	.-300    	; 0x2d88 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2eb4:	8f 81       	ldd	r24, Y+7	; 0x07
    2eb6:	98 85       	ldd	r25, Y+8	; 0x08
    2eb8:	0e 94 df 18 	call	0x31be	; 0x31be <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2ebc:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xTaskResumeAll>
    2ec0:	63 cf       	rjmp	.-314    	; 0x2d88 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2ec2:	8f 81       	ldd	r24, Y+7	; 0x07
    2ec4:	98 85       	ldd	r25, Y+8	; 0x08
    2ec6:	0e 94 df 18 	call	0x31be	; 0x31be <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2eca:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2ece:	1e 86       	std	Y+14, r1	; 0x0e
    2ed0:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    2ed2:	2e 96       	adiw	r28, 0x0e	; 14
    2ed4:	0f b6       	in	r0, 0x3f	; 63
    2ed6:	f8 94       	cli
    2ed8:	de bf       	out	0x3e, r29	; 62
    2eda:	0f be       	out	0x3f, r0	; 63
    2edc:	cd bf       	out	0x3d, r28	; 61
    2ede:	cf 91       	pop	r28
    2ee0:	df 91       	pop	r29
    2ee2:	08 95       	ret

00002ee4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    2ee4:	df 93       	push	r29
    2ee6:	cf 93       	push	r28
    2ee8:	cd b7       	in	r28, 0x3d	; 61
    2eea:	de b7       	in	r29, 0x3e	; 62
    2eec:	28 97       	sbiw	r28, 0x08	; 8
    2eee:	0f b6       	in	r0, 0x3f	; 63
    2ef0:	f8 94       	cli
    2ef2:	de bf       	out	0x3e, r29	; 62
    2ef4:	0f be       	out	0x3f, r0	; 63
    2ef6:	cd bf       	out	0x3d, r28	; 61
    2ef8:	9c 83       	std	Y+4, r25	; 0x04
    2efa:	8b 83       	std	Y+3, r24	; 0x03
    2efc:	7e 83       	std	Y+6, r23	; 0x06
    2efe:	6d 83       	std	Y+5, r22	; 0x05
    2f00:	58 87       	std	Y+8, r21	; 0x08
    2f02:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2f04:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2f06:	eb 81       	ldd	r30, Y+3	; 0x03
    2f08:	fc 81       	ldd	r31, Y+4	; 0x04
    2f0a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f0c:	88 23       	and	r24, r24
    2f0e:	71 f1       	breq	.+92     	; 0x2f6c <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2f10:	8b 81       	ldd	r24, Y+3	; 0x03
    2f12:	9c 81       	ldd	r25, Y+4	; 0x04
    2f14:	2d 81       	ldd	r18, Y+5	; 0x05
    2f16:	3e 81       	ldd	r19, Y+6	; 0x06
    2f18:	b9 01       	movw	r22, r18
    2f1a:	0e 94 97 18 	call	0x312e	; 0x312e <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2f1e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f20:	fc 81       	ldd	r31, Y+4	; 0x04
    2f22:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f24:	81 50       	subi	r24, 0x01	; 1
    2f26:	eb 81       	ldd	r30, Y+3	; 0x03
    2f28:	fc 81       	ldd	r31, Y+4	; 0x04
    2f2a:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2f2c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f2e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f30:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f32:	8f 3f       	cpi	r24, 0xFF	; 255
    2f34:	89 f4       	brne	.+34     	; 0x2f58 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2f36:	eb 81       	ldd	r30, Y+3	; 0x03
    2f38:	fc 81       	ldd	r31, Y+4	; 0x04
    2f3a:	80 85       	ldd	r24, Z+8	; 0x08
    2f3c:	88 23       	and	r24, r24
    2f3e:	99 f0       	breq	.+38     	; 0x2f66 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2f40:	8b 81       	ldd	r24, Y+3	; 0x03
    2f42:	9c 81       	ldd	r25, Y+4	; 0x04
    2f44:	08 96       	adiw	r24, 0x08	; 8
    2f46:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <xTaskRemoveFromEventList>
    2f4a:	88 23       	and	r24, r24
    2f4c:	61 f0       	breq	.+24     	; 0x2f66 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2f4e:	ef 81       	ldd	r30, Y+7	; 0x07
    2f50:	f8 85       	ldd	r31, Y+8	; 0x08
    2f52:	81 e0       	ldi	r24, 0x01	; 1
    2f54:	80 83       	st	Z, r24
    2f56:	07 c0       	rjmp	.+14     	; 0x2f66 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2f58:	eb 81       	ldd	r30, Y+3	; 0x03
    2f5a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f5c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f5e:	8f 5f       	subi	r24, 0xFF	; 255
    2f60:	eb 81       	ldd	r30, Y+3	; 0x03
    2f62:	fc 81       	ldd	r31, Y+4	; 0x04
    2f64:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2f66:	81 e0       	ldi	r24, 0x01	; 1
    2f68:	8a 83       	std	Y+2, r24	; 0x02
    2f6a:	01 c0       	rjmp	.+2      	; 0x2f6e <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    2f6c:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2f6e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2f70:	28 96       	adiw	r28, 0x08	; 8
    2f72:	0f b6       	in	r0, 0x3f	; 63
    2f74:	f8 94       	cli
    2f76:	de bf       	out	0x3e, r29	; 62
    2f78:	0f be       	out	0x3f, r0	; 63
    2f7a:	cd bf       	out	0x3d, r28	; 61
    2f7c:	cf 91       	pop	r28
    2f7e:	df 91       	pop	r29
    2f80:	08 95       	ret

00002f82 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    2f82:	df 93       	push	r29
    2f84:	cf 93       	push	r28
    2f86:	00 d0       	rcall	.+0      	; 0x2f88 <uxQueueMessagesWaiting+0x6>
    2f88:	0f 92       	push	r0
    2f8a:	cd b7       	in	r28, 0x3d	; 61
    2f8c:	de b7       	in	r29, 0x3e	; 62
    2f8e:	9b 83       	std	Y+3, r25	; 0x03
    2f90:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2f92:	0f b6       	in	r0, 0x3f	; 63
    2f94:	f8 94       	cli
    2f96:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2f98:	ea 81       	ldd	r30, Y+2	; 0x02
    2f9a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f9c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f9e:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2fa0:	0f 90       	pop	r0
    2fa2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2fa4:	89 81       	ldd	r24, Y+1	; 0x01
}
    2fa6:	0f 90       	pop	r0
    2fa8:	0f 90       	pop	r0
    2faa:	0f 90       	pop	r0
    2fac:	cf 91       	pop	r28
    2fae:	df 91       	pop	r29
    2fb0:	08 95       	ret

00002fb2 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    2fb2:	df 93       	push	r29
    2fb4:	cf 93       	push	r28
    2fb6:	00 d0       	rcall	.+0      	; 0x2fb8 <uxQueueMessagesWaitingFromISR+0x6>
    2fb8:	0f 92       	push	r0
    2fba:	cd b7       	in	r28, 0x3d	; 61
    2fbc:	de b7       	in	r29, 0x3e	; 62
    2fbe:	9b 83       	std	Y+3, r25	; 0x03
    2fc0:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2fc2:	ea 81       	ldd	r30, Y+2	; 0x02
    2fc4:	fb 81       	ldd	r31, Y+3	; 0x03
    2fc6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2fc8:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    2fca:	89 81       	ldd	r24, Y+1	; 0x01
}
    2fcc:	0f 90       	pop	r0
    2fce:	0f 90       	pop	r0
    2fd0:	0f 90       	pop	r0
    2fd2:	cf 91       	pop	r28
    2fd4:	df 91       	pop	r29
    2fd6:	08 95       	ret

00002fd8 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2fd8:	df 93       	push	r29
    2fda:	cf 93       	push	r28
    2fdc:	00 d0       	rcall	.+0      	; 0x2fde <vQueueDelete+0x6>
    2fde:	cd b7       	in	r28, 0x3d	; 61
    2fe0:	de b7       	in	r29, 0x3e	; 62
    2fe2:	9a 83       	std	Y+2, r25	; 0x02
    2fe4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    2fe6:	e9 81       	ldd	r30, Y+1	; 0x01
    2fe8:	fa 81       	ldd	r31, Y+2	; 0x02
    2fea:	80 81       	ld	r24, Z
    2fec:	91 81       	ldd	r25, Z+1	; 0x01
    2fee:	0e 94 97 10 	call	0x212e	; 0x212e <vPortFree>
	vPortFree( pxQueue );
    2ff2:	89 81       	ldd	r24, Y+1	; 0x01
    2ff4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ff6:	0e 94 97 10 	call	0x212e	; 0x212e <vPortFree>
}
    2ffa:	0f 90       	pop	r0
    2ffc:	0f 90       	pop	r0
    2ffe:	cf 91       	pop	r28
    3000:	df 91       	pop	r29
    3002:	08 95       	ret

00003004 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3004:	df 93       	push	r29
    3006:	cf 93       	push	r28
    3008:	00 d0       	rcall	.+0      	; 0x300a <prvCopyDataToQueue+0x6>
    300a:	00 d0       	rcall	.+0      	; 0x300c <prvCopyDataToQueue+0x8>
    300c:	0f 92       	push	r0
    300e:	cd b7       	in	r28, 0x3d	; 61
    3010:	de b7       	in	r29, 0x3e	; 62
    3012:	9a 83       	std	Y+2, r25	; 0x02
    3014:	89 83       	std	Y+1, r24	; 0x01
    3016:	7c 83       	std	Y+4, r23	; 0x04
    3018:	6b 83       	std	Y+3, r22	; 0x03
    301a:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    301c:	e9 81       	ldd	r30, Y+1	; 0x01
    301e:	fa 81       	ldd	r31, Y+2	; 0x02
    3020:	84 8d       	ldd	r24, Z+28	; 0x1c
    3022:	88 23       	and	r24, r24
    3024:	09 f4       	brne	.+2      	; 0x3028 <prvCopyDataToQueue+0x24>
    3026:	74 c0       	rjmp	.+232    	; 0x3110 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3028:	8d 81       	ldd	r24, Y+5	; 0x05
    302a:	88 23       	and	r24, r24
    302c:	99 f5       	brne	.+102    	; 0x3094 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    302e:	e9 81       	ldd	r30, Y+1	; 0x01
    3030:	fa 81       	ldd	r31, Y+2	; 0x02
    3032:	64 81       	ldd	r22, Z+4	; 0x04
    3034:	75 81       	ldd	r23, Z+5	; 0x05
    3036:	e9 81       	ldd	r30, Y+1	; 0x01
    3038:	fa 81       	ldd	r31, Y+2	; 0x02
    303a:	84 8d       	ldd	r24, Z+28	; 0x1c
    303c:	48 2f       	mov	r20, r24
    303e:	50 e0       	ldi	r21, 0x00	; 0
    3040:	2b 81       	ldd	r18, Y+3	; 0x03
    3042:	3c 81       	ldd	r19, Y+4	; 0x04
    3044:	cb 01       	movw	r24, r22
    3046:	b9 01       	movw	r22, r18
    3048:	0e 94 1d 21 	call	0x423a	; 0x423a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    304c:	e9 81       	ldd	r30, Y+1	; 0x01
    304e:	fa 81       	ldd	r31, Y+2	; 0x02
    3050:	24 81       	ldd	r18, Z+4	; 0x04
    3052:	35 81       	ldd	r19, Z+5	; 0x05
    3054:	e9 81       	ldd	r30, Y+1	; 0x01
    3056:	fa 81       	ldd	r31, Y+2	; 0x02
    3058:	84 8d       	ldd	r24, Z+28	; 0x1c
    305a:	88 2f       	mov	r24, r24
    305c:	90 e0       	ldi	r25, 0x00	; 0
    305e:	82 0f       	add	r24, r18
    3060:	93 1f       	adc	r25, r19
    3062:	e9 81       	ldd	r30, Y+1	; 0x01
    3064:	fa 81       	ldd	r31, Y+2	; 0x02
    3066:	95 83       	std	Z+5, r25	; 0x05
    3068:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    306a:	e9 81       	ldd	r30, Y+1	; 0x01
    306c:	fa 81       	ldd	r31, Y+2	; 0x02
    306e:	24 81       	ldd	r18, Z+4	; 0x04
    3070:	35 81       	ldd	r19, Z+5	; 0x05
    3072:	e9 81       	ldd	r30, Y+1	; 0x01
    3074:	fa 81       	ldd	r31, Y+2	; 0x02
    3076:	82 81       	ldd	r24, Z+2	; 0x02
    3078:	93 81       	ldd	r25, Z+3	; 0x03
    307a:	28 17       	cp	r18, r24
    307c:	39 07       	cpc	r19, r25
    307e:	08 f4       	brcc	.+2      	; 0x3082 <prvCopyDataToQueue+0x7e>
    3080:	47 c0       	rjmp	.+142    	; 0x3110 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3082:	e9 81       	ldd	r30, Y+1	; 0x01
    3084:	fa 81       	ldd	r31, Y+2	; 0x02
    3086:	80 81       	ld	r24, Z
    3088:	91 81       	ldd	r25, Z+1	; 0x01
    308a:	e9 81       	ldd	r30, Y+1	; 0x01
    308c:	fa 81       	ldd	r31, Y+2	; 0x02
    308e:	95 83       	std	Z+5, r25	; 0x05
    3090:	84 83       	std	Z+4, r24	; 0x04
    3092:	3e c0       	rjmp	.+124    	; 0x3110 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3094:	e9 81       	ldd	r30, Y+1	; 0x01
    3096:	fa 81       	ldd	r31, Y+2	; 0x02
    3098:	66 81       	ldd	r22, Z+6	; 0x06
    309a:	77 81       	ldd	r23, Z+7	; 0x07
    309c:	e9 81       	ldd	r30, Y+1	; 0x01
    309e:	fa 81       	ldd	r31, Y+2	; 0x02
    30a0:	84 8d       	ldd	r24, Z+28	; 0x1c
    30a2:	48 2f       	mov	r20, r24
    30a4:	50 e0       	ldi	r21, 0x00	; 0
    30a6:	2b 81       	ldd	r18, Y+3	; 0x03
    30a8:	3c 81       	ldd	r19, Y+4	; 0x04
    30aa:	cb 01       	movw	r24, r22
    30ac:	b9 01       	movw	r22, r18
    30ae:	0e 94 1d 21 	call	0x423a	; 0x423a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    30b2:	e9 81       	ldd	r30, Y+1	; 0x01
    30b4:	fa 81       	ldd	r31, Y+2	; 0x02
    30b6:	26 81       	ldd	r18, Z+6	; 0x06
    30b8:	37 81       	ldd	r19, Z+7	; 0x07
    30ba:	e9 81       	ldd	r30, Y+1	; 0x01
    30bc:	fa 81       	ldd	r31, Y+2	; 0x02
    30be:	84 8d       	ldd	r24, Z+28	; 0x1c
    30c0:	88 2f       	mov	r24, r24
    30c2:	90 e0       	ldi	r25, 0x00	; 0
    30c4:	90 95       	com	r25
    30c6:	81 95       	neg	r24
    30c8:	9f 4f       	sbci	r25, 0xFF	; 255
    30ca:	82 0f       	add	r24, r18
    30cc:	93 1f       	adc	r25, r19
    30ce:	e9 81       	ldd	r30, Y+1	; 0x01
    30d0:	fa 81       	ldd	r31, Y+2	; 0x02
    30d2:	97 83       	std	Z+7, r25	; 0x07
    30d4:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    30d6:	e9 81       	ldd	r30, Y+1	; 0x01
    30d8:	fa 81       	ldd	r31, Y+2	; 0x02
    30da:	26 81       	ldd	r18, Z+6	; 0x06
    30dc:	37 81       	ldd	r19, Z+7	; 0x07
    30de:	e9 81       	ldd	r30, Y+1	; 0x01
    30e0:	fa 81       	ldd	r31, Y+2	; 0x02
    30e2:	80 81       	ld	r24, Z
    30e4:	91 81       	ldd	r25, Z+1	; 0x01
    30e6:	28 17       	cp	r18, r24
    30e8:	39 07       	cpc	r19, r25
    30ea:	90 f4       	brcc	.+36     	; 0x3110 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    30ec:	e9 81       	ldd	r30, Y+1	; 0x01
    30ee:	fa 81       	ldd	r31, Y+2	; 0x02
    30f0:	22 81       	ldd	r18, Z+2	; 0x02
    30f2:	33 81       	ldd	r19, Z+3	; 0x03
    30f4:	e9 81       	ldd	r30, Y+1	; 0x01
    30f6:	fa 81       	ldd	r31, Y+2	; 0x02
    30f8:	84 8d       	ldd	r24, Z+28	; 0x1c
    30fa:	88 2f       	mov	r24, r24
    30fc:	90 e0       	ldi	r25, 0x00	; 0
    30fe:	90 95       	com	r25
    3100:	81 95       	neg	r24
    3102:	9f 4f       	sbci	r25, 0xFF	; 255
    3104:	82 0f       	add	r24, r18
    3106:	93 1f       	adc	r25, r19
    3108:	e9 81       	ldd	r30, Y+1	; 0x01
    310a:	fa 81       	ldd	r31, Y+2	; 0x02
    310c:	97 83       	std	Z+7, r25	; 0x07
    310e:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    3110:	e9 81       	ldd	r30, Y+1	; 0x01
    3112:	fa 81       	ldd	r31, Y+2	; 0x02
    3114:	82 8d       	ldd	r24, Z+26	; 0x1a
    3116:	8f 5f       	subi	r24, 0xFF	; 255
    3118:	e9 81       	ldd	r30, Y+1	; 0x01
    311a:	fa 81       	ldd	r31, Y+2	; 0x02
    311c:	82 8f       	std	Z+26, r24	; 0x1a
}
    311e:	0f 90       	pop	r0
    3120:	0f 90       	pop	r0
    3122:	0f 90       	pop	r0
    3124:	0f 90       	pop	r0
    3126:	0f 90       	pop	r0
    3128:	cf 91       	pop	r28
    312a:	df 91       	pop	r29
    312c:	08 95       	ret

0000312e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    312e:	df 93       	push	r29
    3130:	cf 93       	push	r28
    3132:	00 d0       	rcall	.+0      	; 0x3134 <prvCopyDataFromQueue+0x6>
    3134:	00 d0       	rcall	.+0      	; 0x3136 <prvCopyDataFromQueue+0x8>
    3136:	cd b7       	in	r28, 0x3d	; 61
    3138:	de b7       	in	r29, 0x3e	; 62
    313a:	9a 83       	std	Y+2, r25	; 0x02
    313c:	89 83       	std	Y+1, r24	; 0x01
    313e:	7c 83       	std	Y+4, r23	; 0x04
    3140:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    3142:	e9 81       	ldd	r30, Y+1	; 0x01
    3144:	fa 81       	ldd	r31, Y+2	; 0x02
    3146:	80 81       	ld	r24, Z
    3148:	91 81       	ldd	r25, Z+1	; 0x01
    314a:	00 97       	sbiw	r24, 0x00	; 0
    314c:	89 f1       	breq	.+98     	; 0x31b0 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    314e:	e9 81       	ldd	r30, Y+1	; 0x01
    3150:	fa 81       	ldd	r31, Y+2	; 0x02
    3152:	26 81       	ldd	r18, Z+6	; 0x06
    3154:	37 81       	ldd	r19, Z+7	; 0x07
    3156:	e9 81       	ldd	r30, Y+1	; 0x01
    3158:	fa 81       	ldd	r31, Y+2	; 0x02
    315a:	84 8d       	ldd	r24, Z+28	; 0x1c
    315c:	88 2f       	mov	r24, r24
    315e:	90 e0       	ldi	r25, 0x00	; 0
    3160:	82 0f       	add	r24, r18
    3162:	93 1f       	adc	r25, r19
    3164:	e9 81       	ldd	r30, Y+1	; 0x01
    3166:	fa 81       	ldd	r31, Y+2	; 0x02
    3168:	97 83       	std	Z+7, r25	; 0x07
    316a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    316c:	e9 81       	ldd	r30, Y+1	; 0x01
    316e:	fa 81       	ldd	r31, Y+2	; 0x02
    3170:	26 81       	ldd	r18, Z+6	; 0x06
    3172:	37 81       	ldd	r19, Z+7	; 0x07
    3174:	e9 81       	ldd	r30, Y+1	; 0x01
    3176:	fa 81       	ldd	r31, Y+2	; 0x02
    3178:	82 81       	ldd	r24, Z+2	; 0x02
    317a:	93 81       	ldd	r25, Z+3	; 0x03
    317c:	28 17       	cp	r18, r24
    317e:	39 07       	cpc	r19, r25
    3180:	40 f0       	brcs	.+16     	; 0x3192 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    3182:	e9 81       	ldd	r30, Y+1	; 0x01
    3184:	fa 81       	ldd	r31, Y+2	; 0x02
    3186:	80 81       	ld	r24, Z
    3188:	91 81       	ldd	r25, Z+1	; 0x01
    318a:	e9 81       	ldd	r30, Y+1	; 0x01
    318c:	fa 81       	ldd	r31, Y+2	; 0x02
    318e:	97 83       	std	Z+7, r25	; 0x07
    3190:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3192:	e9 81       	ldd	r30, Y+1	; 0x01
    3194:	fa 81       	ldd	r31, Y+2	; 0x02
    3196:	46 81       	ldd	r20, Z+6	; 0x06
    3198:	57 81       	ldd	r21, Z+7	; 0x07
    319a:	e9 81       	ldd	r30, Y+1	; 0x01
    319c:	fa 81       	ldd	r31, Y+2	; 0x02
    319e:	84 8d       	ldd	r24, Z+28	; 0x1c
    31a0:	28 2f       	mov	r18, r24
    31a2:	30 e0       	ldi	r19, 0x00	; 0
    31a4:	8b 81       	ldd	r24, Y+3	; 0x03
    31a6:	9c 81       	ldd	r25, Y+4	; 0x04
    31a8:	ba 01       	movw	r22, r20
    31aa:	a9 01       	movw	r20, r18
    31ac:	0e 94 1d 21 	call	0x423a	; 0x423a <memcpy>
	}
}
    31b0:	0f 90       	pop	r0
    31b2:	0f 90       	pop	r0
    31b4:	0f 90       	pop	r0
    31b6:	0f 90       	pop	r0
    31b8:	cf 91       	pop	r28
    31ba:	df 91       	pop	r29
    31bc:	08 95       	ret

000031be <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    31be:	df 93       	push	r29
    31c0:	cf 93       	push	r28
    31c2:	00 d0       	rcall	.+0      	; 0x31c4 <prvUnlockQueue+0x6>
    31c4:	cd b7       	in	r28, 0x3d	; 61
    31c6:	de b7       	in	r29, 0x3e	; 62
    31c8:	9a 83       	std	Y+2, r25	; 0x02
    31ca:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    31cc:	0f b6       	in	r0, 0x3f	; 63
    31ce:	f8 94       	cli
    31d0:	0f 92       	push	r0
    31d2:	15 c0       	rjmp	.+42     	; 0x31fe <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    31d4:	e9 81       	ldd	r30, Y+1	; 0x01
    31d6:	fa 81       	ldd	r31, Y+2	; 0x02
    31d8:	81 89       	ldd	r24, Z+17	; 0x11
    31da:	88 23       	and	r24, r24
    31dc:	a9 f0       	breq	.+42     	; 0x3208 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    31de:	89 81       	ldd	r24, Y+1	; 0x01
    31e0:	9a 81       	ldd	r25, Y+2	; 0x02
    31e2:	41 96       	adiw	r24, 0x11	; 17
    31e4:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <xTaskRemoveFromEventList>
    31e8:	88 23       	and	r24, r24
    31ea:	11 f0       	breq	.+4      	; 0x31f0 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    31ec:	0e 94 f5 1e 	call	0x3dea	; 0x3dea <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    31f0:	e9 81       	ldd	r30, Y+1	; 0x01
    31f2:	fa 81       	ldd	r31, Y+2	; 0x02
    31f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    31f6:	81 50       	subi	r24, 0x01	; 1
    31f8:	e9 81       	ldd	r30, Y+1	; 0x01
    31fa:	fa 81       	ldd	r31, Y+2	; 0x02
    31fc:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    31fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3200:	fa 81       	ldd	r31, Y+2	; 0x02
    3202:	86 8d       	ldd	r24, Z+30	; 0x1e
    3204:	18 16       	cp	r1, r24
    3206:	34 f3       	brlt	.-52     	; 0x31d4 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3208:	e9 81       	ldd	r30, Y+1	; 0x01
    320a:	fa 81       	ldd	r31, Y+2	; 0x02
    320c:	8f ef       	ldi	r24, 0xFF	; 255
    320e:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3210:	0f 90       	pop	r0
    3212:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3214:	0f b6       	in	r0, 0x3f	; 63
    3216:	f8 94       	cli
    3218:	0f 92       	push	r0
    321a:	15 c0       	rjmp	.+42     	; 0x3246 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    321c:	e9 81       	ldd	r30, Y+1	; 0x01
    321e:	fa 81       	ldd	r31, Y+2	; 0x02
    3220:	80 85       	ldd	r24, Z+8	; 0x08
    3222:	88 23       	and	r24, r24
    3224:	a9 f0       	breq	.+42     	; 0x3250 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3226:	89 81       	ldd	r24, Y+1	; 0x01
    3228:	9a 81       	ldd	r25, Y+2	; 0x02
    322a:	08 96       	adiw	r24, 0x08	; 8
    322c:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <xTaskRemoveFromEventList>
    3230:	88 23       	and	r24, r24
    3232:	11 f0       	breq	.+4      	; 0x3238 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    3234:	0e 94 f5 1e 	call	0x3dea	; 0x3dea <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    3238:	e9 81       	ldd	r30, Y+1	; 0x01
    323a:	fa 81       	ldd	r31, Y+2	; 0x02
    323c:	85 8d       	ldd	r24, Z+29	; 0x1d
    323e:	81 50       	subi	r24, 0x01	; 1
    3240:	e9 81       	ldd	r30, Y+1	; 0x01
    3242:	fa 81       	ldd	r31, Y+2	; 0x02
    3244:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3246:	e9 81       	ldd	r30, Y+1	; 0x01
    3248:	fa 81       	ldd	r31, Y+2	; 0x02
    324a:	85 8d       	ldd	r24, Z+29	; 0x1d
    324c:	18 16       	cp	r1, r24
    324e:	34 f3       	brlt	.-52     	; 0x321c <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3250:	e9 81       	ldd	r30, Y+1	; 0x01
    3252:	fa 81       	ldd	r31, Y+2	; 0x02
    3254:	8f ef       	ldi	r24, 0xFF	; 255
    3256:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    3258:	0f 90       	pop	r0
    325a:	0f be       	out	0x3f, r0	; 63
}
    325c:	0f 90       	pop	r0
    325e:	0f 90       	pop	r0
    3260:	cf 91       	pop	r28
    3262:	df 91       	pop	r29
    3264:	08 95       	ret

00003266 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    3266:	df 93       	push	r29
    3268:	cf 93       	push	r28
    326a:	00 d0       	rcall	.+0      	; 0x326c <prvIsQueueEmpty+0x6>
    326c:	0f 92       	push	r0
    326e:	cd b7       	in	r28, 0x3d	; 61
    3270:	de b7       	in	r29, 0x3e	; 62
    3272:	9b 83       	std	Y+3, r25	; 0x03
    3274:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3276:	0f b6       	in	r0, 0x3f	; 63
    3278:	f8 94       	cli
    327a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    327c:	ea 81       	ldd	r30, Y+2	; 0x02
    327e:	fb 81       	ldd	r31, Y+3	; 0x03
    3280:	82 8d       	ldd	r24, Z+26	; 0x1a
    3282:	19 82       	std	Y+1, r1	; 0x01
    3284:	88 23       	and	r24, r24
    3286:	11 f4       	brne	.+4      	; 0x328c <prvIsQueueEmpty+0x26>
    3288:	81 e0       	ldi	r24, 0x01	; 1
    328a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    328c:	0f 90       	pop	r0
    328e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3290:	89 81       	ldd	r24, Y+1	; 0x01
}
    3292:	0f 90       	pop	r0
    3294:	0f 90       	pop	r0
    3296:	0f 90       	pop	r0
    3298:	cf 91       	pop	r28
    329a:	df 91       	pop	r29
    329c:	08 95       	ret

0000329e <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    329e:	df 93       	push	r29
    32a0:	cf 93       	push	r28
    32a2:	00 d0       	rcall	.+0      	; 0x32a4 <xQueueIsQueueEmptyFromISR+0x6>
    32a4:	0f 92       	push	r0
    32a6:	cd b7       	in	r28, 0x3d	; 61
    32a8:	de b7       	in	r29, 0x3e	; 62
    32aa:	9b 83       	std	Y+3, r25	; 0x03
    32ac:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    32ae:	ea 81       	ldd	r30, Y+2	; 0x02
    32b0:	fb 81       	ldd	r31, Y+3	; 0x03
    32b2:	82 8d       	ldd	r24, Z+26	; 0x1a
    32b4:	19 82       	std	Y+1, r1	; 0x01
    32b6:	88 23       	and	r24, r24
    32b8:	11 f4       	brne	.+4      	; 0x32be <xQueueIsQueueEmptyFromISR+0x20>
    32ba:	81 e0       	ldi	r24, 0x01	; 1
    32bc:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    32be:	89 81       	ldd	r24, Y+1	; 0x01
}
    32c0:	0f 90       	pop	r0
    32c2:	0f 90       	pop	r0
    32c4:	0f 90       	pop	r0
    32c6:	cf 91       	pop	r28
    32c8:	df 91       	pop	r29
    32ca:	08 95       	ret

000032cc <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    32cc:	df 93       	push	r29
    32ce:	cf 93       	push	r28
    32d0:	00 d0       	rcall	.+0      	; 0x32d2 <prvIsQueueFull+0x6>
    32d2:	0f 92       	push	r0
    32d4:	cd b7       	in	r28, 0x3d	; 61
    32d6:	de b7       	in	r29, 0x3e	; 62
    32d8:	9b 83       	std	Y+3, r25	; 0x03
    32da:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    32dc:	0f b6       	in	r0, 0x3f	; 63
    32de:	f8 94       	cli
    32e0:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    32e2:	ea 81       	ldd	r30, Y+2	; 0x02
    32e4:	fb 81       	ldd	r31, Y+3	; 0x03
    32e6:	92 8d       	ldd	r25, Z+26	; 0x1a
    32e8:	ea 81       	ldd	r30, Y+2	; 0x02
    32ea:	fb 81       	ldd	r31, Y+3	; 0x03
    32ec:	83 8d       	ldd	r24, Z+27	; 0x1b
    32ee:	19 82       	std	Y+1, r1	; 0x01
    32f0:	98 17       	cp	r25, r24
    32f2:	11 f4       	brne	.+4      	; 0x32f8 <prvIsQueueFull+0x2c>
    32f4:	81 e0       	ldi	r24, 0x01	; 1
    32f6:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    32f8:	0f 90       	pop	r0
    32fa:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    32fc:	89 81       	ldd	r24, Y+1	; 0x01
}
    32fe:	0f 90       	pop	r0
    3300:	0f 90       	pop	r0
    3302:	0f 90       	pop	r0
    3304:	cf 91       	pop	r28
    3306:	df 91       	pop	r29
    3308:	08 95       	ret

0000330a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    330a:	df 93       	push	r29
    330c:	cf 93       	push	r28
    330e:	00 d0       	rcall	.+0      	; 0x3310 <xQueueIsQueueFullFromISR+0x6>
    3310:	0f 92       	push	r0
    3312:	cd b7       	in	r28, 0x3d	; 61
    3314:	de b7       	in	r29, 0x3e	; 62
    3316:	9b 83       	std	Y+3, r25	; 0x03
    3318:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    331a:	ea 81       	ldd	r30, Y+2	; 0x02
    331c:	fb 81       	ldd	r31, Y+3	; 0x03
    331e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3320:	ea 81       	ldd	r30, Y+2	; 0x02
    3322:	fb 81       	ldd	r31, Y+3	; 0x03
    3324:	83 8d       	ldd	r24, Z+27	; 0x1b
    3326:	19 82       	std	Y+1, r1	; 0x01
    3328:	98 17       	cp	r25, r24
    332a:	11 f4       	brne	.+4      	; 0x3330 <xQueueIsQueueFullFromISR+0x26>
    332c:	81 e0       	ldi	r24, 0x01	; 1
    332e:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3330:	89 81       	ldd	r24, Y+1	; 0x01
}
    3332:	0f 90       	pop	r0
    3334:	0f 90       	pop	r0
    3336:	0f 90       	pop	r0
    3338:	cf 91       	pop	r28
    333a:	df 91       	pop	r29
    333c:	08 95       	ret

0000333e <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    333e:	af 92       	push	r10
    3340:	bf 92       	push	r11
    3342:	cf 92       	push	r12
    3344:	df 92       	push	r13
    3346:	ef 92       	push	r14
    3348:	ff 92       	push	r15
    334a:	0f 93       	push	r16
    334c:	1f 93       	push	r17
    334e:	df 93       	push	r29
    3350:	cf 93       	push	r28
    3352:	cd b7       	in	r28, 0x3d	; 61
    3354:	de b7       	in	r29, 0x3e	; 62
    3356:	64 97       	sbiw	r28, 0x14	; 20
    3358:	0f b6       	in	r0, 0x3f	; 63
    335a:	f8 94       	cli
    335c:	de bf       	out	0x3e, r29	; 62
    335e:	0f be       	out	0x3f, r0	; 63
    3360:	cd bf       	out	0x3d, r28	; 61
    3362:	9f 83       	std	Y+7, r25	; 0x07
    3364:	8e 83       	std	Y+6, r24	; 0x06
    3366:	79 87       	std	Y+9, r23	; 0x09
    3368:	68 87       	std	Y+8, r22	; 0x08
    336a:	5b 87       	std	Y+11, r21	; 0x0b
    336c:	4a 87       	std	Y+10, r20	; 0x0a
    336e:	3d 87       	std	Y+13, r19	; 0x0d
    3370:	2c 87       	std	Y+12, r18	; 0x0c
    3372:	0e 87       	std	Y+14, r16	; 0x0e
    3374:	f8 8a       	std	Y+16, r15	; 0x10
    3376:	ef 86       	std	Y+15, r14	; 0x0f
    3378:	da 8a       	std	Y+18, r13	; 0x12
    337a:	c9 8a       	std	Y+17, r12	; 0x11
    337c:	bc 8a       	std	Y+20, r11	; 0x14
    337e:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    3380:	8a 85       	ldd	r24, Y+10	; 0x0a
    3382:	9b 85       	ldd	r25, Y+11	; 0x0b
    3384:	29 89       	ldd	r18, Y+17	; 0x11
    3386:	3a 89       	ldd	r19, Y+18	; 0x12
    3388:	b9 01       	movw	r22, r18
    338a:	0e 94 24 20 	call	0x4048	; 0x4048 <prvAllocateTCBAndStack>
    338e:	9c 83       	std	Y+4, r25	; 0x04
    3390:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    3392:	8b 81       	ldd	r24, Y+3	; 0x03
    3394:	9c 81       	ldd	r25, Y+4	; 0x04
    3396:	00 97       	sbiw	r24, 0x00	; 0
    3398:	09 f4       	brne	.+2      	; 0x339c <xTaskGenericCreate+0x5e>
    339a:	99 c0       	rjmp	.+306    	; 0x34ce <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    339c:	eb 81       	ldd	r30, Y+3	; 0x03
    339e:	fc 81       	ldd	r31, Y+4	; 0x04
    33a0:	27 89       	ldd	r18, Z+23	; 0x17
    33a2:	30 8d       	ldd	r19, Z+24	; 0x18
    33a4:	8a 85       	ldd	r24, Y+10	; 0x0a
    33a6:	9b 85       	ldd	r25, Y+11	; 0x0b
    33a8:	01 97       	sbiw	r24, 0x01	; 1
    33aa:	82 0f       	add	r24, r18
    33ac:	93 1f       	adc	r25, r19
    33ae:	9a 83       	std	Y+2, r25	; 0x02
    33b0:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    33b2:	8b 81       	ldd	r24, Y+3	; 0x03
    33b4:	9c 81       	ldd	r25, Y+4	; 0x04
    33b6:	28 85       	ldd	r18, Y+8	; 0x08
    33b8:	39 85       	ldd	r19, Y+9	; 0x09
    33ba:	eb 89       	ldd	r30, Y+19	; 0x13
    33bc:	fc 89       	ldd	r31, Y+20	; 0x14
    33be:	aa 85       	ldd	r26, Y+10	; 0x0a
    33c0:	bb 85       	ldd	r27, Y+11	; 0x0b
    33c2:	b9 01       	movw	r22, r18
    33c4:	4e 85       	ldd	r20, Y+14	; 0x0e
    33c6:	9f 01       	movw	r18, r30
    33c8:	8d 01       	movw	r16, r26
    33ca:	0e 94 09 1f 	call	0x3e12	; 0x3e12 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    33ce:	89 81       	ldd	r24, Y+1	; 0x01
    33d0:	9a 81       	ldd	r25, Y+2	; 0x02
    33d2:	2e 81       	ldd	r18, Y+6	; 0x06
    33d4:	3f 81       	ldd	r19, Y+7	; 0x07
    33d6:	4c 85       	ldd	r20, Y+12	; 0x0c
    33d8:	5d 85       	ldd	r21, Y+13	; 0x0d
    33da:	b9 01       	movw	r22, r18
    33dc:	0e 94 4c 12 	call	0x2498	; 0x2498 <pxPortInitialiseStack>
    33e0:	eb 81       	ldd	r30, Y+3	; 0x03
    33e2:	fc 81       	ldd	r31, Y+4	; 0x04
    33e4:	91 83       	std	Z+1, r25	; 0x01
    33e6:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    33e8:	8f 85       	ldd	r24, Y+15	; 0x0f
    33ea:	98 89       	ldd	r25, Y+16	; 0x10
    33ec:	00 97       	sbiw	r24, 0x00	; 0
    33ee:	31 f0       	breq	.+12     	; 0x33fc <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    33f0:	ef 85       	ldd	r30, Y+15	; 0x0f
    33f2:	f8 89       	ldd	r31, Y+16	; 0x10
    33f4:	8b 81       	ldd	r24, Y+3	; 0x03
    33f6:	9c 81       	ldd	r25, Y+4	; 0x04
    33f8:	91 83       	std	Z+1, r25	; 0x01
    33fa:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    33fc:	0f b6       	in	r0, 0x3f	; 63
    33fe:	f8 94       	cli
    3400:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3402:	80 91 a9 05 	lds	r24, 0x05A9
    3406:	8f 5f       	subi	r24, 0xFF	; 255
    3408:	80 93 a9 05 	sts	0x05A9, r24
			if( pxCurrentTCB == NULL )
    340c:	80 91 a6 05 	lds	r24, 0x05A6
    3410:	90 91 a7 05 	lds	r25, 0x05A7
    3414:	00 97       	sbiw	r24, 0x00	; 0
    3416:	69 f4       	brne	.+26     	; 0x3432 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    3418:	8b 81       	ldd	r24, Y+3	; 0x03
    341a:	9c 81       	ldd	r25, Y+4	; 0x04
    341c:	90 93 a7 05 	sts	0x05A7, r25
    3420:	80 93 a6 05 	sts	0x05A6, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    3424:	80 91 a9 05 	lds	r24, 0x05A9
    3428:	81 30       	cpi	r24, 0x01	; 1
    342a:	a9 f4       	brne	.+42     	; 0x3456 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    342c:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <prvInitialiseTaskLists>
    3430:	12 c0       	rjmp	.+36     	; 0x3456 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    3432:	80 91 ae 05 	lds	r24, 0x05AE
    3436:	88 23       	and	r24, r24
    3438:	71 f4       	brne	.+28     	; 0x3456 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    343a:	e0 91 a6 05 	lds	r30, 0x05A6
    343e:	f0 91 a7 05 	lds	r31, 0x05A7
    3442:	96 89       	ldd	r25, Z+22	; 0x16
    3444:	8e 85       	ldd	r24, Y+14	; 0x0e
    3446:	89 17       	cp	r24, r25
    3448:	30 f0       	brcs	.+12     	; 0x3456 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    344a:	8b 81       	ldd	r24, Y+3	; 0x03
    344c:	9c 81       	ldd	r25, Y+4	; 0x04
    344e:	90 93 a7 05 	sts	0x05A7, r25
    3452:	80 93 a6 05 	sts	0x05A6, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    3456:	eb 81       	ldd	r30, Y+3	; 0x03
    3458:	fc 81       	ldd	r31, Y+4	; 0x04
    345a:	96 89       	ldd	r25, Z+22	; 0x16
    345c:	80 91 ac 05 	lds	r24, 0x05AC
    3460:	89 17       	cp	r24, r25
    3462:	28 f4       	brcc	.+10     	; 0x346e <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    3464:	eb 81       	ldd	r30, Y+3	; 0x03
    3466:	fc 81       	ldd	r31, Y+4	; 0x04
    3468:	86 89       	ldd	r24, Z+22	; 0x16
    346a:	80 93 ac 05 	sts	0x05AC, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    346e:	80 91 b3 05 	lds	r24, 0x05B3
    3472:	8f 5f       	subi	r24, 0xFF	; 255
    3474:	80 93 b3 05 	sts	0x05B3, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    3478:	eb 81       	ldd	r30, Y+3	; 0x03
    347a:	fc 81       	ldd	r31, Y+4	; 0x04
    347c:	96 89       	ldd	r25, Z+22	; 0x16
    347e:	80 91 ad 05 	lds	r24, 0x05AD
    3482:	89 17       	cp	r24, r25
    3484:	28 f4       	brcc	.+10     	; 0x3490 <xTaskGenericCreate+0x152>
    3486:	eb 81       	ldd	r30, Y+3	; 0x03
    3488:	fc 81       	ldd	r31, Y+4	; 0x04
    348a:	86 89       	ldd	r24, Z+22	; 0x16
    348c:	80 93 ad 05 	sts	0x05AD, r24
    3490:	eb 81       	ldd	r30, Y+3	; 0x03
    3492:	fc 81       	ldd	r31, Y+4	; 0x04
    3494:	86 89       	ldd	r24, Z+22	; 0x16
    3496:	28 2f       	mov	r18, r24
    3498:	30 e0       	ldi	r19, 0x00	; 0
    349a:	c9 01       	movw	r24, r18
    349c:	88 0f       	add	r24, r24
    349e:	99 1f       	adc	r25, r25
    34a0:	88 0f       	add	r24, r24
    34a2:	99 1f       	adc	r25, r25
    34a4:	88 0f       	add	r24, r24
    34a6:	99 1f       	adc	r25, r25
    34a8:	82 0f       	add	r24, r18
    34aa:	93 1f       	adc	r25, r19
    34ac:	ac 01       	movw	r20, r24
    34ae:	4c 54       	subi	r20, 0x4C	; 76
    34b0:	5a 4f       	sbci	r21, 0xFA	; 250
    34b2:	8b 81       	ldd	r24, Y+3	; 0x03
    34b4:	9c 81       	ldd	r25, Y+4	; 0x04
    34b6:	9c 01       	movw	r18, r24
    34b8:	2e 5f       	subi	r18, 0xFE	; 254
    34ba:	3f 4f       	sbci	r19, 0xFF	; 255
    34bc:	ca 01       	movw	r24, r20
    34be:	b9 01       	movw	r22, r18
    34c0:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vListInsertEnd>

			xReturn = pdPASS;
    34c4:	81 e0       	ldi	r24, 0x01	; 1
    34c6:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    34c8:	0f 90       	pop	r0
    34ca:	0f be       	out	0x3f, r0	; 63
    34cc:	02 c0       	rjmp	.+4      	; 0x34d2 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    34ce:	8f ef       	ldi	r24, 0xFF	; 255
    34d0:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    34d2:	8d 81       	ldd	r24, Y+5	; 0x05
    34d4:	81 30       	cpi	r24, 0x01	; 1
    34d6:	71 f4       	brne	.+28     	; 0x34f4 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    34d8:	80 91 ae 05 	lds	r24, 0x05AE
    34dc:	88 23       	and	r24, r24
    34de:	51 f0       	breq	.+20     	; 0x34f4 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    34e0:	e0 91 a6 05 	lds	r30, 0x05A6
    34e4:	f0 91 a7 05 	lds	r31, 0x05A7
    34e8:	96 89       	ldd	r25, Z+22	; 0x16
    34ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    34ec:	98 17       	cp	r25, r24
    34ee:	10 f4       	brcc	.+4      	; 0x34f4 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    34f0:	0e 94 0b 14 	call	0x2816	; 0x2816 <vPortYield>
			}
		}
	}

	return xReturn;
    34f4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    34f6:	64 96       	adiw	r28, 0x14	; 20
    34f8:	0f b6       	in	r0, 0x3f	; 63
    34fa:	f8 94       	cli
    34fc:	de bf       	out	0x3e, r29	; 62
    34fe:	0f be       	out	0x3f, r0	; 63
    3500:	cd bf       	out	0x3d, r28	; 61
    3502:	cf 91       	pop	r28
    3504:	df 91       	pop	r29
    3506:	1f 91       	pop	r17
    3508:	0f 91       	pop	r16
    350a:	ff 90       	pop	r15
    350c:	ef 90       	pop	r14
    350e:	df 90       	pop	r13
    3510:	cf 90       	pop	r12
    3512:	bf 90       	pop	r11
    3514:	af 90       	pop	r10
    3516:	08 95       	ret

00003518 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    3518:	df 93       	push	r29
    351a:	cf 93       	push	r28
    351c:	00 d0       	rcall	.+0      	; 0x351e <vTaskDelete+0x6>
    351e:	00 d0       	rcall	.+0      	; 0x3520 <vTaskDelete+0x8>
    3520:	00 d0       	rcall	.+0      	; 0x3522 <vTaskDelete+0xa>
    3522:	cd b7       	in	r28, 0x3d	; 61
    3524:	de b7       	in	r29, 0x3e	; 62
    3526:	9c 83       	std	Y+4, r25	; 0x04
    3528:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    352a:	0f b6       	in	r0, 0x3f	; 63
    352c:	f8 94       	cli
    352e:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    3530:	20 91 a6 05 	lds	r18, 0x05A6
    3534:	30 91 a7 05 	lds	r19, 0x05A7
    3538:	8b 81       	ldd	r24, Y+3	; 0x03
    353a:	9c 81       	ldd	r25, Y+4	; 0x04
    353c:	82 17       	cp	r24, r18
    353e:	93 07       	cpc	r25, r19
    3540:	11 f4       	brne	.+4      	; 0x3546 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    3542:	1c 82       	std	Y+4, r1	; 0x04
    3544:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    3546:	8b 81       	ldd	r24, Y+3	; 0x03
    3548:	9c 81       	ldd	r25, Y+4	; 0x04
    354a:	00 97       	sbiw	r24, 0x00	; 0
    354c:	39 f4       	brne	.+14     	; 0x355c <vTaskDelete+0x44>
    354e:	80 91 a6 05 	lds	r24, 0x05A6
    3552:	90 91 a7 05 	lds	r25, 0x05A7
    3556:	9e 83       	std	Y+6, r25	; 0x06
    3558:	8d 83       	std	Y+5, r24	; 0x05
    355a:	04 c0       	rjmp	.+8      	; 0x3564 <vTaskDelete+0x4c>
    355c:	8b 81       	ldd	r24, Y+3	; 0x03
    355e:	9c 81       	ldd	r25, Y+4	; 0x04
    3560:	9e 83       	std	Y+6, r25	; 0x06
    3562:	8d 83       	std	Y+5, r24	; 0x05
    3564:	8d 81       	ldd	r24, Y+5	; 0x05
    3566:	9e 81       	ldd	r25, Y+6	; 0x06
    3568:	9a 83       	std	Y+2, r25	; 0x02
    356a:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    356c:	89 81       	ldd	r24, Y+1	; 0x01
    356e:	9a 81       	ldd	r25, Y+2	; 0x02
    3570:	02 96       	adiw	r24, 0x02	; 2
    3572:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    3576:	e9 81       	ldd	r30, Y+1	; 0x01
    3578:	fa 81       	ldd	r31, Y+2	; 0x02
    357a:	84 89       	ldd	r24, Z+20	; 0x14
    357c:	95 89       	ldd	r25, Z+21	; 0x15
    357e:	00 97       	sbiw	r24, 0x00	; 0
    3580:	29 f0       	breq	.+10     	; 0x358c <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    3582:	89 81       	ldd	r24, Y+1	; 0x01
    3584:	9a 81       	ldd	r25, Y+2	; 0x02
    3586:	0c 96       	adiw	r24, 0x0c	; 12
    3588:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    358c:	89 81       	ldd	r24, Y+1	; 0x01
    358e:	9a 81       	ldd	r25, Y+2	; 0x02
    3590:	9c 01       	movw	r18, r24
    3592:	2e 5f       	subi	r18, 0xFE	; 254
    3594:	3f 4f       	sbci	r19, 0xFF	; 255
    3596:	87 ef       	ldi	r24, 0xF7	; 247
    3598:	95 e0       	ldi	r25, 0x05	; 5
    359a:	b9 01       	movw	r22, r18
    359c:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    35a0:	80 91 a8 05 	lds	r24, 0x05A8
    35a4:	8f 5f       	subi	r24, 0xFF	; 255
    35a6:	80 93 a8 05 	sts	0x05A8, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    35aa:	80 91 b3 05 	lds	r24, 0x05B3
    35ae:	8f 5f       	subi	r24, 0xFF	; 255
    35b0:	80 93 b3 05 	sts	0x05B3, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    35b4:	0f 90       	pop	r0
    35b6:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    35b8:	80 91 ae 05 	lds	r24, 0x05AE
    35bc:	88 23       	and	r24, r24
    35be:	31 f0       	breq	.+12     	; 0x35cc <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    35c0:	8b 81       	ldd	r24, Y+3	; 0x03
    35c2:	9c 81       	ldd	r25, Y+4	; 0x04
    35c4:	00 97       	sbiw	r24, 0x00	; 0
    35c6:	11 f4       	brne	.+4      	; 0x35cc <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    35c8:	0e 94 0b 14 	call	0x2816	; 0x2816 <vPortYield>
			}
		}
	}
    35cc:	26 96       	adiw	r28, 0x06	; 6
    35ce:	0f b6       	in	r0, 0x3f	; 63
    35d0:	f8 94       	cli
    35d2:	de bf       	out	0x3e, r29	; 62
    35d4:	0f be       	out	0x3f, r0	; 63
    35d6:	cd bf       	out	0x3d, r28	; 61
    35d8:	cf 91       	pop	r28
    35da:	df 91       	pop	r29
    35dc:	08 95       	ret

000035de <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    35de:	df 93       	push	r29
    35e0:	cf 93       	push	r28
    35e2:	cd b7       	in	r28, 0x3d	; 61
    35e4:	de b7       	in	r29, 0x3e	; 62
    35e6:	28 97       	sbiw	r28, 0x08	; 8
    35e8:	0f b6       	in	r0, 0x3f	; 63
    35ea:	f8 94       	cli
    35ec:	de bf       	out	0x3e, r29	; 62
    35ee:	0f be       	out	0x3f, r0	; 63
    35f0:	cd bf       	out	0x3d, r28	; 61
    35f2:	9e 83       	std	Y+6, r25	; 0x06
    35f4:	8d 83       	std	Y+5, r24	; 0x05
    35f6:	78 87       	std	Y+8, r23	; 0x08
    35f8:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    35fa:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    35fc:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3600:	ed 81       	ldd	r30, Y+5	; 0x05
    3602:	fe 81       	ldd	r31, Y+6	; 0x06
    3604:	20 81       	ld	r18, Z
    3606:	31 81       	ldd	r19, Z+1	; 0x01
    3608:	8f 81       	ldd	r24, Y+7	; 0x07
    360a:	98 85       	ldd	r25, Y+8	; 0x08
    360c:	82 0f       	add	r24, r18
    360e:	93 1f       	adc	r25, r19
    3610:	9c 83       	std	Y+4, r25	; 0x04
    3612:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    3614:	ed 81       	ldd	r30, Y+5	; 0x05
    3616:	fe 81       	ldd	r31, Y+6	; 0x06
    3618:	20 81       	ld	r18, Z
    361a:	31 81       	ldd	r19, Z+1	; 0x01
    361c:	80 91 aa 05 	lds	r24, 0x05AA
    3620:	90 91 ab 05 	lds	r25, 0x05AB
    3624:	82 17       	cp	r24, r18
    3626:	93 07       	cpc	r25, r19
    3628:	a8 f4       	brcc	.+42     	; 0x3654 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    362a:	ed 81       	ldd	r30, Y+5	; 0x05
    362c:	fe 81       	ldd	r31, Y+6	; 0x06
    362e:	20 81       	ld	r18, Z
    3630:	31 81       	ldd	r19, Z+1	; 0x01
    3632:	8b 81       	ldd	r24, Y+3	; 0x03
    3634:	9c 81       	ldd	r25, Y+4	; 0x04
    3636:	82 17       	cp	r24, r18
    3638:	93 07       	cpc	r25, r19
    363a:	00 f5       	brcc	.+64     	; 0x367c <vTaskDelayUntil+0x9e>
    363c:	20 91 aa 05 	lds	r18, 0x05AA
    3640:	30 91 ab 05 	lds	r19, 0x05AB
    3644:	8b 81       	ldd	r24, Y+3	; 0x03
    3646:	9c 81       	ldd	r25, Y+4	; 0x04
    3648:	28 17       	cp	r18, r24
    364a:	39 07       	cpc	r19, r25
    364c:	b8 f4       	brcc	.+46     	; 0x367c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    364e:	81 e0       	ldi	r24, 0x01	; 1
    3650:	89 83       	std	Y+1, r24	; 0x01
    3652:	14 c0       	rjmp	.+40     	; 0x367c <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    3654:	ed 81       	ldd	r30, Y+5	; 0x05
    3656:	fe 81       	ldd	r31, Y+6	; 0x06
    3658:	20 81       	ld	r18, Z
    365a:	31 81       	ldd	r19, Z+1	; 0x01
    365c:	8b 81       	ldd	r24, Y+3	; 0x03
    365e:	9c 81       	ldd	r25, Y+4	; 0x04
    3660:	82 17       	cp	r24, r18
    3662:	93 07       	cpc	r25, r19
    3664:	48 f0       	brcs	.+18     	; 0x3678 <vTaskDelayUntil+0x9a>
    3666:	20 91 aa 05 	lds	r18, 0x05AA
    366a:	30 91 ab 05 	lds	r19, 0x05AB
    366e:	8b 81       	ldd	r24, Y+3	; 0x03
    3670:	9c 81       	ldd	r25, Y+4	; 0x04
    3672:	28 17       	cp	r18, r24
    3674:	39 07       	cpc	r19, r25
    3676:	10 f4       	brcc	.+4      	; 0x367c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3678:	81 e0       	ldi	r24, 0x01	; 1
    367a:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    367c:	ed 81       	ldd	r30, Y+5	; 0x05
    367e:	fe 81       	ldd	r31, Y+6	; 0x06
    3680:	8b 81       	ldd	r24, Y+3	; 0x03
    3682:	9c 81       	ldd	r25, Y+4	; 0x04
    3684:	91 83       	std	Z+1, r25	; 0x01
    3686:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    3688:	89 81       	ldd	r24, Y+1	; 0x01
    368a:	88 23       	and	r24, r24
    368c:	59 f0       	breq	.+22     	; 0x36a4 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    368e:	80 91 a6 05 	lds	r24, 0x05A6
    3692:	90 91 a7 05 	lds	r25, 0x05A7
    3696:	02 96       	adiw	r24, 0x02	; 2
    3698:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    369c:	8b 81       	ldd	r24, Y+3	; 0x03
    369e:	9c 81       	ldd	r25, Y+4	; 0x04
    36a0:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    36a4:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xTaskResumeAll>
    36a8:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    36aa:	8a 81       	ldd	r24, Y+2	; 0x02
    36ac:	88 23       	and	r24, r24
    36ae:	11 f4       	brne	.+4      	; 0x36b4 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    36b0:	0e 94 0b 14 	call	0x2816	; 0x2816 <vPortYield>
		}
	}
    36b4:	28 96       	adiw	r28, 0x08	; 8
    36b6:	0f b6       	in	r0, 0x3f	; 63
    36b8:	f8 94       	cli
    36ba:	de bf       	out	0x3e, r29	; 62
    36bc:	0f be       	out	0x3f, r0	; 63
    36be:	cd bf       	out	0x3d, r28	; 61
    36c0:	cf 91       	pop	r28
    36c2:	df 91       	pop	r29
    36c4:	08 95       	ret

000036c6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    36c6:	df 93       	push	r29
    36c8:	cf 93       	push	r28
    36ca:	00 d0       	rcall	.+0      	; 0x36cc <vTaskDelay+0x6>
    36cc:	00 d0       	rcall	.+0      	; 0x36ce <vTaskDelay+0x8>
    36ce:	0f 92       	push	r0
    36d0:	cd b7       	in	r28, 0x3d	; 61
    36d2:	de b7       	in	r29, 0x3e	; 62
    36d4:	9d 83       	std	Y+5, r25	; 0x05
    36d6:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    36d8:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    36da:	8c 81       	ldd	r24, Y+4	; 0x04
    36dc:	9d 81       	ldd	r25, Y+5	; 0x05
    36de:	00 97       	sbiw	r24, 0x00	; 0
    36e0:	d1 f0       	breq	.+52     	; 0x3716 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    36e2:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    36e6:	20 91 aa 05 	lds	r18, 0x05AA
    36ea:	30 91 ab 05 	lds	r19, 0x05AB
    36ee:	8c 81       	ldd	r24, Y+4	; 0x04
    36f0:	9d 81       	ldd	r25, Y+5	; 0x05
    36f2:	82 0f       	add	r24, r18
    36f4:	93 1f       	adc	r25, r19
    36f6:	9b 83       	std	Y+3, r25	; 0x03
    36f8:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    36fa:	80 91 a6 05 	lds	r24, 0x05A6
    36fe:	90 91 a7 05 	lds	r25, 0x05A7
    3702:	02 96       	adiw	r24, 0x02	; 2
    3704:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3708:	8a 81       	ldd	r24, Y+2	; 0x02
    370a:	9b 81       	ldd	r25, Y+3	; 0x03
    370c:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3710:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xTaskResumeAll>
    3714:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3716:	89 81       	ldd	r24, Y+1	; 0x01
    3718:	88 23       	and	r24, r24
    371a:	11 f4       	brne	.+4      	; 0x3720 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    371c:	0e 94 0b 14 	call	0x2816	; 0x2816 <vPortYield>
		}
	}
    3720:	0f 90       	pop	r0
    3722:	0f 90       	pop	r0
    3724:	0f 90       	pop	r0
    3726:	0f 90       	pop	r0
    3728:	0f 90       	pop	r0
    372a:	cf 91       	pop	r28
    372c:	df 91       	pop	r29
    372e:	08 95       	ret

00003730 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    3730:	af 92       	push	r10
    3732:	bf 92       	push	r11
    3734:	cf 92       	push	r12
    3736:	df 92       	push	r13
    3738:	ef 92       	push	r14
    373a:	ff 92       	push	r15
    373c:	0f 93       	push	r16
    373e:	df 93       	push	r29
    3740:	cf 93       	push	r28
    3742:	0f 92       	push	r0
    3744:	cd b7       	in	r28, 0x3d	; 61
    3746:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    3748:	22 e7       	ldi	r18, 0x72	; 114
    374a:	30 e0       	ldi	r19, 0x00	; 0
    374c:	8f ef       	ldi	r24, 0xFF	; 255
    374e:	9e e1       	ldi	r25, 0x1E	; 30
    3750:	b9 01       	movw	r22, r18
    3752:	45 e5       	ldi	r20, 0x55	; 85
    3754:	50 e0       	ldi	r21, 0x00	; 0
    3756:	20 e0       	ldi	r18, 0x00	; 0
    3758:	30 e0       	ldi	r19, 0x00	; 0
    375a:	00 e0       	ldi	r16, 0x00	; 0
    375c:	ee 24       	eor	r14, r14
    375e:	ff 24       	eor	r15, r15
    3760:	cc 24       	eor	r12, r12
    3762:	dd 24       	eor	r13, r13
    3764:	aa 24       	eor	r10, r10
    3766:	bb 24       	eor	r11, r11
    3768:	0e 94 9f 19 	call	0x333e	; 0x333e <xTaskGenericCreate>
    376c:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    376e:	89 81       	ldd	r24, Y+1	; 0x01
    3770:	81 30       	cpi	r24, 0x01	; 1
    3772:	51 f4       	brne	.+20     	; 0x3788 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    3774:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    3776:	81 e0       	ldi	r24, 0x01	; 1
    3778:	80 93 ae 05 	sts	0x05AE, r24
		xTickCount = ( portTickType ) 0U;
    377c:	10 92 ab 05 	sts	0x05AB, r1
    3780:	10 92 aa 05 	sts	0x05AA, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3784:	0e 94 cf 13 	call	0x279e	; 0x279e <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    3788:	0f 90       	pop	r0
    378a:	cf 91       	pop	r28
    378c:	df 91       	pop	r29
    378e:	0f 91       	pop	r16
    3790:	ff 90       	pop	r15
    3792:	ef 90       	pop	r14
    3794:	df 90       	pop	r13
    3796:	cf 90       	pop	r12
    3798:	bf 90       	pop	r11
    379a:	af 90       	pop	r10
    379c:	08 95       	ret

0000379e <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    379e:	df 93       	push	r29
    37a0:	cf 93       	push	r28
    37a2:	cd b7       	in	r28, 0x3d	; 61
    37a4:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    37a6:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    37a8:	10 92 ae 05 	sts	0x05AE, r1
	vPortEndScheduler();
    37ac:	0e 94 04 14 	call	0x2808	; 0x2808 <vPortEndScheduler>
}
    37b0:	cf 91       	pop	r28
    37b2:	df 91       	pop	r29
    37b4:	08 95       	ret

000037b6 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    37b6:	df 93       	push	r29
    37b8:	cf 93       	push	r28
    37ba:	cd b7       	in	r28, 0x3d	; 61
    37bc:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    37be:	80 91 af 05 	lds	r24, 0x05AF
    37c2:	8f 5f       	subi	r24, 0xFF	; 255
    37c4:	80 93 af 05 	sts	0x05AF, r24
}
    37c8:	cf 91       	pop	r28
    37ca:	df 91       	pop	r29
    37cc:	08 95       	ret

000037ce <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    37ce:	df 93       	push	r29
    37d0:	cf 93       	push	r28
    37d2:	00 d0       	rcall	.+0      	; 0x37d4 <xTaskResumeAll+0x6>
    37d4:	00 d0       	rcall	.+0      	; 0x37d6 <xTaskResumeAll+0x8>
    37d6:	cd b7       	in	r28, 0x3d	; 61
    37d8:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    37da:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    37dc:	0f b6       	in	r0, 0x3f	; 63
    37de:	f8 94       	cli
    37e0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    37e2:	80 91 af 05 	lds	r24, 0x05AF
    37e6:	81 50       	subi	r24, 0x01	; 1
    37e8:	80 93 af 05 	sts	0x05AF, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    37ec:	80 91 af 05 	lds	r24, 0x05AF
    37f0:	88 23       	and	r24, r24
    37f2:	09 f0       	breq	.+2      	; 0x37f6 <xTaskResumeAll+0x28>
    37f4:	6c c0       	rjmp	.+216    	; 0x38ce <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    37f6:	80 91 a9 05 	lds	r24, 0x05A9
    37fa:	88 23       	and	r24, r24
    37fc:	09 f4       	brne	.+2      	; 0x3800 <xTaskResumeAll+0x32>
    37fe:	67 c0       	rjmp	.+206    	; 0x38ce <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    3800:	19 82       	std	Y+1, r1	; 0x01
    3802:	41 c0       	rjmp	.+130    	; 0x3886 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    3804:	e0 91 f3 05 	lds	r30, 0x05F3
    3808:	f0 91 f4 05 	lds	r31, 0x05F4
    380c:	86 81       	ldd	r24, Z+6	; 0x06
    380e:	97 81       	ldd	r25, Z+7	; 0x07
    3810:	9c 83       	std	Y+4, r25	; 0x04
    3812:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    3814:	8b 81       	ldd	r24, Y+3	; 0x03
    3816:	9c 81       	ldd	r25, Y+4	; 0x04
    3818:	0c 96       	adiw	r24, 0x0c	; 12
    381a:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    381e:	8b 81       	ldd	r24, Y+3	; 0x03
    3820:	9c 81       	ldd	r25, Y+4	; 0x04
    3822:	02 96       	adiw	r24, 0x02	; 2
    3824:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    3828:	eb 81       	ldd	r30, Y+3	; 0x03
    382a:	fc 81       	ldd	r31, Y+4	; 0x04
    382c:	96 89       	ldd	r25, Z+22	; 0x16
    382e:	80 91 ad 05 	lds	r24, 0x05AD
    3832:	89 17       	cp	r24, r25
    3834:	28 f4       	brcc	.+10     	; 0x3840 <xTaskResumeAll+0x72>
    3836:	eb 81       	ldd	r30, Y+3	; 0x03
    3838:	fc 81       	ldd	r31, Y+4	; 0x04
    383a:	86 89       	ldd	r24, Z+22	; 0x16
    383c:	80 93 ad 05 	sts	0x05AD, r24
    3840:	eb 81       	ldd	r30, Y+3	; 0x03
    3842:	fc 81       	ldd	r31, Y+4	; 0x04
    3844:	86 89       	ldd	r24, Z+22	; 0x16
    3846:	28 2f       	mov	r18, r24
    3848:	30 e0       	ldi	r19, 0x00	; 0
    384a:	c9 01       	movw	r24, r18
    384c:	88 0f       	add	r24, r24
    384e:	99 1f       	adc	r25, r25
    3850:	88 0f       	add	r24, r24
    3852:	99 1f       	adc	r25, r25
    3854:	88 0f       	add	r24, r24
    3856:	99 1f       	adc	r25, r25
    3858:	82 0f       	add	r24, r18
    385a:	93 1f       	adc	r25, r19
    385c:	8c 54       	subi	r24, 0x4C	; 76
    385e:	9a 4f       	sbci	r25, 0xFA	; 250
    3860:	2b 81       	ldd	r18, Y+3	; 0x03
    3862:	3c 81       	ldd	r19, Y+4	; 0x04
    3864:	2e 5f       	subi	r18, 0xFE	; 254
    3866:	3f 4f       	sbci	r19, 0xFF	; 255
    3868:	b9 01       	movw	r22, r18
    386a:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    386e:	eb 81       	ldd	r30, Y+3	; 0x03
    3870:	fc 81       	ldd	r31, Y+4	; 0x04
    3872:	96 89       	ldd	r25, Z+22	; 0x16
    3874:	e0 91 a6 05 	lds	r30, 0x05A6
    3878:	f0 91 a7 05 	lds	r31, 0x05A7
    387c:	86 89       	ldd	r24, Z+22	; 0x16
    387e:	98 17       	cp	r25, r24
    3880:	10 f0       	brcs	.+4      	; 0x3886 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    3882:	81 e0       	ldi	r24, 0x01	; 1
    3884:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    3886:	80 91 ee 05 	lds	r24, 0x05EE
    388a:	88 23       	and	r24, r24
    388c:	09 f0       	breq	.+2      	; 0x3890 <xTaskResumeAll+0xc2>
    388e:	ba cf       	rjmp	.-140    	; 0x3804 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3890:	80 91 b0 05 	lds	r24, 0x05B0
    3894:	88 23       	and	r24, r24
    3896:	71 f0       	breq	.+28     	; 0x38b4 <xTaskResumeAll+0xe6>
    3898:	07 c0       	rjmp	.+14     	; 0x38a8 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    389a:	0e 94 a6 1c 	call	0x394c	; 0x394c <vTaskIncrementTick>
						--uxMissedTicks;
    389e:	80 91 b0 05 	lds	r24, 0x05B0
    38a2:	81 50       	subi	r24, 0x01	; 1
    38a4:	80 93 b0 05 	sts	0x05B0, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    38a8:	80 91 b0 05 	lds	r24, 0x05B0
    38ac:	88 23       	and	r24, r24
    38ae:	a9 f7       	brne	.-22     	; 0x389a <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    38b0:	81 e0       	ldi	r24, 0x01	; 1
    38b2:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    38b4:	89 81       	ldd	r24, Y+1	; 0x01
    38b6:	81 30       	cpi	r24, 0x01	; 1
    38b8:	21 f0       	breq	.+8      	; 0x38c2 <xTaskResumeAll+0xf4>
    38ba:	80 91 b1 05 	lds	r24, 0x05B1
    38be:	81 30       	cpi	r24, 0x01	; 1
    38c0:	31 f4       	brne	.+12     	; 0x38ce <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    38c2:	81 e0       	ldi	r24, 0x01	; 1
    38c4:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    38c6:	10 92 b1 05 	sts	0x05B1, r1
					portYIELD_WITHIN_API();
    38ca:	0e 94 0b 14 	call	0x2816	; 0x2816 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    38ce:	0f 90       	pop	r0
    38d0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    38d2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    38d4:	0f 90       	pop	r0
    38d6:	0f 90       	pop	r0
    38d8:	0f 90       	pop	r0
    38da:	0f 90       	pop	r0
    38dc:	cf 91       	pop	r28
    38de:	df 91       	pop	r29
    38e0:	08 95       	ret

000038e2 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    38e2:	df 93       	push	r29
    38e4:	cf 93       	push	r28
    38e6:	00 d0       	rcall	.+0      	; 0x38e8 <xTaskGetTickCount+0x6>
    38e8:	cd b7       	in	r28, 0x3d	; 61
    38ea:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    38ec:	0f b6       	in	r0, 0x3f	; 63
    38ee:	f8 94       	cli
    38f0:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    38f2:	80 91 aa 05 	lds	r24, 0x05AA
    38f6:	90 91 ab 05 	lds	r25, 0x05AB
    38fa:	9a 83       	std	Y+2, r25	; 0x02
    38fc:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    38fe:	0f 90       	pop	r0
    3900:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3902:	89 81       	ldd	r24, Y+1	; 0x01
    3904:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3906:	0f 90       	pop	r0
    3908:	0f 90       	pop	r0
    390a:	cf 91       	pop	r28
    390c:	df 91       	pop	r29
    390e:	08 95       	ret

00003910 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    3910:	df 93       	push	r29
    3912:	cf 93       	push	r28
    3914:	00 d0       	rcall	.+0      	; 0x3916 <xTaskGetTickCountFromISR+0x6>
    3916:	0f 92       	push	r0
    3918:	cd b7       	in	r28, 0x3d	; 61
    391a:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    391c:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    391e:	80 91 aa 05 	lds	r24, 0x05AA
    3922:	90 91 ab 05 	lds	r25, 0x05AB
    3926:	9b 83       	std	Y+3, r25	; 0x03
    3928:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    392a:	8a 81       	ldd	r24, Y+2	; 0x02
    392c:	9b 81       	ldd	r25, Y+3	; 0x03
}
    392e:	0f 90       	pop	r0
    3930:	0f 90       	pop	r0
    3932:	0f 90       	pop	r0
    3934:	cf 91       	pop	r28
    3936:	df 91       	pop	r29
    3938:	08 95       	ret

0000393a <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    393a:	df 93       	push	r29
    393c:	cf 93       	push	r28
    393e:	cd b7       	in	r28, 0x3d	; 61
    3940:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    3942:	80 91 a9 05 	lds	r24, 0x05A9
}
    3946:	cf 91       	pop	r28
    3948:	df 91       	pop	r29
    394a:	08 95       	ret

0000394c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    394c:	df 93       	push	r29
    394e:	cf 93       	push	r28
    3950:	00 d0       	rcall	.+0      	; 0x3952 <vTaskIncrementTick+0x6>
    3952:	00 d0       	rcall	.+0      	; 0x3954 <vTaskIncrementTick+0x8>
    3954:	00 d0       	rcall	.+0      	; 0x3956 <vTaskIncrementTick+0xa>
    3956:	cd b7       	in	r28, 0x3d	; 61
    3958:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    395a:	80 91 af 05 	lds	r24, 0x05AF
    395e:	88 23       	and	r24, r24
    3960:	09 f0       	breq	.+2      	; 0x3964 <vTaskIncrementTick+0x18>
    3962:	bb c0       	rjmp	.+374    	; 0x3ada <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    3964:	80 91 aa 05 	lds	r24, 0x05AA
    3968:	90 91 ab 05 	lds	r25, 0x05AB
    396c:	01 96       	adiw	r24, 0x01	; 1
    396e:	90 93 ab 05 	sts	0x05AB, r25
    3972:	80 93 aa 05 	sts	0x05AA, r24
		if( xTickCount == ( portTickType ) 0U )
    3976:	80 91 aa 05 	lds	r24, 0x05AA
    397a:	90 91 ab 05 	lds	r25, 0x05AB
    397e:	00 97       	sbiw	r24, 0x00	; 0
    3980:	d1 f5       	brne	.+116    	; 0x39f6 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    3982:	80 91 ea 05 	lds	r24, 0x05EA
    3986:	90 91 eb 05 	lds	r25, 0x05EB
    398a:	9c 83       	std	Y+4, r25	; 0x04
    398c:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    398e:	80 91 ec 05 	lds	r24, 0x05EC
    3992:	90 91 ed 05 	lds	r25, 0x05ED
    3996:	90 93 eb 05 	sts	0x05EB, r25
    399a:	80 93 ea 05 	sts	0x05EA, r24
			pxOverflowDelayedTaskList = pxTemp;
    399e:	8b 81       	ldd	r24, Y+3	; 0x03
    39a0:	9c 81       	ldd	r25, Y+4	; 0x04
    39a2:	90 93 ed 05 	sts	0x05ED, r25
    39a6:	80 93 ec 05 	sts	0x05EC, r24
			xNumOfOverflows++;
    39aa:	80 91 b2 05 	lds	r24, 0x05B2
    39ae:	8f 5f       	subi	r24, 0xFF	; 255
    39b0:	80 93 b2 05 	sts	0x05B2, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    39b4:	e0 91 ea 05 	lds	r30, 0x05EA
    39b8:	f0 91 eb 05 	lds	r31, 0x05EB
    39bc:	80 81       	ld	r24, Z
    39be:	88 23       	and	r24, r24
    39c0:	39 f4       	brne	.+14     	; 0x39d0 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    39c2:	8f ef       	ldi	r24, 0xFF	; 255
    39c4:	9f ef       	ldi	r25, 0xFF	; 255
    39c6:	90 93 80 01 	sts	0x0180, r25
    39ca:	80 93 7f 01 	sts	0x017F, r24
    39ce:	13 c0       	rjmp	.+38     	; 0x39f6 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    39d0:	e0 91 ea 05 	lds	r30, 0x05EA
    39d4:	f0 91 eb 05 	lds	r31, 0x05EB
    39d8:	05 80       	ldd	r0, Z+5	; 0x05
    39da:	f6 81       	ldd	r31, Z+6	; 0x06
    39dc:	e0 2d       	mov	r30, r0
    39de:	86 81       	ldd	r24, Z+6	; 0x06
    39e0:	97 81       	ldd	r25, Z+7	; 0x07
    39e2:	9e 83       	std	Y+6, r25	; 0x06
    39e4:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    39e6:	ed 81       	ldd	r30, Y+5	; 0x05
    39e8:	fe 81       	ldd	r31, Y+6	; 0x06
    39ea:	82 81       	ldd	r24, Z+2	; 0x02
    39ec:	93 81       	ldd	r25, Z+3	; 0x03
    39ee:	90 93 80 01 	sts	0x0180, r25
    39f2:	80 93 7f 01 	sts	0x017F, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    39f6:	20 91 aa 05 	lds	r18, 0x05AA
    39fa:	30 91 ab 05 	lds	r19, 0x05AB
    39fe:	80 91 7f 01 	lds	r24, 0x017F
    3a02:	90 91 80 01 	lds	r25, 0x0180
    3a06:	28 17       	cp	r18, r24
    3a08:	39 07       	cpc	r19, r25
    3a0a:	08 f4       	brcc	.+2      	; 0x3a0e <vTaskIncrementTick+0xc2>
    3a0c:	6b c0       	rjmp	.+214    	; 0x3ae4 <vTaskIncrementTick+0x198>
    3a0e:	e0 91 ea 05 	lds	r30, 0x05EA
    3a12:	f0 91 eb 05 	lds	r31, 0x05EB
    3a16:	80 81       	ld	r24, Z
    3a18:	88 23       	and	r24, r24
    3a1a:	39 f4       	brne	.+14     	; 0x3a2a <vTaskIncrementTick+0xde>
    3a1c:	8f ef       	ldi	r24, 0xFF	; 255
    3a1e:	9f ef       	ldi	r25, 0xFF	; 255
    3a20:	90 93 80 01 	sts	0x0180, r25
    3a24:	80 93 7f 01 	sts	0x017F, r24
    3a28:	5d c0       	rjmp	.+186    	; 0x3ae4 <vTaskIncrementTick+0x198>
    3a2a:	e0 91 ea 05 	lds	r30, 0x05EA
    3a2e:	f0 91 eb 05 	lds	r31, 0x05EB
    3a32:	05 80       	ldd	r0, Z+5	; 0x05
    3a34:	f6 81       	ldd	r31, Z+6	; 0x06
    3a36:	e0 2d       	mov	r30, r0
    3a38:	86 81       	ldd	r24, Z+6	; 0x06
    3a3a:	97 81       	ldd	r25, Z+7	; 0x07
    3a3c:	9e 83       	std	Y+6, r25	; 0x06
    3a3e:	8d 83       	std	Y+5, r24	; 0x05
    3a40:	ed 81       	ldd	r30, Y+5	; 0x05
    3a42:	fe 81       	ldd	r31, Y+6	; 0x06
    3a44:	82 81       	ldd	r24, Z+2	; 0x02
    3a46:	93 81       	ldd	r25, Z+3	; 0x03
    3a48:	9a 83       	std	Y+2, r25	; 0x02
    3a4a:	89 83       	std	Y+1, r24	; 0x01
    3a4c:	20 91 aa 05 	lds	r18, 0x05AA
    3a50:	30 91 ab 05 	lds	r19, 0x05AB
    3a54:	89 81       	ldd	r24, Y+1	; 0x01
    3a56:	9a 81       	ldd	r25, Y+2	; 0x02
    3a58:	28 17       	cp	r18, r24
    3a5a:	39 07       	cpc	r19, r25
    3a5c:	38 f4       	brcc	.+14     	; 0x3a6c <vTaskIncrementTick+0x120>
    3a5e:	89 81       	ldd	r24, Y+1	; 0x01
    3a60:	9a 81       	ldd	r25, Y+2	; 0x02
    3a62:	90 93 80 01 	sts	0x0180, r25
    3a66:	80 93 7f 01 	sts	0x017F, r24
    3a6a:	3c c0       	rjmp	.+120    	; 0x3ae4 <vTaskIncrementTick+0x198>
    3a6c:	8d 81       	ldd	r24, Y+5	; 0x05
    3a6e:	9e 81       	ldd	r25, Y+6	; 0x06
    3a70:	02 96       	adiw	r24, 0x02	; 2
    3a72:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
    3a76:	ed 81       	ldd	r30, Y+5	; 0x05
    3a78:	fe 81       	ldd	r31, Y+6	; 0x06
    3a7a:	84 89       	ldd	r24, Z+20	; 0x14
    3a7c:	95 89       	ldd	r25, Z+21	; 0x15
    3a7e:	00 97       	sbiw	r24, 0x00	; 0
    3a80:	29 f0       	breq	.+10     	; 0x3a8c <vTaskIncrementTick+0x140>
    3a82:	8d 81       	ldd	r24, Y+5	; 0x05
    3a84:	9e 81       	ldd	r25, Y+6	; 0x06
    3a86:	0c 96       	adiw	r24, 0x0c	; 12
    3a88:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
    3a8c:	ed 81       	ldd	r30, Y+5	; 0x05
    3a8e:	fe 81       	ldd	r31, Y+6	; 0x06
    3a90:	96 89       	ldd	r25, Z+22	; 0x16
    3a92:	80 91 ad 05 	lds	r24, 0x05AD
    3a96:	89 17       	cp	r24, r25
    3a98:	28 f4       	brcc	.+10     	; 0x3aa4 <vTaskIncrementTick+0x158>
    3a9a:	ed 81       	ldd	r30, Y+5	; 0x05
    3a9c:	fe 81       	ldd	r31, Y+6	; 0x06
    3a9e:	86 89       	ldd	r24, Z+22	; 0x16
    3aa0:	80 93 ad 05 	sts	0x05AD, r24
    3aa4:	ed 81       	ldd	r30, Y+5	; 0x05
    3aa6:	fe 81       	ldd	r31, Y+6	; 0x06
    3aa8:	86 89       	ldd	r24, Z+22	; 0x16
    3aaa:	28 2f       	mov	r18, r24
    3aac:	30 e0       	ldi	r19, 0x00	; 0
    3aae:	c9 01       	movw	r24, r18
    3ab0:	88 0f       	add	r24, r24
    3ab2:	99 1f       	adc	r25, r25
    3ab4:	88 0f       	add	r24, r24
    3ab6:	99 1f       	adc	r25, r25
    3ab8:	88 0f       	add	r24, r24
    3aba:	99 1f       	adc	r25, r25
    3abc:	82 0f       	add	r24, r18
    3abe:	93 1f       	adc	r25, r19
    3ac0:	ac 01       	movw	r20, r24
    3ac2:	4c 54       	subi	r20, 0x4C	; 76
    3ac4:	5a 4f       	sbci	r21, 0xFA	; 250
    3ac6:	8d 81       	ldd	r24, Y+5	; 0x05
    3ac8:	9e 81       	ldd	r25, Y+6	; 0x06
    3aca:	9c 01       	movw	r18, r24
    3acc:	2e 5f       	subi	r18, 0xFE	; 254
    3ace:	3f 4f       	sbci	r19, 0xFF	; 255
    3ad0:	ca 01       	movw	r24, r20
    3ad2:	b9 01       	movw	r22, r18
    3ad4:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vListInsertEnd>
    3ad8:	9a cf       	rjmp	.-204    	; 0x3a0e <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    3ada:	80 91 b0 05 	lds	r24, 0x05B0
    3ade:	8f 5f       	subi	r24, 0xFF	; 255
    3ae0:	80 93 b0 05 	sts	0x05B0, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    3ae4:	26 96       	adiw	r28, 0x06	; 6
    3ae6:	0f b6       	in	r0, 0x3f	; 63
    3ae8:	f8 94       	cli
    3aea:	de bf       	out	0x3e, r29	; 62
    3aec:	0f be       	out	0x3f, r0	; 63
    3aee:	cd bf       	out	0x3d, r28	; 61
    3af0:	cf 91       	pop	r28
    3af2:	df 91       	pop	r29
    3af4:	08 95       	ret

00003af6 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3af6:	df 93       	push	r29
    3af8:	cf 93       	push	r28
    3afa:	00 d0       	rcall	.+0      	; 0x3afc <vTaskSwitchContext+0x6>
    3afc:	cd b7       	in	r28, 0x3d	; 61
    3afe:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3b00:	80 91 af 05 	lds	r24, 0x05AF
    3b04:	88 23       	and	r24, r24
    3b06:	49 f0       	breq	.+18     	; 0x3b1a <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3b08:	81 e0       	ldi	r24, 0x01	; 1
    3b0a:	80 93 b1 05 	sts	0x05B1, r24
    3b0e:	54 c0       	rjmp	.+168    	; 0x3bb8 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    3b10:	80 91 ad 05 	lds	r24, 0x05AD
    3b14:	81 50       	subi	r24, 0x01	; 1
    3b16:	80 93 ad 05 	sts	0x05AD, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3b1a:	80 91 ad 05 	lds	r24, 0x05AD
    3b1e:	28 2f       	mov	r18, r24
    3b20:	30 e0       	ldi	r19, 0x00	; 0
    3b22:	c9 01       	movw	r24, r18
    3b24:	88 0f       	add	r24, r24
    3b26:	99 1f       	adc	r25, r25
    3b28:	88 0f       	add	r24, r24
    3b2a:	99 1f       	adc	r25, r25
    3b2c:	88 0f       	add	r24, r24
    3b2e:	99 1f       	adc	r25, r25
    3b30:	82 0f       	add	r24, r18
    3b32:	93 1f       	adc	r25, r19
    3b34:	fc 01       	movw	r30, r24
    3b36:	ec 54       	subi	r30, 0x4C	; 76
    3b38:	fa 4f       	sbci	r31, 0xFA	; 250
    3b3a:	80 81       	ld	r24, Z
    3b3c:	88 23       	and	r24, r24
    3b3e:	41 f3       	breq	.-48     	; 0x3b10 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    3b40:	80 91 ad 05 	lds	r24, 0x05AD
    3b44:	28 2f       	mov	r18, r24
    3b46:	30 e0       	ldi	r19, 0x00	; 0
    3b48:	c9 01       	movw	r24, r18
    3b4a:	88 0f       	add	r24, r24
    3b4c:	99 1f       	adc	r25, r25
    3b4e:	88 0f       	add	r24, r24
    3b50:	99 1f       	adc	r25, r25
    3b52:	88 0f       	add	r24, r24
    3b54:	99 1f       	adc	r25, r25
    3b56:	82 0f       	add	r24, r18
    3b58:	93 1f       	adc	r25, r19
    3b5a:	8c 54       	subi	r24, 0x4C	; 76
    3b5c:	9a 4f       	sbci	r25, 0xFA	; 250
    3b5e:	9a 83       	std	Y+2, r25	; 0x02
    3b60:	89 83       	std	Y+1, r24	; 0x01
    3b62:	e9 81       	ldd	r30, Y+1	; 0x01
    3b64:	fa 81       	ldd	r31, Y+2	; 0x02
    3b66:	01 80       	ldd	r0, Z+1	; 0x01
    3b68:	f2 81       	ldd	r31, Z+2	; 0x02
    3b6a:	e0 2d       	mov	r30, r0
    3b6c:	82 81       	ldd	r24, Z+2	; 0x02
    3b6e:	93 81       	ldd	r25, Z+3	; 0x03
    3b70:	e9 81       	ldd	r30, Y+1	; 0x01
    3b72:	fa 81       	ldd	r31, Y+2	; 0x02
    3b74:	92 83       	std	Z+2, r25	; 0x02
    3b76:	81 83       	std	Z+1, r24	; 0x01
    3b78:	e9 81       	ldd	r30, Y+1	; 0x01
    3b7a:	fa 81       	ldd	r31, Y+2	; 0x02
    3b7c:	21 81       	ldd	r18, Z+1	; 0x01
    3b7e:	32 81       	ldd	r19, Z+2	; 0x02
    3b80:	89 81       	ldd	r24, Y+1	; 0x01
    3b82:	9a 81       	ldd	r25, Y+2	; 0x02
    3b84:	03 96       	adiw	r24, 0x03	; 3
    3b86:	28 17       	cp	r18, r24
    3b88:	39 07       	cpc	r19, r25
    3b8a:	59 f4       	brne	.+22     	; 0x3ba2 <vTaskSwitchContext+0xac>
    3b8c:	e9 81       	ldd	r30, Y+1	; 0x01
    3b8e:	fa 81       	ldd	r31, Y+2	; 0x02
    3b90:	01 80       	ldd	r0, Z+1	; 0x01
    3b92:	f2 81       	ldd	r31, Z+2	; 0x02
    3b94:	e0 2d       	mov	r30, r0
    3b96:	82 81       	ldd	r24, Z+2	; 0x02
    3b98:	93 81       	ldd	r25, Z+3	; 0x03
    3b9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3b9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3b9e:	92 83       	std	Z+2, r25	; 0x02
    3ba0:	81 83       	std	Z+1, r24	; 0x01
    3ba2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ba4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ba6:	01 80       	ldd	r0, Z+1	; 0x01
    3ba8:	f2 81       	ldd	r31, Z+2	; 0x02
    3baa:	e0 2d       	mov	r30, r0
    3bac:	86 81       	ldd	r24, Z+6	; 0x06
    3bae:	97 81       	ldd	r25, Z+7	; 0x07
    3bb0:	90 93 a7 05 	sts	0x05A7, r25
    3bb4:	80 93 a6 05 	sts	0x05A6, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    3bb8:	0f 90       	pop	r0
    3bba:	0f 90       	pop	r0
    3bbc:	cf 91       	pop	r28
    3bbe:	df 91       	pop	r29
    3bc0:	08 95       	ret

00003bc2 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    3bc2:	df 93       	push	r29
    3bc4:	cf 93       	push	r28
    3bc6:	00 d0       	rcall	.+0      	; 0x3bc8 <vTaskPlaceOnEventList+0x6>
    3bc8:	00 d0       	rcall	.+0      	; 0x3bca <vTaskPlaceOnEventList+0x8>
    3bca:	00 d0       	rcall	.+0      	; 0x3bcc <vTaskPlaceOnEventList+0xa>
    3bcc:	cd b7       	in	r28, 0x3d	; 61
    3bce:	de b7       	in	r29, 0x3e	; 62
    3bd0:	9c 83       	std	Y+4, r25	; 0x04
    3bd2:	8b 83       	std	Y+3, r24	; 0x03
    3bd4:	7e 83       	std	Y+6, r23	; 0x06
    3bd6:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3bd8:	4b 81       	ldd	r20, Y+3	; 0x03
    3bda:	5c 81       	ldd	r21, Y+4	; 0x04
    3bdc:	80 91 a6 05 	lds	r24, 0x05A6
    3be0:	90 91 a7 05 	lds	r25, 0x05A7
    3be4:	9c 01       	movw	r18, r24
    3be6:	24 5f       	subi	r18, 0xF4	; 244
    3be8:	3f 4f       	sbci	r19, 0xFF	; 255
    3bea:	ca 01       	movw	r24, r20
    3bec:	b9 01       	movw	r22, r18
    3bee:	0e 94 43 11 	call	0x2286	; 0x2286 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3bf2:	80 91 a6 05 	lds	r24, 0x05A6
    3bf6:	90 91 a7 05 	lds	r25, 0x05A7
    3bfa:	02 96       	adiw	r24, 0x02	; 2
    3bfc:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3c00:	20 91 aa 05 	lds	r18, 0x05AA
    3c04:	30 91 ab 05 	lds	r19, 0x05AB
    3c08:	8d 81       	ldd	r24, Y+5	; 0x05
    3c0a:	9e 81       	ldd	r25, Y+6	; 0x06
    3c0c:	82 0f       	add	r24, r18
    3c0e:	93 1f       	adc	r25, r19
    3c10:	9a 83       	std	Y+2, r25	; 0x02
    3c12:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3c14:	89 81       	ldd	r24, Y+1	; 0x01
    3c16:	9a 81       	ldd	r25, Y+2	; 0x02
    3c18:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    3c1c:	26 96       	adiw	r28, 0x06	; 6
    3c1e:	0f b6       	in	r0, 0x3f	; 63
    3c20:	f8 94       	cli
    3c22:	de bf       	out	0x3e, r29	; 62
    3c24:	0f be       	out	0x3f, r0	; 63
    3c26:	cd bf       	out	0x3d, r28	; 61
    3c28:	cf 91       	pop	r28
    3c2a:	df 91       	pop	r29
    3c2c:	08 95       	ret

00003c2e <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    3c2e:	df 93       	push	r29
    3c30:	cf 93       	push	r28
    3c32:	00 d0       	rcall	.+0      	; 0x3c34 <xTaskRemoveFromEventList+0x6>
    3c34:	00 d0       	rcall	.+0      	; 0x3c36 <xTaskRemoveFromEventList+0x8>
    3c36:	0f 92       	push	r0
    3c38:	cd b7       	in	r28, 0x3d	; 61
    3c3a:	de b7       	in	r29, 0x3e	; 62
    3c3c:	9d 83       	std	Y+5, r25	; 0x05
    3c3e:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3c40:	ec 81       	ldd	r30, Y+4	; 0x04
    3c42:	fd 81       	ldd	r31, Y+5	; 0x05
    3c44:	05 80       	ldd	r0, Z+5	; 0x05
    3c46:	f6 81       	ldd	r31, Z+6	; 0x06
    3c48:	e0 2d       	mov	r30, r0
    3c4a:	86 81       	ldd	r24, Z+6	; 0x06
    3c4c:	97 81       	ldd	r25, Z+7	; 0x07
    3c4e:	9b 83       	std	Y+3, r25	; 0x03
    3c50:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3c52:	8a 81       	ldd	r24, Y+2	; 0x02
    3c54:	9b 81       	ldd	r25, Y+3	; 0x03
    3c56:	0c 96       	adiw	r24, 0x0c	; 12
    3c58:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3c5c:	80 91 af 05 	lds	r24, 0x05AF
    3c60:	88 23       	and	r24, r24
    3c62:	61 f5       	brne	.+88     	; 0x3cbc <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3c64:	8a 81       	ldd	r24, Y+2	; 0x02
    3c66:	9b 81       	ldd	r25, Y+3	; 0x03
    3c68:	02 96       	adiw	r24, 0x02	; 2
    3c6a:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    3c6e:	ea 81       	ldd	r30, Y+2	; 0x02
    3c70:	fb 81       	ldd	r31, Y+3	; 0x03
    3c72:	96 89       	ldd	r25, Z+22	; 0x16
    3c74:	80 91 ad 05 	lds	r24, 0x05AD
    3c78:	89 17       	cp	r24, r25
    3c7a:	28 f4       	brcc	.+10     	; 0x3c86 <xTaskRemoveFromEventList+0x58>
    3c7c:	ea 81       	ldd	r30, Y+2	; 0x02
    3c7e:	fb 81       	ldd	r31, Y+3	; 0x03
    3c80:	86 89       	ldd	r24, Z+22	; 0x16
    3c82:	80 93 ad 05 	sts	0x05AD, r24
    3c86:	ea 81       	ldd	r30, Y+2	; 0x02
    3c88:	fb 81       	ldd	r31, Y+3	; 0x03
    3c8a:	86 89       	ldd	r24, Z+22	; 0x16
    3c8c:	28 2f       	mov	r18, r24
    3c8e:	30 e0       	ldi	r19, 0x00	; 0
    3c90:	c9 01       	movw	r24, r18
    3c92:	88 0f       	add	r24, r24
    3c94:	99 1f       	adc	r25, r25
    3c96:	88 0f       	add	r24, r24
    3c98:	99 1f       	adc	r25, r25
    3c9a:	88 0f       	add	r24, r24
    3c9c:	99 1f       	adc	r25, r25
    3c9e:	82 0f       	add	r24, r18
    3ca0:	93 1f       	adc	r25, r19
    3ca2:	ac 01       	movw	r20, r24
    3ca4:	4c 54       	subi	r20, 0x4C	; 76
    3ca6:	5a 4f       	sbci	r21, 0xFA	; 250
    3ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    3caa:	9b 81       	ldd	r25, Y+3	; 0x03
    3cac:	9c 01       	movw	r18, r24
    3cae:	2e 5f       	subi	r18, 0xFE	; 254
    3cb0:	3f 4f       	sbci	r19, 0xFF	; 255
    3cb2:	ca 01       	movw	r24, r20
    3cb4:	b9 01       	movw	r22, r18
    3cb6:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vListInsertEnd>
    3cba:	0a c0       	rjmp	.+20     	; 0x3cd0 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3cbc:	8a 81       	ldd	r24, Y+2	; 0x02
    3cbe:	9b 81       	ldd	r25, Y+3	; 0x03
    3cc0:	9c 01       	movw	r18, r24
    3cc2:	24 5f       	subi	r18, 0xF4	; 244
    3cc4:	3f 4f       	sbci	r19, 0xFF	; 255
    3cc6:	8e ee       	ldi	r24, 0xEE	; 238
    3cc8:	95 e0       	ldi	r25, 0x05	; 5
    3cca:	b9 01       	movw	r22, r18
    3ccc:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3cd0:	ea 81       	ldd	r30, Y+2	; 0x02
    3cd2:	fb 81       	ldd	r31, Y+3	; 0x03
    3cd4:	96 89       	ldd	r25, Z+22	; 0x16
    3cd6:	e0 91 a6 05 	lds	r30, 0x05A6
    3cda:	f0 91 a7 05 	lds	r31, 0x05A7
    3cde:	86 89       	ldd	r24, Z+22	; 0x16
    3ce0:	98 17       	cp	r25, r24
    3ce2:	18 f0       	brcs	.+6      	; 0x3cea <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    3ce4:	81 e0       	ldi	r24, 0x01	; 1
    3ce6:	89 83       	std	Y+1, r24	; 0x01
    3ce8:	01 c0       	rjmp	.+2      	; 0x3cec <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    3cea:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3cec:	89 81       	ldd	r24, Y+1	; 0x01
}
    3cee:	0f 90       	pop	r0
    3cf0:	0f 90       	pop	r0
    3cf2:	0f 90       	pop	r0
    3cf4:	0f 90       	pop	r0
    3cf6:	0f 90       	pop	r0
    3cf8:	cf 91       	pop	r28
    3cfa:	df 91       	pop	r29
    3cfc:	08 95       	ret

00003cfe <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    3cfe:	df 93       	push	r29
    3d00:	cf 93       	push	r28
    3d02:	00 d0       	rcall	.+0      	; 0x3d04 <vTaskSetTimeOutState+0x6>
    3d04:	cd b7       	in	r28, 0x3d	; 61
    3d06:	de b7       	in	r29, 0x3e	; 62
    3d08:	9a 83       	std	Y+2, r25	; 0x02
    3d0a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3d0c:	80 91 b2 05 	lds	r24, 0x05B2
    3d10:	e9 81       	ldd	r30, Y+1	; 0x01
    3d12:	fa 81       	ldd	r31, Y+2	; 0x02
    3d14:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3d16:	80 91 aa 05 	lds	r24, 0x05AA
    3d1a:	90 91 ab 05 	lds	r25, 0x05AB
    3d1e:	e9 81       	ldd	r30, Y+1	; 0x01
    3d20:	fa 81       	ldd	r31, Y+2	; 0x02
    3d22:	92 83       	std	Z+2, r25	; 0x02
    3d24:	81 83       	std	Z+1, r24	; 0x01
}
    3d26:	0f 90       	pop	r0
    3d28:	0f 90       	pop	r0
    3d2a:	cf 91       	pop	r28
    3d2c:	df 91       	pop	r29
    3d2e:	08 95       	ret

00003d30 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    3d30:	df 93       	push	r29
    3d32:	cf 93       	push	r28
    3d34:	00 d0       	rcall	.+0      	; 0x3d36 <xTaskCheckForTimeOut+0x6>
    3d36:	00 d0       	rcall	.+0      	; 0x3d38 <xTaskCheckForTimeOut+0x8>
    3d38:	0f 92       	push	r0
    3d3a:	cd b7       	in	r28, 0x3d	; 61
    3d3c:	de b7       	in	r29, 0x3e	; 62
    3d3e:	9b 83       	std	Y+3, r25	; 0x03
    3d40:	8a 83       	std	Y+2, r24	; 0x02
    3d42:	7d 83       	std	Y+5, r23	; 0x05
    3d44:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3d46:	0f b6       	in	r0, 0x3f	; 63
    3d48:	f8 94       	cli
    3d4a:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    3d4c:	ea 81       	ldd	r30, Y+2	; 0x02
    3d4e:	fb 81       	ldd	r31, Y+3	; 0x03
    3d50:	90 81       	ld	r25, Z
    3d52:	80 91 b2 05 	lds	r24, 0x05B2
    3d56:	98 17       	cp	r25, r24
    3d58:	71 f0       	breq	.+28     	; 0x3d76 <xTaskCheckForTimeOut+0x46>
    3d5a:	ea 81       	ldd	r30, Y+2	; 0x02
    3d5c:	fb 81       	ldd	r31, Y+3	; 0x03
    3d5e:	21 81       	ldd	r18, Z+1	; 0x01
    3d60:	32 81       	ldd	r19, Z+2	; 0x02
    3d62:	80 91 aa 05 	lds	r24, 0x05AA
    3d66:	90 91 ab 05 	lds	r25, 0x05AB
    3d6a:	82 17       	cp	r24, r18
    3d6c:	93 07       	cpc	r25, r19
    3d6e:	18 f0       	brcs	.+6      	; 0x3d76 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    3d70:	81 e0       	ldi	r24, 0x01	; 1
    3d72:	89 83       	std	Y+1, r24	; 0x01
    3d74:	2f c0       	rjmp	.+94     	; 0x3dd4 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    3d76:	20 91 aa 05 	lds	r18, 0x05AA
    3d7a:	30 91 ab 05 	lds	r19, 0x05AB
    3d7e:	ea 81       	ldd	r30, Y+2	; 0x02
    3d80:	fb 81       	ldd	r31, Y+3	; 0x03
    3d82:	81 81       	ldd	r24, Z+1	; 0x01
    3d84:	92 81       	ldd	r25, Z+2	; 0x02
    3d86:	28 1b       	sub	r18, r24
    3d88:	39 0b       	sbc	r19, r25
    3d8a:	ec 81       	ldd	r30, Y+4	; 0x04
    3d8c:	fd 81       	ldd	r31, Y+5	; 0x05
    3d8e:	80 81       	ld	r24, Z
    3d90:	91 81       	ldd	r25, Z+1	; 0x01
    3d92:	28 17       	cp	r18, r24
    3d94:	39 07       	cpc	r19, r25
    3d96:	e0 f4       	brcc	.+56     	; 0x3dd0 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    3d98:	ec 81       	ldd	r30, Y+4	; 0x04
    3d9a:	fd 81       	ldd	r31, Y+5	; 0x05
    3d9c:	40 81       	ld	r20, Z
    3d9e:	51 81       	ldd	r21, Z+1	; 0x01
    3da0:	ea 81       	ldd	r30, Y+2	; 0x02
    3da2:	fb 81       	ldd	r31, Y+3	; 0x03
    3da4:	21 81       	ldd	r18, Z+1	; 0x01
    3da6:	32 81       	ldd	r19, Z+2	; 0x02
    3da8:	80 91 aa 05 	lds	r24, 0x05AA
    3dac:	90 91 ab 05 	lds	r25, 0x05AB
    3db0:	b9 01       	movw	r22, r18
    3db2:	68 1b       	sub	r22, r24
    3db4:	79 0b       	sbc	r23, r25
    3db6:	cb 01       	movw	r24, r22
    3db8:	84 0f       	add	r24, r20
    3dba:	95 1f       	adc	r25, r21
    3dbc:	ec 81       	ldd	r30, Y+4	; 0x04
    3dbe:	fd 81       	ldd	r31, Y+5	; 0x05
    3dc0:	91 83       	std	Z+1, r25	; 0x01
    3dc2:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    3dc4:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc6:	9b 81       	ldd	r25, Y+3	; 0x03
    3dc8:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3dcc:	19 82       	std	Y+1, r1	; 0x01
    3dce:	02 c0       	rjmp	.+4      	; 0x3dd4 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    3dd0:	81 e0       	ldi	r24, 0x01	; 1
    3dd2:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3dd4:	0f 90       	pop	r0
    3dd6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3dd8:	89 81       	ldd	r24, Y+1	; 0x01
}
    3dda:	0f 90       	pop	r0
    3ddc:	0f 90       	pop	r0
    3dde:	0f 90       	pop	r0
    3de0:	0f 90       	pop	r0
    3de2:	0f 90       	pop	r0
    3de4:	cf 91       	pop	r28
    3de6:	df 91       	pop	r29
    3de8:	08 95       	ret

00003dea <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3dea:	df 93       	push	r29
    3dec:	cf 93       	push	r28
    3dee:	cd b7       	in	r28, 0x3d	; 61
    3df0:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    3df2:	81 e0       	ldi	r24, 0x01	; 1
    3df4:	80 93 b1 05 	sts	0x05B1, r24
}
    3df8:	cf 91       	pop	r28
    3dfa:	df 91       	pop	r29
    3dfc:	08 95       	ret

00003dfe <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3dfe:	df 93       	push	r29
    3e00:	cf 93       	push	r28
    3e02:	00 d0       	rcall	.+0      	; 0x3e04 <prvIdleTask+0x6>
    3e04:	cd b7       	in	r28, 0x3d	; 61
    3e06:	de b7       	in	r29, 0x3e	; 62
    3e08:	9a 83       	std	Y+2, r25	; 0x02
    3e0a:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    3e0c:	0e 94 9d 1f 	call	0x3f3a	; 0x3f3a <prvCheckTasksWaitingTermination>
    3e10:	fd cf       	rjmp	.-6      	; 0x3e0c <prvIdleTask+0xe>

00003e12 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    3e12:	0f 93       	push	r16
    3e14:	1f 93       	push	r17
    3e16:	df 93       	push	r29
    3e18:	cf 93       	push	r28
    3e1a:	cd b7       	in	r28, 0x3d	; 61
    3e1c:	de b7       	in	r29, 0x3e	; 62
    3e1e:	29 97       	sbiw	r28, 0x09	; 9
    3e20:	0f b6       	in	r0, 0x3f	; 63
    3e22:	f8 94       	cli
    3e24:	de bf       	out	0x3e, r29	; 62
    3e26:	0f be       	out	0x3f, r0	; 63
    3e28:	cd bf       	out	0x3d, r28	; 61
    3e2a:	9a 83       	std	Y+2, r25	; 0x02
    3e2c:	89 83       	std	Y+1, r24	; 0x01
    3e2e:	7c 83       	std	Y+4, r23	; 0x04
    3e30:	6b 83       	std	Y+3, r22	; 0x03
    3e32:	4d 83       	std	Y+5, r20	; 0x05
    3e34:	3f 83       	std	Y+7, r19	; 0x07
    3e36:	2e 83       	std	Y+6, r18	; 0x06
    3e38:	19 87       	std	Y+9, r17	; 0x09
    3e3a:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    3e3c:	89 81       	ldd	r24, Y+1	; 0x01
    3e3e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e40:	49 96       	adiw	r24, 0x19	; 25
    3e42:	2b 81       	ldd	r18, Y+3	; 0x03
    3e44:	3c 81       	ldd	r19, Y+4	; 0x04
    3e46:	b9 01       	movw	r22, r18
    3e48:	48 e0       	ldi	r20, 0x08	; 8
    3e4a:	50 e0       	ldi	r21, 0x00	; 0
    3e4c:	0e 94 2d 21 	call	0x425a	; 0x425a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    3e50:	e9 81       	ldd	r30, Y+1	; 0x01
    3e52:	fa 81       	ldd	r31, Y+2	; 0x02
    3e54:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    3e56:	8d 81       	ldd	r24, Y+5	; 0x05
    3e58:	84 30       	cpi	r24, 0x04	; 4
    3e5a:	10 f0       	brcs	.+4      	; 0x3e60 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    3e5c:	83 e0       	ldi	r24, 0x03	; 3
    3e5e:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    3e60:	e9 81       	ldd	r30, Y+1	; 0x01
    3e62:	fa 81       	ldd	r31, Y+2	; 0x02
    3e64:	8d 81       	ldd	r24, Y+5	; 0x05
    3e66:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    3e68:	89 81       	ldd	r24, Y+1	; 0x01
    3e6a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e6c:	02 96       	adiw	r24, 0x02	; 2
    3e6e:	0e 94 e7 10 	call	0x21ce	; 0x21ce <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    3e72:	89 81       	ldd	r24, Y+1	; 0x01
    3e74:	9a 81       	ldd	r25, Y+2	; 0x02
    3e76:	0c 96       	adiw	r24, 0x0c	; 12
    3e78:	0e 94 e7 10 	call	0x21ce	; 0x21ce <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    3e7c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e7e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e80:	89 81       	ldd	r24, Y+1	; 0x01
    3e82:	9a 81       	ldd	r25, Y+2	; 0x02
    3e84:	91 87       	std	Z+9, r25	; 0x09
    3e86:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    3e88:	8d 81       	ldd	r24, Y+5	; 0x05
    3e8a:	28 2f       	mov	r18, r24
    3e8c:	30 e0       	ldi	r19, 0x00	; 0
    3e8e:	84 e0       	ldi	r24, 0x04	; 4
    3e90:	90 e0       	ldi	r25, 0x00	; 0
    3e92:	82 1b       	sub	r24, r18
    3e94:	93 0b       	sbc	r25, r19
    3e96:	e9 81       	ldd	r30, Y+1	; 0x01
    3e98:	fa 81       	ldd	r31, Y+2	; 0x02
    3e9a:	95 87       	std	Z+13, r25	; 0x0d
    3e9c:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    3e9e:	e9 81       	ldd	r30, Y+1	; 0x01
    3ea0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ea2:	89 81       	ldd	r24, Y+1	; 0x01
    3ea4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ea6:	93 8b       	std	Z+19, r25	; 0x13
    3ea8:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    3eaa:	29 96       	adiw	r28, 0x09	; 9
    3eac:	0f b6       	in	r0, 0x3f	; 63
    3eae:	f8 94       	cli
    3eb0:	de bf       	out	0x3e, r29	; 62
    3eb2:	0f be       	out	0x3f, r0	; 63
    3eb4:	cd bf       	out	0x3d, r28	; 61
    3eb6:	cf 91       	pop	r28
    3eb8:	df 91       	pop	r29
    3eba:	1f 91       	pop	r17
    3ebc:	0f 91       	pop	r16
    3ebe:	08 95       	ret

00003ec0 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    3ec0:	df 93       	push	r29
    3ec2:	cf 93       	push	r28
    3ec4:	0f 92       	push	r0
    3ec6:	cd b7       	in	r28, 0x3d	; 61
    3ec8:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    3eca:	19 82       	std	Y+1, r1	; 0x01
    3ecc:	13 c0       	rjmp	.+38     	; 0x3ef4 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    3ece:	89 81       	ldd	r24, Y+1	; 0x01
    3ed0:	28 2f       	mov	r18, r24
    3ed2:	30 e0       	ldi	r19, 0x00	; 0
    3ed4:	c9 01       	movw	r24, r18
    3ed6:	88 0f       	add	r24, r24
    3ed8:	99 1f       	adc	r25, r25
    3eda:	88 0f       	add	r24, r24
    3edc:	99 1f       	adc	r25, r25
    3ede:	88 0f       	add	r24, r24
    3ee0:	99 1f       	adc	r25, r25
    3ee2:	82 0f       	add	r24, r18
    3ee4:	93 1f       	adc	r25, r19
    3ee6:	8c 54       	subi	r24, 0x4C	; 76
    3ee8:	9a 4f       	sbci	r25, 0xFA	; 250
    3eea:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    3eee:	89 81       	ldd	r24, Y+1	; 0x01
    3ef0:	8f 5f       	subi	r24, 0xFF	; 255
    3ef2:	89 83       	std	Y+1, r24	; 0x01
    3ef4:	89 81       	ldd	r24, Y+1	; 0x01
    3ef6:	84 30       	cpi	r24, 0x04	; 4
    3ef8:	50 f3       	brcs	.-44     	; 0x3ece <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    3efa:	88 ed       	ldi	r24, 0xD8	; 216
    3efc:	95 e0       	ldi	r25, 0x05	; 5
    3efe:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    3f02:	81 ee       	ldi	r24, 0xE1	; 225
    3f04:	95 e0       	ldi	r25, 0x05	; 5
    3f06:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    3f0a:	8e ee       	ldi	r24, 0xEE	; 238
    3f0c:	95 e0       	ldi	r25, 0x05	; 5
    3f0e:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    3f12:	87 ef       	ldi	r24, 0xF7	; 247
    3f14:	95 e0       	ldi	r25, 0x05	; 5
    3f16:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3f1a:	88 ed       	ldi	r24, 0xD8	; 216
    3f1c:	95 e0       	ldi	r25, 0x05	; 5
    3f1e:	90 93 eb 05 	sts	0x05EB, r25
    3f22:	80 93 ea 05 	sts	0x05EA, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3f26:	81 ee       	ldi	r24, 0xE1	; 225
    3f28:	95 e0       	ldi	r25, 0x05	; 5
    3f2a:	90 93 ed 05 	sts	0x05ED, r25
    3f2e:	80 93 ec 05 	sts	0x05EC, r24
}
    3f32:	0f 90       	pop	r0
    3f34:	cf 91       	pop	r28
    3f36:	df 91       	pop	r29
    3f38:	08 95       	ret

00003f3a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3f3a:	df 93       	push	r29
    3f3c:	cf 93       	push	r28
    3f3e:	00 d0       	rcall	.+0      	; 0x3f40 <prvCheckTasksWaitingTermination+0x6>
    3f40:	0f 92       	push	r0
    3f42:	cd b7       	in	r28, 0x3d	; 61
    3f44:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    3f46:	80 91 a8 05 	lds	r24, 0x05A8
    3f4a:	88 23       	and	r24, r24
    3f4c:	71 f1       	breq	.+92     	; 0x3faa <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    3f4e:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    3f52:	80 91 f7 05 	lds	r24, 0x05F7
    3f56:	1b 82       	std	Y+3, r1	; 0x03
    3f58:	88 23       	and	r24, r24
    3f5a:	11 f4       	brne	.+4      	; 0x3f60 <prvCheckTasksWaitingTermination+0x26>
    3f5c:	81 e0       	ldi	r24, 0x01	; 1
    3f5e:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    3f60:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    3f64:	8b 81       	ldd	r24, Y+3	; 0x03
    3f66:	88 23       	and	r24, r24
    3f68:	01 f5       	brne	.+64     	; 0x3faa <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    3f6a:	0f b6       	in	r0, 0x3f	; 63
    3f6c:	f8 94       	cli
    3f6e:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    3f70:	e0 91 fc 05 	lds	r30, 0x05FC
    3f74:	f0 91 fd 05 	lds	r31, 0x05FD
    3f78:	86 81       	ldd	r24, Z+6	; 0x06
    3f7a:	97 81       	ldd	r25, Z+7	; 0x07
    3f7c:	9a 83       	std	Y+2, r25	; 0x02
    3f7e:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    3f80:	89 81       	ldd	r24, Y+1	; 0x01
    3f82:	9a 81       	ldd	r25, Y+2	; 0x02
    3f84:	02 96       	adiw	r24, 0x02	; 2
    3f86:	0e 94 af 11 	call	0x235e	; 0x235e <vListRemove>
					--uxCurrentNumberOfTasks;
    3f8a:	80 91 a9 05 	lds	r24, 0x05A9
    3f8e:	81 50       	subi	r24, 0x01	; 1
    3f90:	80 93 a9 05 	sts	0x05A9, r24
					--uxTasksDeleted;
    3f94:	80 91 a8 05 	lds	r24, 0x05A8
    3f98:	81 50       	subi	r24, 0x01	; 1
    3f9a:	80 93 a8 05 	sts	0x05A8, r24
				}
				taskEXIT_CRITICAL();
    3f9e:	0f 90       	pop	r0
    3fa0:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    3fa2:	89 81       	ldd	r24, Y+1	; 0x01
    3fa4:	9a 81       	ldd	r25, Y+2	; 0x02
    3fa6:	0e 94 74 20 	call	0x40e8	; 0x40e8 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    3faa:	0f 90       	pop	r0
    3fac:	0f 90       	pop	r0
    3fae:	0f 90       	pop	r0
    3fb0:	cf 91       	pop	r28
    3fb2:	df 91       	pop	r29
    3fb4:	08 95       	ret

00003fb6 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    3fb6:	df 93       	push	r29
    3fb8:	cf 93       	push	r28
    3fba:	00 d0       	rcall	.+0      	; 0x3fbc <prvAddCurrentTaskToDelayedList+0x6>
    3fbc:	cd b7       	in	r28, 0x3d	; 61
    3fbe:	de b7       	in	r29, 0x3e	; 62
    3fc0:	9a 83       	std	Y+2, r25	; 0x02
    3fc2:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    3fc4:	e0 91 a6 05 	lds	r30, 0x05A6
    3fc8:	f0 91 a7 05 	lds	r31, 0x05A7
    3fcc:	89 81       	ldd	r24, Y+1	; 0x01
    3fce:	9a 81       	ldd	r25, Y+2	; 0x02
    3fd0:	93 83       	std	Z+3, r25	; 0x03
    3fd2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    3fd4:	20 91 aa 05 	lds	r18, 0x05AA
    3fd8:	30 91 ab 05 	lds	r19, 0x05AB
    3fdc:	89 81       	ldd	r24, Y+1	; 0x01
    3fde:	9a 81       	ldd	r25, Y+2	; 0x02
    3fe0:	82 17       	cp	r24, r18
    3fe2:	93 07       	cpc	r25, r19
    3fe4:	70 f4       	brcc	.+28     	; 0x4002 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3fe6:	80 91 ec 05 	lds	r24, 0x05EC
    3fea:	90 91 ed 05 	lds	r25, 0x05ED
    3fee:	20 91 a6 05 	lds	r18, 0x05A6
    3ff2:	30 91 a7 05 	lds	r19, 0x05A7
    3ff6:	2e 5f       	subi	r18, 0xFE	; 254
    3ff8:	3f 4f       	sbci	r19, 0xFF	; 255
    3ffa:	b9 01       	movw	r22, r18
    3ffc:	0e 94 43 11 	call	0x2286	; 0x2286 <vListInsert>
    4000:	1e c0       	rjmp	.+60     	; 0x403e <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4002:	40 91 ea 05 	lds	r20, 0x05EA
    4006:	50 91 eb 05 	lds	r21, 0x05EB
    400a:	80 91 a6 05 	lds	r24, 0x05A6
    400e:	90 91 a7 05 	lds	r25, 0x05A7
    4012:	9c 01       	movw	r18, r24
    4014:	2e 5f       	subi	r18, 0xFE	; 254
    4016:	3f 4f       	sbci	r19, 0xFF	; 255
    4018:	ca 01       	movw	r24, r20
    401a:	b9 01       	movw	r22, r18
    401c:	0e 94 43 11 	call	0x2286	; 0x2286 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    4020:	20 91 7f 01 	lds	r18, 0x017F
    4024:	30 91 80 01 	lds	r19, 0x0180
    4028:	89 81       	ldd	r24, Y+1	; 0x01
    402a:	9a 81       	ldd	r25, Y+2	; 0x02
    402c:	82 17       	cp	r24, r18
    402e:	93 07       	cpc	r25, r19
    4030:	30 f4       	brcc	.+12     	; 0x403e <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4032:	89 81       	ldd	r24, Y+1	; 0x01
    4034:	9a 81       	ldd	r25, Y+2	; 0x02
    4036:	90 93 80 01 	sts	0x0180, r25
    403a:	80 93 7f 01 	sts	0x017F, r24
		}
	}
}
    403e:	0f 90       	pop	r0
    4040:	0f 90       	pop	r0
    4042:	cf 91       	pop	r28
    4044:	df 91       	pop	r29
    4046:	08 95       	ret

00004048 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    4048:	df 93       	push	r29
    404a:	cf 93       	push	r28
    404c:	cd b7       	in	r28, 0x3d	; 61
    404e:	de b7       	in	r29, 0x3e	; 62
    4050:	28 97       	sbiw	r28, 0x08	; 8
    4052:	0f b6       	in	r0, 0x3f	; 63
    4054:	f8 94       	cli
    4056:	de bf       	out	0x3e, r29	; 62
    4058:	0f be       	out	0x3f, r0	; 63
    405a:	cd bf       	out	0x3d, r28	; 61
    405c:	9c 83       	std	Y+4, r25	; 0x04
    405e:	8b 83       	std	Y+3, r24	; 0x03
    4060:	7e 83       	std	Y+6, r23	; 0x06
    4062:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    4064:	81 e2       	ldi	r24, 0x21	; 33
    4066:	90 e0       	ldi	r25, 0x00	; 0
    4068:	0e 94 51 10 	call	0x20a2	; 0x20a2 <pvPortMalloc>
    406c:	9a 83       	std	Y+2, r25	; 0x02
    406e:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4070:	89 81       	ldd	r24, Y+1	; 0x01
    4072:	9a 81       	ldd	r25, Y+2	; 0x02
    4074:	00 97       	sbiw	r24, 0x00	; 0
    4076:	69 f1       	breq	.+90     	; 0x40d2 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    4078:	8d 81       	ldd	r24, Y+5	; 0x05
    407a:	9e 81       	ldd	r25, Y+6	; 0x06
    407c:	00 97       	sbiw	r24, 0x00	; 0
    407e:	39 f4       	brne	.+14     	; 0x408e <prvAllocateTCBAndStack+0x46>
    4080:	8b 81       	ldd	r24, Y+3	; 0x03
    4082:	9c 81       	ldd	r25, Y+4	; 0x04
    4084:	0e 94 51 10 	call	0x20a2	; 0x20a2 <pvPortMalloc>
    4088:	98 87       	std	Y+8, r25	; 0x08
    408a:	8f 83       	std	Y+7, r24	; 0x07
    408c:	04 c0       	rjmp	.+8      	; 0x4096 <prvAllocateTCBAndStack+0x4e>
    408e:	8d 81       	ldd	r24, Y+5	; 0x05
    4090:	9e 81       	ldd	r25, Y+6	; 0x06
    4092:	98 87       	std	Y+8, r25	; 0x08
    4094:	8f 83       	std	Y+7, r24	; 0x07
    4096:	e9 81       	ldd	r30, Y+1	; 0x01
    4098:	fa 81       	ldd	r31, Y+2	; 0x02
    409a:	8f 81       	ldd	r24, Y+7	; 0x07
    409c:	98 85       	ldd	r25, Y+8	; 0x08
    409e:	90 8f       	std	Z+24, r25	; 0x18
    40a0:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    40a2:	e9 81       	ldd	r30, Y+1	; 0x01
    40a4:	fa 81       	ldd	r31, Y+2	; 0x02
    40a6:	87 89       	ldd	r24, Z+23	; 0x17
    40a8:	90 8d       	ldd	r25, Z+24	; 0x18
    40aa:	00 97       	sbiw	r24, 0x00	; 0
    40ac:	39 f4       	brne	.+14     	; 0x40bc <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    40ae:	89 81       	ldd	r24, Y+1	; 0x01
    40b0:	9a 81       	ldd	r25, Y+2	; 0x02
    40b2:	0e 94 97 10 	call	0x212e	; 0x212e <vPortFree>
			pxNewTCB = NULL;
    40b6:	1a 82       	std	Y+2, r1	; 0x02
    40b8:	19 82       	std	Y+1, r1	; 0x01
    40ba:	0b c0       	rjmp	.+22     	; 0x40d2 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    40bc:	e9 81       	ldd	r30, Y+1	; 0x01
    40be:	fa 81       	ldd	r31, Y+2	; 0x02
    40c0:	87 89       	ldd	r24, Z+23	; 0x17
    40c2:	90 8d       	ldd	r25, Z+24	; 0x18
    40c4:	2b 81       	ldd	r18, Y+3	; 0x03
    40c6:	3c 81       	ldd	r19, Y+4	; 0x04
    40c8:	65 ea       	ldi	r22, 0xA5	; 165
    40ca:	70 e0       	ldi	r23, 0x00	; 0
    40cc:	a9 01       	movw	r20, r18
    40ce:	0e 94 26 21 	call	0x424c	; 0x424c <memset>
		}
	}

	return pxNewTCB;
    40d2:	89 81       	ldd	r24, Y+1	; 0x01
    40d4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    40d6:	28 96       	adiw	r28, 0x08	; 8
    40d8:	0f b6       	in	r0, 0x3f	; 63
    40da:	f8 94       	cli
    40dc:	de bf       	out	0x3e, r29	; 62
    40de:	0f be       	out	0x3f, r0	; 63
    40e0:	cd bf       	out	0x3d, r28	; 61
    40e2:	cf 91       	pop	r28
    40e4:	df 91       	pop	r29
    40e6:	08 95       	ret

000040e8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    40e8:	df 93       	push	r29
    40ea:	cf 93       	push	r28
    40ec:	00 d0       	rcall	.+0      	; 0x40ee <prvDeleteTCB+0x6>
    40ee:	cd b7       	in	r28, 0x3d	; 61
    40f0:	de b7       	in	r29, 0x3e	; 62
    40f2:	9a 83       	std	Y+2, r25	; 0x02
    40f4:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    40f6:	e9 81       	ldd	r30, Y+1	; 0x01
    40f8:	fa 81       	ldd	r31, Y+2	; 0x02
    40fa:	87 89       	ldd	r24, Z+23	; 0x17
    40fc:	90 8d       	ldd	r25, Z+24	; 0x18
    40fe:	0e 94 97 10 	call	0x212e	; 0x212e <vPortFree>
		vPortFree( pxTCB );
    4102:	89 81       	ldd	r24, Y+1	; 0x01
    4104:	9a 81       	ldd	r25, Y+2	; 0x02
    4106:	0e 94 97 10 	call	0x212e	; 0x212e <vPortFree>
	}
    410a:	0f 90       	pop	r0
    410c:	0f 90       	pop	r0
    410e:	cf 91       	pop	r28
    4110:	df 91       	pop	r29
    4112:	08 95       	ret

00004114 <__mulsi3>:
    4114:	62 9f       	mul	r22, r18
    4116:	d0 01       	movw	r26, r0
    4118:	73 9f       	mul	r23, r19
    411a:	f0 01       	movw	r30, r0
    411c:	82 9f       	mul	r24, r18
    411e:	e0 0d       	add	r30, r0
    4120:	f1 1d       	adc	r31, r1
    4122:	64 9f       	mul	r22, r20
    4124:	e0 0d       	add	r30, r0
    4126:	f1 1d       	adc	r31, r1
    4128:	92 9f       	mul	r25, r18
    412a:	f0 0d       	add	r31, r0
    412c:	83 9f       	mul	r24, r19
    412e:	f0 0d       	add	r31, r0
    4130:	74 9f       	mul	r23, r20
    4132:	f0 0d       	add	r31, r0
    4134:	65 9f       	mul	r22, r21
    4136:	f0 0d       	add	r31, r0
    4138:	99 27       	eor	r25, r25
    413a:	72 9f       	mul	r23, r18
    413c:	b0 0d       	add	r27, r0
    413e:	e1 1d       	adc	r30, r1
    4140:	f9 1f       	adc	r31, r25
    4142:	63 9f       	mul	r22, r19
    4144:	b0 0d       	add	r27, r0
    4146:	e1 1d       	adc	r30, r1
    4148:	f9 1f       	adc	r31, r25
    414a:	bd 01       	movw	r22, r26
    414c:	cf 01       	movw	r24, r30
    414e:	11 24       	eor	r1, r1
    4150:	08 95       	ret

00004152 <__udivmodsi4>:
    4152:	a1 e2       	ldi	r26, 0x21	; 33
    4154:	1a 2e       	mov	r1, r26
    4156:	aa 1b       	sub	r26, r26
    4158:	bb 1b       	sub	r27, r27
    415a:	fd 01       	movw	r30, r26
    415c:	0d c0       	rjmp	.+26     	; 0x4178 <__udivmodsi4_ep>

0000415e <__udivmodsi4_loop>:
    415e:	aa 1f       	adc	r26, r26
    4160:	bb 1f       	adc	r27, r27
    4162:	ee 1f       	adc	r30, r30
    4164:	ff 1f       	adc	r31, r31
    4166:	a2 17       	cp	r26, r18
    4168:	b3 07       	cpc	r27, r19
    416a:	e4 07       	cpc	r30, r20
    416c:	f5 07       	cpc	r31, r21
    416e:	20 f0       	brcs	.+8      	; 0x4178 <__udivmodsi4_ep>
    4170:	a2 1b       	sub	r26, r18
    4172:	b3 0b       	sbc	r27, r19
    4174:	e4 0b       	sbc	r30, r20
    4176:	f5 0b       	sbc	r31, r21

00004178 <__udivmodsi4_ep>:
    4178:	66 1f       	adc	r22, r22
    417a:	77 1f       	adc	r23, r23
    417c:	88 1f       	adc	r24, r24
    417e:	99 1f       	adc	r25, r25
    4180:	1a 94       	dec	r1
    4182:	69 f7       	brne	.-38     	; 0x415e <__udivmodsi4_loop>
    4184:	60 95       	com	r22
    4186:	70 95       	com	r23
    4188:	80 95       	com	r24
    418a:	90 95       	com	r25
    418c:	9b 01       	movw	r18, r22
    418e:	ac 01       	movw	r20, r24
    4190:	bd 01       	movw	r22, r26
    4192:	cf 01       	movw	r24, r30
    4194:	08 95       	ret

00004196 <__divmodsi4>:
    4196:	97 fb       	bst	r25, 7
    4198:	09 2e       	mov	r0, r25
    419a:	05 26       	eor	r0, r21
    419c:	0e d0       	rcall	.+28     	; 0x41ba <__divmodsi4_neg1>
    419e:	57 fd       	sbrc	r21, 7
    41a0:	04 d0       	rcall	.+8      	; 0x41aa <__divmodsi4_neg2>
    41a2:	d7 df       	rcall	.-82     	; 0x4152 <__udivmodsi4>
    41a4:	0a d0       	rcall	.+20     	; 0x41ba <__divmodsi4_neg1>
    41a6:	00 1c       	adc	r0, r0
    41a8:	38 f4       	brcc	.+14     	; 0x41b8 <__divmodsi4_exit>

000041aa <__divmodsi4_neg2>:
    41aa:	50 95       	com	r21
    41ac:	40 95       	com	r20
    41ae:	30 95       	com	r19
    41b0:	21 95       	neg	r18
    41b2:	3f 4f       	sbci	r19, 0xFF	; 255
    41b4:	4f 4f       	sbci	r20, 0xFF	; 255
    41b6:	5f 4f       	sbci	r21, 0xFF	; 255

000041b8 <__divmodsi4_exit>:
    41b8:	08 95       	ret

000041ba <__divmodsi4_neg1>:
    41ba:	f6 f7       	brtc	.-4      	; 0x41b8 <__divmodsi4_exit>
    41bc:	90 95       	com	r25
    41be:	80 95       	com	r24
    41c0:	70 95       	com	r23
    41c2:	61 95       	neg	r22
    41c4:	7f 4f       	sbci	r23, 0xFF	; 255
    41c6:	8f 4f       	sbci	r24, 0xFF	; 255
    41c8:	9f 4f       	sbci	r25, 0xFF	; 255
    41ca:	08 95       	ret

000041cc <__prologue_saves__>:
    41cc:	2f 92       	push	r2
    41ce:	3f 92       	push	r3
    41d0:	4f 92       	push	r4
    41d2:	5f 92       	push	r5
    41d4:	6f 92       	push	r6
    41d6:	7f 92       	push	r7
    41d8:	8f 92       	push	r8
    41da:	9f 92       	push	r9
    41dc:	af 92       	push	r10
    41de:	bf 92       	push	r11
    41e0:	cf 92       	push	r12
    41e2:	df 92       	push	r13
    41e4:	ef 92       	push	r14
    41e6:	ff 92       	push	r15
    41e8:	0f 93       	push	r16
    41ea:	1f 93       	push	r17
    41ec:	cf 93       	push	r28
    41ee:	df 93       	push	r29
    41f0:	cd b7       	in	r28, 0x3d	; 61
    41f2:	de b7       	in	r29, 0x3e	; 62
    41f4:	ca 1b       	sub	r28, r26
    41f6:	db 0b       	sbc	r29, r27
    41f8:	0f b6       	in	r0, 0x3f	; 63
    41fa:	f8 94       	cli
    41fc:	de bf       	out	0x3e, r29	; 62
    41fe:	0f be       	out	0x3f, r0	; 63
    4200:	cd bf       	out	0x3d, r28	; 61
    4202:	09 94       	ijmp

00004204 <__epilogue_restores__>:
    4204:	2a 88       	ldd	r2, Y+18	; 0x12
    4206:	39 88       	ldd	r3, Y+17	; 0x11
    4208:	48 88       	ldd	r4, Y+16	; 0x10
    420a:	5f 84       	ldd	r5, Y+15	; 0x0f
    420c:	6e 84       	ldd	r6, Y+14	; 0x0e
    420e:	7d 84       	ldd	r7, Y+13	; 0x0d
    4210:	8c 84       	ldd	r8, Y+12	; 0x0c
    4212:	9b 84       	ldd	r9, Y+11	; 0x0b
    4214:	aa 84       	ldd	r10, Y+10	; 0x0a
    4216:	b9 84       	ldd	r11, Y+9	; 0x09
    4218:	c8 84       	ldd	r12, Y+8	; 0x08
    421a:	df 80       	ldd	r13, Y+7	; 0x07
    421c:	ee 80       	ldd	r14, Y+6	; 0x06
    421e:	fd 80       	ldd	r15, Y+5	; 0x05
    4220:	0c 81       	ldd	r16, Y+4	; 0x04
    4222:	1b 81       	ldd	r17, Y+3	; 0x03
    4224:	aa 81       	ldd	r26, Y+2	; 0x02
    4226:	b9 81       	ldd	r27, Y+1	; 0x01
    4228:	ce 0f       	add	r28, r30
    422a:	d1 1d       	adc	r29, r1
    422c:	0f b6       	in	r0, 0x3f	; 63
    422e:	f8 94       	cli
    4230:	de bf       	out	0x3e, r29	; 62
    4232:	0f be       	out	0x3f, r0	; 63
    4234:	cd bf       	out	0x3d, r28	; 61
    4236:	ed 01       	movw	r28, r26
    4238:	08 95       	ret

0000423a <memcpy>:
    423a:	fb 01       	movw	r30, r22
    423c:	dc 01       	movw	r26, r24
    423e:	02 c0       	rjmp	.+4      	; 0x4244 <memcpy+0xa>
    4240:	01 90       	ld	r0, Z+
    4242:	0d 92       	st	X+, r0
    4244:	41 50       	subi	r20, 0x01	; 1
    4246:	50 40       	sbci	r21, 0x00	; 0
    4248:	d8 f7       	brcc	.-10     	; 0x4240 <memcpy+0x6>
    424a:	08 95       	ret

0000424c <memset>:
    424c:	dc 01       	movw	r26, r24
    424e:	01 c0       	rjmp	.+2      	; 0x4252 <memset+0x6>
    4250:	6d 93       	st	X+, r22
    4252:	41 50       	subi	r20, 0x01	; 1
    4254:	50 40       	sbci	r21, 0x00	; 0
    4256:	e0 f7       	brcc	.-8      	; 0x4250 <memset+0x4>
    4258:	08 95       	ret

0000425a <strncpy>:
    425a:	fb 01       	movw	r30, r22
    425c:	dc 01       	movw	r26, r24
    425e:	41 50       	subi	r20, 0x01	; 1
    4260:	50 40       	sbci	r21, 0x00	; 0
    4262:	48 f0       	brcs	.+18     	; 0x4276 <strncpy+0x1c>
    4264:	01 90       	ld	r0, Z+
    4266:	0d 92       	st	X+, r0
    4268:	00 20       	and	r0, r0
    426a:	c9 f7       	brne	.-14     	; 0x425e <strncpy+0x4>
    426c:	01 c0       	rjmp	.+2      	; 0x4270 <strncpy+0x16>
    426e:	1d 92       	st	X+, r1
    4270:	41 50       	subi	r20, 0x01	; 1
    4272:	50 40       	sbci	r21, 0x00	; 0
    4274:	e0 f7       	brcc	.-8      	; 0x426e <strncpy+0x14>
    4276:	08 95       	ret

00004278 <_exit>:
    4278:	f8 94       	cli

0000427a <__stop_program>:
    427a:	ff cf       	rjmp	.-2      	; 0x427a <__stop_program>
